# Authorization signatures
Source: https://docs.privy.io/api-reference/authorization-signatures

Securing Privy API requests with authorization signatures

Authorization signatures protect your resources and wallet operations by cryptographically signing API requests. When enabled, these signatures prevent malicious actors from tampering with your request payload or forging requests to your wallets, ensuring that only authorized servers can trigger wallet actions.

<Info>
  Authorization signatures are a security feature used to secure **update requests** to all critical
  resources.
</Info>

## Required headers

When using authorization signatures, include the following header with your request:

<ParamField header="privy-authorization-signature" type="string">
  The authorization signature. If multiple signatures are required, they should be comma separated.
</ParamField>

## When are they necessary?

### Modifying resources

All critical resources have an `owner_id` field, which indicates the authorization key or quorum whose signatures are required in order to modify the given resource.

This means, if the `owner_id` is set, authorization signatures are required for all `PATCH` and `DELETE` requests to the resource.

Key quorums do not have owners, but rather require a satisfaying set of signatures from the key quorum itself.

You can add additional, non-owner, signers to a wallet by specifying them in the [additional\_signers](/api-reference/wallets/create#body-additional-signers) field on the wallet resource.

### Taking actions with wallets

Signatures from the wallet's owner are required to take actions on a wallet by default. If an `owner_id` is set, authorization signatures are required for:

* POST requests to `/v1/wallets/<wallet_id>/rpc`

<Tip>
  Authorization signatures are an important security measure and we strongly recommend registering
  authorization keys for all production resources.
</Tip>

## How to use authorization signatures

In order to use authorization signatures, you need to:

1. Create an authorization key.
2. Register the authorization public key with the resource you wish to protect.
3. Begin using the authorization private key to sign requests via the `privy-authorization-signature` header.

### Creating authorization keys

To create a new authorization key via the Dashboard:

1. Visit the [Authorization keys](https://dashboard.privy.io/apps?page=authorization-keys) page in the Dashboard.
2. Click the **New key** button.
3. Copy and save the generated **Private key**.

Read more about [creating authorization keys](/controls/authorization-keys/creating-authorization-keys).

<Warning>
  The private key (e.g. the Authorization key you copy) is generated on your device. Privy only
  receives the public key for registration. The private key never leaves the client.
</Warning>

### Registering authorization keys

To register an authorization key with a resource, you need to specify the public key in the `owner` field when creating a resource (e.g. [wallet](/api-reference/wallets/create#body-owner) or [policy](/api-reference/policies/create#body-owner)).

### Generating signatures

You can generate authorization signatures in three ways:

* Using `PrivyClient` via the Server SDK. `PrivyClient` will automatically inject authorization signatures when required. [Learn more](/basics/nodeJS/setup#getting-the-privyclient).
* Using utility functions from the Server SDK such as `formatRequestForAuthorizationSignature` and `generateAuthorizationSignature`.
* Implementing your own signing logic.

Follow the steps below to generate an authorization signature with Server SDK utility functions or your own signing logic:

<Steps>
  <Step title="Build Payload">
    Generate a JSON payload containing the following fields. All fields are required unless otherwise specified.

    | Field                              | Type     | Description                                                                                                                                                                                                       |         |            |                                                                               |
    | ---------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------- | ---------- | ----------------------------------------------------------------------------- |
    | `version`                          | `1`      | Authorization signature version. Currently, `1` is the only version.                                                                                                                                              |         |            |                                                                               |
    | `method`                           | \`'POST' | 'PUT'                                                                                                                                                                                                             | 'PATCH' | 'DELETE'\` | HTTP method for the request. Signatures are not required on `'GET'` requests. |
    | `url`                              | `string` | The full URL for the request. Should not include a trailing slash.                                                                                                                                                |         |            |                                                                               |
    | `body`                             | `JSON`   | JSON body for the request.                                                                                                                                                                                        |         |            |                                                                               |
    | `headers`                          | `JSON`   | JSON object containing any Privy-specific headers, e.g. those that are prefixed with `'privy-'`. This should **not** include any other headers, such as authentication headers, `content-type`, or trace headers. |         |            |                                                                               |
    | `headers['privy-app-id']`          | `string` | Privy app ID header (required).                                                                                                                                                                                   |         |            |                                                                               |
    | `headers['privy-idempotency-key']` | `string` | Privy idempotency key header (optional). If the request does not contain an idempotency key, leave this field out of the payload.                                                                                 |         |            |                                                                               |
  </Step>

  <Step title="Format Payload">
    Canonicalize the payload per [RFC 8785](https://www.rfc-editor.org/rfc/rfc8785) and serialize it to a string. [This GitHub repository](https://github.com/cyberphone/json-canonicalization) links to various libraries for JSON canonicalization in different languages.

    ```ts
    // You can use the Server SDK to format and serialize the payload.
    import {formatRequestForAuthorizationSignature} from '@privy-io/server-auth/wallet-api';

    const input: WalletApiRequestSignatureInput = ...;
    const serializedPayload = formatRequestForAuthorizationSignature(input);
    ```
  </Step>

  <Step title="Sign Payload">
    Sign the serialized JSON with ECDSA P-256 using your app's private key and serialize it to a base64-encoded string.

    ```ts
    // You can use the Server SDK to generate an authorization signature.
    // Note that this function will format, serialize, and sign the payload, making Step 2 redundant.
    import {generateAuthorizationSignature} from '@privy-io/server-auth/wallet-api';

    const input: WalletApiRequestSignatureInput = ...;
    const signature = generateAuthorizationSignature(input, authorizationPrivateKey);
    ```
  </Step>
</Steps>

### Examples

<Tabs>
  <Tab title="@privy-io/server-auth">
    We recommend using `PrivyClient` to send WalletApi requests, which will automatically inject authorization signatures when required.

    However, if you must send WalletApi requests without `PrivyClient`, we recommend using `generateAuthorizationSignature` to sign the request or `formatRequestForAuthorizationSignature` to format and serialize the request if you need to sign elsewhere.

    <CodeGroup>
      ```ts PrivyClient
      import {PrivyClient} from '@privy-io/server-auth';

      const client = new PrivyClient($PRIVY_APP_ID, $PRIVY_APP_SECRET, {
        walletApi: {
          // This is required in order to generate the privy-authorization-signature header.
          authorizationPrivateKey: $PRIVY_AUTHORIZATION_PRIVATE_KEY
        }
      });

      // This request will automatically include the privy-authorization-signature header.
      const res = await privy.walletApi.ethereum.signMessage({
        walletId: $WALLET_ID,
        message: 'Hello world'
      });
      ```

      ```ts Formatting or signing
      // For some use cases, you may need to format and/or sign requests manually, separate from the PrivyClient.
      // The Server SDK provides two utility functions to support this.
      import {WalletApiRequestSignatureInput} from '@privy-io/server-auth';
      import {formatRequestForAuthorizationSignature, generateAuthorizationSignature} from '@privy-io/server-auth/wallet-api';

      // The AuthorizationPrivateKey is the private key copied from the Dashboard, prefixed with 'wallet-auth:'
      const authorizationPrivateKey: $YOUR_AUTHORIZATION_PRIVATE_KEY;

      const input = {
        version: 1,
        method: 'POST',
        url: 'https://api.privy.io/v1/wallets/<wallet_id>/rpc',
        body: {
          method: 'personal_sign',
          params: {
            message: 'Hello world',
            // ...
          },
        },
        headers: {
          'privy-app-id': $PRIVY_APP_ID,
          // If your request includes an idempotency key, include that header here as well
        }
      } as WalletApiRequestSignatureInput

      // Given this input, you can generate an authorization signature:
      const signature = generateAuthorizationSignature({input, authorizationPrivateKey});

      // Alternatively, you can format and serialize the payload:
      const serializedPayload = formatRequestForAuthorizationSignature({input});
      // And then sign the payload elsewhere:
      const signature = signElsewhere(serializedPayload);

      // Then, you can use the signature in your request:
      const res = await fetch(input.url, {
        method: input.method,
        body: input.body,
        headers: {
          ...input.headers,
          'privy-authorization-signature': signature
        }
      });
      ```
    </CodeGroup>
  </Tab>

  <Tab title="JavaScript/TypeScript">
    ```typescript
    import canonicalize from 'canonicalize'; // Support JSON canonicalization
    import crypto from 'crypto'; // Support P-256 signing

    // Replace this with your private key from the Dashboard
    const PRIVY_AUTHORIZATION_KEY = 'wallet-auth:insert-your-private-key-here';
    // ...

    function getAuthorizationSignature({url, body}: {url: string; body: object}) {
      const payload = {
        version: 1,
        method: 'POST',
        url,
        body,
        headers: {
          'privy-app-id': 'insert-your-app-id'
          // If your request includes an idempotency key, include that header here as well
        }
      };

      // JSON-canonicalize the payload and convert it to a buffer
      const serializedPayload = canonicalize(payload) as string;
      const serializedPayloadBuffer = Buffer.from(serializedPayload);

      // Replace this with your app's authorization key. We remove the 'wallet-auth:' prefix
      // from the key before using it to sign requests
      const privateKeyAsString = PRIVY_AUTHORIZATION_KEY.replace('wallet-auth:', '');

      // Convert your private key to PEM format, and instantiate a node crypto KeyObject for it
      const privateKeyAsPem = `-----BEGIN PRIVATE KEY-----\n${privateKeyAsString}\n-----END PRIVATE KEY-----`;
      const privateKey = crypto.createPrivateKey({
        key: privateKeyAsPem,
        format: 'pem'
      });

      // Sign the payload buffer with your private key and serialize the signature to a base64 string
      const signatureBuffer = crypto.sign('sha256', serializedPayloadBuffer, privateKey);
      const signature = signatureBuffer.toString('base64');
      return signature;
    }

    const authorizationSignature = getAuthorizationSignature({
      // Replace with your desired path
      url: 'https://api.privy.io/v1/wallets/<wallet_id>/rpc',
      // Replace with your desired body
      body: {
        method: 'personal_sign',
        params: {
          message: 'Hello world',
          // ...
        },
      }
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import json
    import base64
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import ec, utils

    # Replace this with your private key from the Dashboard

    PRIVY_AUTHORIZATION_KEY = "wallet-auth:your-authorization-private-key"

    def canonicalize(obj):
        """
        Simple JSON canonicalization function.
        Sorts dictionary keys and ensures consistent formatting.
        """

        return json.dumps(obj, sort_keys=True, separators=(",", ":"))

    def get_authorization_signature(url, body):
        """
        Generate authorization signature for Privy API requests using ECDSA and hashlib.
        """
        # Construct the payload
        payload = {
            "version": 1,
            "method": "POST",
            "url": url,
            "body": body,
            "headers": {"privy-app-id": "insert-your-app-id"},
        }

        # Serialize the payload to JSON
        serialized_payload = canonicalize(payload)

        # Create ECDSA P-256 signing key from private key
        private_key_string = PRIVY_AUTHORIZATION_KEY.replace("wallet-auth:", "")
        private_key_pem = (
            f"-----BEGIN PRIVATE KEY-----\n{private_key_string}\n-----END PRIVATE KEY-----"
        )

        # Load the private key from PEM format
        private_key = serialization.load_pem_private_key(
            private_key_pem.encode("utf-8"), password=None
        )

        # Sign the message using ECDSA with SHA-256
        signature = private_key.sign(
            serialized_payload.encode("utf-8"), ec.ECDSA(hashes.SHA256())
        )

        # Convert the signature to base64 for easy transmission
        return base64.b64encode(signature).decode("utf-8")

    authorization_signature = get_authorization_signature(
        url="https://api.privy.io/v1/wallets",
        body={
            "chain_type": "ethereum",
        },
    )
    ```
  </Tab>

  <Tab title="Rust">
    <CodeGroup>
      ```rust signature.rs
      use anyhow::{anyhow, Result};
      use p256::ecdsa::{signature::Signer, Signature, SigningKey};
      use base64::{engine::general_purpose::STANDARD, Engine as _};
      use serde_json::json;

      /// Signs the canonicalized JSON payload using ECDSA (P-256 + SHA-256).
      ///
      /// - `private_key_string` - A string containing your authorization key with the 'wallet-api:' prefix removed.
      /// - `payload` - JSON payload to sign, serialized to a string
      ///
      fn sign_payload(private_key_string: &str, payload: &str) -> Result<String> {
          let bytes = extract_32_byte_key_from_pkcs8_base64(private_key_string)?;
          let signing_key = SigningKey::from_slice(bytes.as_slice())?;

          // Sign the payload (SHA-256 is implied by ECDSA in P256's default)
          let signature: Signature = signing_key.sign(payload.as_bytes());

          // base64 encode the signature
          let signature_b64 = STANDARD.encode(signature.to_der());

          Ok(signature_b64)
      }

      /// Extracts the raw 32-byte private key from a base64-encoded PKCS#8 blob.
      /// Returns an error if `0x04 0x20` cannot be found or if the data is too short.
      fn extract_32_byte_key_from_pkcs8_base64(pkcs8_b64: &str) -> Result<[u8; 32]> {
          // 1. Decode base64
          let pkcs8_bytes = STANDARD.decode(pkcs8_b64)?;

          // 2. Search for the 2-byte pattern [0x04, 0x20]
          let pattern = [0x04, 0x20];
          let private_key_start = pkcs8_bytes
              .windows(pattern.len())
              .position(|window| window == pattern)
              .ok_or(anyhow!(
                  "Invalid wallet authorization private key: marker not found"
              ))?;

          // 3. Extract the 32 bytes following 0x04, 0x20
          let start = private_key_start + 2;
          let end = start + 32;
          if end > pkcs8_bytes.len() {
              return Err(anyhow!(
                  "Invalid wallet authorization private key: data too short"
              ));
          }

          let mut private_key_bytes = [0u8; 32];
          private_key_bytes.copy_from_slice(&pkcs8_bytes[start..end]);
          Ok(private_key_bytes)
      }

      /// Main function to generate the authorization signature.
      fn main() -> Result<()> {
          let privy_authorization_key = "wallet-auth:your-authorization-private-key";

          let private_key_string = privy_authorization_key.replace("wallet-auth:", "");

          let url = "https://api.privy.io/v1/wallets";
          let body = json!({
              "chain_type": "ethereum"
          });

          // --- Build the payload to sign ---
          let mut payload = json!({
              "version": 1,
              "method": "POST",
              "url": url,
              "body": body,
              "headers": {
                  "privy-app-id": "insert-your-app-id"
              }
          });

          // --- Canonicalize (sort keys, minimal separators) and serialize ---
          payload.sort_all_objects();
          let serialized_payload = serde_json::to_string(&payload)?;
          println!("{}", serialized_payload);

          // --- Sign the serialized payload using P-256 ECDSA ---
          let authorization_signature = sign_payload(&private_key_string, &serialized_payload)?;
          println!("{}", authorization_signature);

          Ok(())
      }
      ```

      ```rust Cargo.toml
      [dependencies]
      serde_json = {version = "1.0", features = ["preserve_order"]}
      p256 = "0.13"
      base64 = "0.22"
      anyhow = "1.0"
      ```
    </CodeGroup>
  </Tab>
</Tabs>


# Idempotency keys
Source: https://docs.privy.io/api-reference/idempotency-keys

Making Privy API requests idempotent with idempotency keys

Idempotency keys ensure your API requests to Privy aren't executed multiple times, preventing duplicated transactions. When provided, Privy guarantees that a request with the same idempotency key will only be processed once within a 24-hour window.

## Required headers

When using idempotency keys with the REST API, include the following header with your request:

<ParamField header="privy-idempotency-key" type="string" required>
  A unique identifier for the request, up to 256 characters. We recommend using a V4 UUID.
</ParamField>

## When are they necessary?

Idempotency keys are recommended for:

* Any `POST` request that triggers state changes or transactions
* Scenarios where network issues might cause request retries
* Critical operations where duplicate execution would be problematic

While optional, idempotency keys are strongly recommended for all non-idempotent operations in production environments to prevent double-spends and duplicate transactions.

## How idempotency works

<Steps>
  <Step title="First Request">
    When Privy receives a request with a new idempotency key, it processes the request normally and
    stores both the request details and response for 24 hours.
  </Step>

  <Step title="Subsequent Requests">
    If the same idempotency key is used again within 24 hours:

    * If the request body matches the original request: Privy returns the stored response without re-executing the operation
    * If the request body differs: Privy returns a 400 error indicating invalid use of the key
  </Step>

  <Step title="Key Expiration">
    After 24 hours, idempotency keys expire. Using an expired key will result in normal request
    processing.
  </Step>
</Steps>

<Warning>
  Changing any part of the request body while reusing an idempotency key will result in an error.
  Each unique operation should have its own idempotency key.
</Warning>

## Generating idempotency keys

Generate a unique, random string for each distinct operation. V4 UUIDs are recommended for their uniqueness properties.

<CodeGroup>
  ```ts JavaScript/TypeScript
  import {v4 as uuidv4} from 'uuid';

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();
  ```

  ```python Python
  import uuid

  # Generate a unique idempotency key
  idempotency_key = str(uuid.uuid4())
  ```
</CodeGroup>

## Examples

<CodeGroup>
  ```ts @privy-io/server-auth
  import {PrivyClient} from '@privy-io/server-auth';
  import {v4 as uuidv4} from 'uuid';

  const client = new PrivyClient($PRIVY_APP_ID, $PRIVY_APP_SECRET);

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();

  const res = await client.walletApi.ethereum.sendTransaction({
    walletId: $WALLET_ID,
    idempotencyKey, // Pass the idempotency key to prevent duplicate transactions
    transaction: {
      to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
      value: '0x2386F26FC10000',
      chainId: 8453
    }
  });
  ```

  ```ts TypeScript/JavaScript
  import axios from 'axios';
  import {v4 as uuidv4} from 'uuid';

  // Generate a unique idempotency key
  const idempotencyKey = uuidv4();

  const response = await axios.post(
    'https://api.privy.io/api/v1/wallets/y5ofctvacjiv53u4hmnqi0e5/rpc',
    {
      caip2: 'eip155:8453',
      method: 'eth_sendTransaction',
      params: {
        transaction: {
          to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
          value: '0x2386F26FC10000',
          chainId: 8453
        }
      }
    },
    {
      headers: {
        'privy-app-id': 'insert-your-app-id',
        'privy-idempotency-key': idempotencyKey,
        Authorization: 'Bearer insert-your-api-key'
      }
    }
  );
  ```
</CodeGroup>

<Tip>
  For critical operations, store the idempotency key alongside your transaction records. This allows
  you to safely retry failed operations with the same key.
</Tip>


# Introduction
Source: https://docs.privy.io/api-reference/introduction

Getting started with the Privy REST API

Privy offers low-level APIs you can use to interact with wallets and user objects directly. This means APIs to interface with the following resources:

* **Users**: create user objects with appropriate linked accounts and pregenerate wallets for them.
* **Wallets**: create, update and use wallets across blockchains.
* **Authorization keys**: create and manage authorization keys to manage wallets.
* **Policies**: create and manage policies tied to wallets.

Read more about direct API access below.

## Base URL

All requests to the Privy API must be made to the following base URL:

```
https://api.privy.io
```

HTTPS is required for all requests. HTTP requests will be rejected.

## Authentication

All API endpoints require authentication using Basic Auth and a Privy App ID header. Include the following headers with every request:

<ParamField header="Authorization" type="string" example="Basic ouihv9248hosd9020oihj0v10d=" required>
  Basic Auth header with your app ID as the username and your app secret as the password.
</ParamField>

<ParamField header="privy-app-id" type="string" example="cla06f34x0001mh08l8nsr496" required>
  Your Privy app ID as a string.
</ParamField>

Requests missing either of these headers will be rejected by Privy's middleware.

<Info>
  Your Privy app ID and app secret can be found in the [**App settings** >
  **Basics**](https://dashboard.privy.io/apps?page=settings\&tab=basics) tab for your app.
</Info>

## Examples

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    fetch('https://api.privy.io/v1/wallets', {
      method: 'GET',
      headers: {
        'Authorization': `Basic ${btoa('insert-your-app-id' + ':' + 'insert-your-app-secret')}`,
        'privy-app-id': 'insert-your-app-id',
        'Content-Type': 'application/json'
      }
    })
    .then(response => response.json())
    .then(data => console.log(data));
    ```
  </Tab>

  <Tab title="cURL">
    ```bash
    curl -X GET "https://api.privy.io/v1/wallets" \
      --user "insert-your-app-id:insert-your-app-secret" \
      -H "privy-app-id: insert-your-app-id" \
      -H "Content-Type: application/json"
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import requests
    import base64

    app_id = "insert-your-app-id"
    app_secret = "insert-your-app-secret"

    auth_string = f"{app_id}:{app_secret}"
    encoded_auth = base64.b64encode(auth_string.encode()).decode()

    headers = {
        "Authorization": f"Basic {encoded_auth}",
        "privy-app-id": app_id,
        "Content-Type": "application/json"
    }

    response = requests.get("https://api.privy.io/v1/wallets", headers=headers)
    data = response.json()
    ```
  </Tab>
</Tabs>


# Create key quorum
Source: https://docs.privy.io/api-reference/key-quorums/create

post /v1/key_quorums
Create a new key quorum.



# Delete key quorum
Source: https://docs.privy.io/api-reference/key-quorums/delete

delete /v1/key_quorums/{key_quorum_id}
Delete a key quorum by key quorum ID.



# Get key quorum
Source: https://docs.privy.io/api-reference/key-quorums/get

get /v1/key_quorums/{key_quorum_id}
Get a key quorum by ID.



# Update key quorum
Source: https://docs.privy.io/api-reference/key-quorums/update

patch /v1/key_quorums/{key_quorum_id}
Update a key quorum by key quorum ID.



# Create policy
Source: https://docs.privy.io/api-reference/policies/create

post /v1/policies
Create a new policy.



# Delete policy
Source: https://docs.privy.io/api-reference/policies/delete

delete /v1/policies/{policy_id}
Delete a policy by policy ID.



# Get policy
Source: https://docs.privy.io/api-reference/policies/get

get /v1/policies/{policy_id}
Get a policy by policy ID.



# Update policy
Source: https://docs.privy.io/api-reference/policies/update

patch /v1/policies/{policy_id}
Update a policy by policy ID.



# Authenticate
Source: https://docs.privy.io/api-reference/signers/authenticate

post /v1/user_signers/authenticate
Obtain a user session signer to enable wallet access.

<Info>
  Directly managing user authorization keys via the API is an advanced setting. We recommend using
  Privy's SDKs, which internally manage user authorization keys if applicable.
</Info>

This endpoint is used to create an ephemeral signing key for signing requests to [take actions](/api-reference/wallets/ethereum/eth-send-transaction) with a user's wallet.

The returned key is encrypted using Hybrid Public Key Encryption (HPKE), with the following configuration:

<ul>
  <li>KEM (Key Encapsulation Mechanism): DHKEM\_P256\_HKDF\_SHA256</li>
  <li>KDF (Key Derivation Function): HKDF\_SHA256</li>
  <li>AEAD (Authenticated Encryption with Associated Data): CHACHA20\_POLY1305</li>
  <li>Mode: BASE</li>
</ul>

The response `authorization_key` is ciphertext and must be decrypted.


# Create wallets
Source: https://docs.privy.io/api-reference/signers/create

post /v1/wallets_with_recovery
Create wallets with an associated recovery user.

<Info>
  Directly managing user authorization keys via the API is an advanced setting. We recommend using
  Privy's SDKs, which internally manage user authorization keys if applicable.
</Info>

This endpoint creates the requested wallets with the associated signer and recovery accounts. After creation, you can make a request to [authenticate](/api-reference/signers/authenticate) with a valid user JWT to obtain a time-bound user authorization key to use to take actions on the user's wallet.


# Get transaction
Source: https://docs.privy.io/api-reference/transactions/get

get /v1/transactions/{transaction_id}
Get a transaction by transaction ID.



# Create user
Source: https://docs.privy.io/api-reference/users/create

post /v1/users
Create a new user with linked accounts. Optionally pre-generate embedded wallets for the user.



# Add custom metadata
Source: https://docs.privy.io/api-reference/users/custom-metadata/create

post /v1/users/{user_id}/custom_metadata
Adds custom metadata to a user by user ID.



# Delete user
Source: https://docs.privy.io/api-reference/users/delete

delete /v1/users/{user_id}
Delete a user by user ID.



# Get user
Source: https://docs.privy.io/api-reference/users/get

get /v1/users/{user_id}
Get a user by user ID.



# Get users
Source: https://docs.privy.io/api-reference/users/get-all

get /v1/users
Get all users in your app.



# Create wallet
Source: https://docs.privy.io/api-reference/wallets/create

post /v1/wallets
Create a new wallet.



# eth_sendTransaction
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-send-transaction

post /v1/wallets/{wallet_id}/rpc
Sign and send a transaction using the eth_sendTransaction method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_sendTransaction",
    "caip2": "eip155:11155111",
    "chain_type": "ethereum",
    "params": {
      "transaction": {
        "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "value": "0x2386F26FC10000",
      }
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "eth_sendTransaction",
    "data": {
      "hash": "0xfc3a736ab2e34e13be2b0b11b39dbc0232a2e755a11aa5a9219890d3b2c6c7d8",
      "caip2": "eip155:11155111",
      "transaction_id": "y90vpg3bnkjxhw541c2zc6a9"
    }
  }
  ```
</ResponseExample>

<Warning>
  A successful response indicates that the transaction has been broadcasted to the network.
  Transactions may get broadcasted but still fail to be confirmed by the network: we recommend
  [listening for transaction event
  webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks) to evaluate and
  handle transactions stuck in a broadcasted state.
</Warning>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_sendTransaction" required>
  Available options: `eth_sendTransaction`
</ParamField>

<ParamField body="caip2" type="string" initialValue="eip155:11155111" required />

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="from" type="string" />

        <ParamField body="to" type="string" />

        <ParamField body="chain_id" type="string" />

        <ParamField body="nonce" type="string" />

        <ParamField body="data" type="string" />

        <ParamField body="value" type="string">
          The value to send in the transaction in wei as a hexadecimal string.
        </ParamField>

        <ParamField body="type" type="number">
          Available options: `0`, `1`, `2`
        </ParamField>

        <ParamField body="gas_limit" type="string" />

        <ParamField body="gas_price" type="string" />
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="address" type="string" />

<ParamField body="chain_type" type="string">
  Available options: `ethereum`
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_sendTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="hash" type="string" required />

    <ResponseField name="caip2" type="string" required />

    <ResponseField name="transaction_id" type="string" />
  </Expandable>
</ResponseField>


# eth_signTransaction
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-sign-transaction

post /v1/wallets/{wallet_id}/rpc
Sign a transaction using the eth_signTransaction method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_signTransaction",
    "params": {
      "transaction": {
        "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "value": "0x2386F26FC10000",
        "chain_id": 11155111,
        "data": "0x",
        "gas": 50000,
        "nonce": 0,
        "max_fee_per_gas": 1000308,
        "max_priority_fee_per_gas": "1000000"
      }
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "eth_signTransaction",
    "data": {
      "signed_transaction": "0x02f870830138de80830f4240830f437480940b81418147df37155d643b5cb65ba6c8cb7aba76872000000000000480c080a05c11a2166ec56189d993dec477477d962ce0d4c466ab7ed8982110621ec87a57a003c796590c0c62eac30acd412f2aa0e8ad740c4ded86fb64d3326ee4c0ea804c",
      "encoding": "rlp"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_signTransaction" required>
  Available options: `eth_signTransaction`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="from" type="string" />

        <ParamField body="to" type="string" />

        <ParamField body="chain_id" type="string" />

        <ParamField body="nonce" type="string" />

        <ParamField body="data" type="string" />

        <ParamField body="value" type="string">
          The value to send in the transaction in wei as a hexadecimal string.
        </ParamField>

        <ParamField body="type" type="number">
          Available options: `0`, `1`, `2`
        </ParamField>

        <ParamField body="gas_limit" type="string" />

        <ParamField body="gas_price" type="string" />
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_signTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signed_transaction" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `rlp`
    </ResponseField>
  </Expandable>
</ResponseField>


# eth_signTypedData_v4
Source: https://docs.privy.io/api-reference/wallets/ethereum/eth-signtypeddata-v4

post /v1/wallets/{wallet_id}/rpc
Sign a message using the eth_signTypedData_v4 method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_signTypedData_v4",
    "params": {
      "typed_data": {
        "types": {
          "EIP712Domain": [
            { "name": "name", "type": "string" },
            { "name": "version", "type": "string" },
            { "name": "chainId", "type": "uint160" },
            { "name": "verifyingContract", "type": "address" }
          ],
          "Person": [
            { "name": "name", "type": "string" },
            { "name": "wallet", "type": "address" }
          ],
          "Mail": [
            { "name": "from", "type": "Person" },
            { "name": "to", "type": "Person" },
            { "name": "contents", "type": "string" }
          ]
        },
        "message": {
          "from": {
            "name": "Alice",
            "wallet": "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
          },
          "to": {
            "name": "Bob",
            "wallet": "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
          },
          "contents": "Hello, Bob!"
        },
        "primary_type": "Mail",
        "domain": {
          "name": "DApp Mail",
          "version": "1",
          "chainId": "0x3e8",
          "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
        }
      }
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "eth_signTypedData_v4",
    "data": {
      "signature": "0x1754782aea15e96189c3a85a7b7ac2f6339f6f4f3b29b1d3200a4c9907ef53e4776a84387583896b0a074cbc6de1a1c2a1eb53aba199da6ada8c99b0266171c41b",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="eth_signTypedData_v4" required>
  Available options: `eth_signTypedData_v4`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="typed_data" type="object" required>
      <Expandable title="child attributes" defaultOpen="true">
        <ParamField body="domain" type="object" required />

        <ParamField body="types" type="object" required />

        <ParamField body="message" type="object" required />

        <ParamField body="primary_type" type="string" required />
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `eth_signTypedData_v4`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `utf-8`, `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# personal_sign
Source: https://docs.privy.io/api-reference/wallets/ethereum/personal-sign

post /v1/wallets/{wallet_id}/rpc
Sign a message using the personal_sign method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "personal_sign",
    "params": {
      "message": "Hello from Privy!",
      "encoding": "utf-8"
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "personal_sign",
    "data": {
      "signature": "0x0db9c7bd881045cbba28c347de6cc32a653e15d7f6f2f1cec21d645f402a64196e877eb45d3041f8d2ab1a76f57f408b63894cfc6f339d8f584bd26efceae3081c",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="personal_sign" required>
  Available options: `personal_sign`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ParamField body="message" type="string" />

    <ParamField body="encoding" type="string" initialValue="utf-8">
      Available options: `utf-8`, `hex`
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `personal_sign`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `utf-8`, `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# secp256k1_sign
Source: https://docs.privy.io/api-reference/wallets/ethereum/secp256k1-sign

post /v1/wallets/{wallet_id}/rpc
Sign a hash using the secp256k1 method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "secp256k1_sign",
    "params": {
      "hash": "0x12345678",
    }
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "secp256k1_sign",
    "data": {
      "signature": "0x0db9c7bd881045cbba28c347de6cc32a653e15d7f6f2f1cec21d645f402a64196e877eb45d3041f8d2ab1a76f57f408b63894cfc6f339d8f584bd26efceae3081c",
      "encoding": "hex"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="secp256k1_sign" required>
  Available options: `secp256k1_sign`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ParamField body="hash" type="string" />
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `secp256k1_sign`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties" defaultOpen="true">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `hex`
    </ResponseField>
  </Expandable>
</ResponseField>


# Export wallet
Source: https://docs.privy.io/api-reference/wallets/export

post /v1/wallets/{wallet_id}/export
Export a wallet's private key.

This endpoint exports a wallet's private key using Hybrid Public Key Encryption (HPKE). The following HPKE configuration is supported:

* KEM (Key Encapsulation Mechanism): DHKEM\_P256\_HKDF\_SHA256
* KDF (Key Derivation Function): HKDF\_SHA256
* AEAD (Authenticated Encryption with Associated Data): CHACHA20\_POLY1305
* Mode: BASE

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/export \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "encryption_type": "HPKE",
    "recipient_public_key": "<base64-encoded-recipient-public-key>"
  }'
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "encryption_type": "HPKE",
    "ciphertext": "N3rWFx85foeomDu8054VcwNBIwPkVNt4i5m2av1sXsXeWrIicVGwutFist12MmnI",
    "encapsulated_key": "BECqbgIAcs3TpP5GadS6F8mXkSktR2DR8WNtd3e0Qcy7PpoRHEygpzjFWttntS+SEM3VSr4Thewh18ZP9chseLE="
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to export.
</ParamField>

### Body

<ParamField body="encryption_type" type="string" defaultValue="HPKE" required>
  Currently only supports `HPKE` (Hybrid Public Key Encryption).
</ParamField>

<ParamField body="recipient_public_key" type="string" required>
  Base64-encoded public key of the recipient who will decrypt the private key. This key must be
  generated securely and kept confidential.
</ParamField>

### Response

<ResponseField name="encryption_type" type="string" required>
  Will be `HPKE` to indicate Hybrid Public Key Encryption was used.
</ResponseField>

<ResponseField name="ciphertext" type="string" required>
  Base64-encoded encrypted private key.
</ResponseField>

<ResponseField name="encapsulated_key" type="string" required>
  Base64-encoded ephemeral public key used in the HPKE encryption process. Required for decryption.
</ResponseField>


# Get wallet
Source: https://docs.privy.io/api-reference/wallets/get

get /v1/wallets/{wallet_id}
Get a wallet by wallet ID.



# Get wallets
Source: https://docs.privy.io/api-reference/wallets/get-all

get /v1/wallets
Get all wallets in your app.



# Raw sign
Source: https://docs.privy.io/api-reference/wallets/raw-sign

post /v1/wallets/{wallet_id}/raw_sign
Sign a raw hash along the blockchain's cryptographic curve using the wallet's private key.



# signAndSendTransaction
Source: https://docs.privy.io/api-reference/wallets/solana/sign-and-send-transaction

post /v1/wallets/{wallet_id}/rpc
Sign and send transaction with a Solana wallet using the signAndSendTransaction method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signAndSendTransaction",
    "params": {
      "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR+yTW0UB7am+E/MBAgIAAQwCAAAAQEIPAAAAAAA=",
      "encoding": "base64"
    }
  }
  '
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "signAndSendTransaction",
    "data": {
      "signed_transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR",
      "encoding": "base64"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="signAndSendTransaction" required>
  Available options: `signAndSendTransaction`
</ParamField>

<ParamField body="caip2" type="string" initialValue="eip155:11155111" required>
  Available options: `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp` (Solana Mainnet),
  `solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1` (Solana Devnet),
  `solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z` (Solana Testnet)
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="string">
      Base64 encoded serialized transaction to sign.
    </ParamField>

    <ParamField body="encoding" type="string">
      Available options: `base64`
    </ParamField>
  </Expandable>
</ParamField>

### Returns

<ResponseField name="method" type="enum<string>" required>
  Available options: `signAndSendTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="signed_transaction" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `base64`
    </ResponseField>
  </Expandable>
</ResponseField>


# signMessage
Source: https://docs.privy.io/api-reference/wallets/solana/sign-message

post /v1/wallets/{wallet_id}/rpc
Sign a message with a Solana wallet using the signMessage method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signMessage",
    "params": {
      "message": "aGVsbG8sIFByaXZ5IQ=",
      "encoding": "base64"
    }
  }
  '
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "signMessage",
    "data": {
      "signature": "76wpEsq9FS4QOInePQUY3b4GCXdVwLv+nNp4NnI+EPTAPVwvXCjzjUW/gD6Vuh4KaD+7p2X4MaTu6xYu0rMTAA==",
      "encoding": "base64"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="signMessage" required>
  Available options: `signMessage`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child properties">
    <ParamField body="message" type="string">
      Base64 encoded message to sign.
    </ParamField>

    <ParamField body="encoding" type="string">
      Available options: `base64`
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `signMessage`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child properties">
    <ResponseField name="signature" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `base64`
    </ResponseField>
  </Expandable>
</ResponseField>


# signTransaction
Source: https://docs.privy.io/api-reference/wallets/solana/sign-transaction

post /v1/wallets/{wallet_id}/rpc
Sign a transaction with a Solana wallet using the signTransaction method.

<RequestExample>
  ```sh cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "signTransaction",
    "params": {
      "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR+yTW0UB7am+E/MBAgIAAQwCAAAAQEIPAAAAAAA=",
      "encoding": "base64"
    }
  }
  '
  ```
</RequestExample>

<ResponseExample>
  ```json 200
  {
    "method": "signTransaction",
    "data": {
      "signed_transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEDRpb0mdmKftapwzzqUtlcDnuWbw8vwlyiyuWyyieQFKESezu52HWNss0SAcb60ftz7DSpgTwUmfUSl1CYHJ91GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAScgJ7J0AXFr1azCEvB1Y5zpiF4eXR",
      "encoding": "base64"
    }
  }
  ```
</ResponseExample>

### Headers

<ParamField header="privy-app-id" type="string" required>
  ID of your Privy app.
</ParamField>

<ParamField header="privy-authorization-signature" type="string">
  Request authorization signature. If multiple signatures are required, they should be comma
  separated.
</ParamField>

### Path Parameters

<ParamField path="wallet_id" type="string" required>
  ID of the wallet to get.
</ParamField>

### Body

<ParamField body="method" type="string" defaultValue="signTransaction" required>
  Available options: `signTransaction`
</ParamField>

<ParamField body="params" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ParamField body="transaction" type="string">
      Base64 encoded serialized transaction to sign.
    </ParamField>

    <ParamField body="encoding" type="string">
      Available options: `base64`
    </ParamField>
  </Expandable>
</ParamField>

### Response

<ResponseField name="method" type="enum<string>" required>
  Available options: `signTransaction`
</ResponseField>

<ResponseField name="data" type="object" required>
  <Expandable title="child attributes" defaultOpen="true">
    <ResponseField name="signed_transaction" type="string" required />

    <ResponseField name="encoding" type="enum<string>">
      Available options: `base64`
    </ResponseField>
  </Expandable>
</ResponseField>


# Update wallet
Source: https://docs.privy.io/api-reference/wallets/update

patch /v1/wallets/{wallet_id}
Update a wallet's policies or authorization key configuration.



# Overview
Source: https://docs.privy.io/authentication/overview



Privy's wallet system supports granular controls on who can access wallets and what actions different users can perform.

To enforce these controls, Privy's API must verify the identity of the party requesting a wallet action, ensuring that only authorized actions are executed by the system. This process is known as **authentication**.

Privy supports both **API authentication** and **user authentication** for authenticating access to wallets.

***

## API authentication

With **API authentication**, Privy authenticates a request from your server directly using an **API secret**. This ensures that Privy only executes requests sent by your servers alone, and no other party.

In addition to the API secret, you can also configure **authorization keys** that control specific wallets, policies, and other resources. Any requests to use or update these resources require a signature from the corresponding authorization key. This allows you to enforce granular controls on all Privy resources.

***

## User authentication

Privy is a powerful toolkit for progressive authentication of users. With fine-grained control over onboarding flows and wallet connections, you can improve conversion and craft better UX.

Using any of Privy's client-side SDKs, your app can authenticate users across web2 and web3 accounts, including:

* **[JWT-based authentication](/authentication/user-authentication/jwt-based-auth)**: Your app's existing JWT-based authentication system. This includes any OIDC compliant authentication system, including OAuth 2.0, Auth0, Firebase, AWS Cognito, and more.
* **[Email](/authentication/user-authentication/login-methods/email) or [SMS](/authentication/user-authentication/login-methods/sms)**: Passwordless login via an one-time passcode sent to a user's email address or phone number.
* **[Passkey](/authentication/user-authentication/login-methods/passkey)**: Biometric or passkey-based login based on the WebAuthn standard.
* **[OAuth and socials](/authentication/user-authentication/login-methods/oauth)**: Social login with Google, Apple, Twitter, Discord, GitHub, LinkedIn, Spotify, Telegram, Farcaster, and more.
* **[Wallets](/authentication/user-authentication/login-methods/wallet)**: External wallet login via Sign-In With Ethereum and Sign-In With Solana.

Your app can configure each of the account types above to be an upfront login method, or as an account that users link to their profile after login.

All of Privy's authentication methods create a common [user object](/user-management/users/the-user-object), where you can easily find a user's unique ID and all of the accounts they've linked to their profile. A user is a user, regardless of whether they've connected with a wallet, email or Discord account.

Once a user of your application successfully authenticates with Privy, Privy issues an [access token](/authentication/user-authentication/access-tokens) for the user that you app can additionally use to represent an authenticated session or to make authenticated requests to your backend.

## Get started

<CardGroup>
  <Card title="Login users with their email" icon="envelope" href="/authentication/user-authentication/login-methods/email">
    Authenticate users using just their email address and a one-time passcode.
  </Card>

  <Card title="Login with metamask" icon="wallet" href="/authentication/user-authentication/login-methods/wallet">
    Authenticate users with their externally owned Ethereum or Solana wallets.
  </Card>

  <Card title="Enable MFA" icon="key" href="/authentication/user-authentication/mfa">
    Add an extra layer of security to user accounts with multi-factor authentication.
  </Card>

  <Card title="Seamless Farcaster Frames login" icon="frame" href="/recipes/farcaster/frames">
    Allow your users to sign into your Farcaster frame seamlessly with Privy.
  </Card>
</CardGroup>


# Access tokens
Source: https://docs.privy.io/authentication/user-authentication/access-tokens



When a user logs in to your app and becomes **authenticated**, Privy issues the user an app **access token**. This token is signed by Privy and cannot be spoofed.

When your frontend makes a request to your backend, you should include the current user's access token in the request. This allows your server to determine whether the requesting user is truly authenticated or not.

***

## Access token format

Privy access tokens are [JSON Web Tokens (JWT)](https://jwt.io/introduction), signed with the ES256 algorithm. These JWTs include certain information about the user in their claims, namely:

<Expandable title="properties">
  <ResponseField name="sid" type="string">
    The user's current session ID
  </ResponseField>

  <ResponseField name="sub" type="string">
    The user's Privy DID
  </ResponseField>

  <ResponseField name="iss" type="string">
    The token issuer, which should always be [privy.io](http://privy.io)
  </ResponseField>

  <ResponseField name="aud" type="string">
    Your Privy app ID
  </ResponseField>

  <ResponseField name="iat" type="number">
    The timestamp of when the JWT was issued
  </ResponseField>

  <ResponseField name="exp" type="number">
    The timestamp of when the JWT will expire and is no longer valid. This is generally 1 hour after
    the JWT was issued.
  </ResponseField>
</Expandable>

<Info>
  Read more about Privy's tokens and their security in our [security
  guide](/security/authentication/user-authentication).
</Info>

***

## Sending the access token

### Accessing the token from your client

To include the current user's access token in requests from your frontend to your backend, you'll first need to retrieve it, then send it appropriately.

<Tabs>
  <Tab title="React">
    You can get the current user's Privy token as a string using the **`getAccessToken`** method from the **`usePrivy`** hook. This method will also automatically refresh the user's access token if it is nearing expiration or has expired.

    ```tsx
    const { getAccessToken } = usePrivy();
    const accessToken = await getAccessToken();
    ```

    If you need to get a user's Privy token *outside* of Privy's React context, you can directly import the **`getAccessToken`** method:

    ```tsx
    import { getAccessToken } from '@privy-io/react-auth';

    const authToken = await getAccessToken();
    ```

    <Warning>
      When using direct imports, you must ensure **`PrivyProvider`** has rendered before invoking the method.
      Whenever possible, you should retrieve **`getAccessToken`** from the **`usePrivy`** hook.
    </Warning>
  </Tab>

  <Tab title="React Native">
    In React Native, you can use the `getAccessToken` method from the `PrivyClient` instance to retrieve the user's access token.

    ```tsx
    const privy = createPrivyClient({
      appId: '<your-privy-app-id>',
      clientId: '<your-privy-app-client-id>'
    });
    const accessToken = await privy.getAccessToken();
    ```
  </Tab>

  <Tab title="Swift">
    In Swift, you can use the `getAccessToken` method on the PrivyUser object to retrieve the user's access token.

    ```swift
    // Check if user is authenticated
    guard let user = privy.user else {
      // If user is nil, user is not authenticated
      return
    }

    // Get the access token
    do {
      let accessToken = try await user.getAccessToken()
      print("Access token: \(accessToken)")
    } catch {
      // Handle error appropriately
    }
    ```
  </Tab>

  <Tab title="Android">
    In Android, you can use the `getAccessToken` method on the PrivyUser object to retrieve the user's access token.

    ```kotlin
    // Check if user is authenticated
    val user = privy.user
    if (user != null) {

      // Get the access token
      val result: Result<String> = user.getAccessToken()

      // Handle the result with fold method
      result.fold(
          onSuccess = { accessToken ->
              println("Access token: $accessToken")
          },
          onFailure = { error ->
              // Handle error appropriately
          },
      )
    }
    ```
  </Tab>

  <Tab title="Flutter">
    In Flutter, you can use the `getAccessToken` method on the PrivyUser object to retrieve the user's access token.

    ```dart
    // Check if user is authenticated
    final user = privy.user;
    if (user != null) {

      // Get the access token
      final result = await privy.user.getAccessToken();

      // Handle the result with fold method
      result.fold(
        onSuccess: (accessToken) {
          print('Access token: $accessToken');
        },
        onError: (error) {
          // Handle error appropriately
        },
      );
    }
    ```
  </Tab>
</Tabs>

<Info>
  If your app is configured to use HTTP-only cookies (instead of the default local storage), the
  access token will automatically be included in the cookies for requests to the same domain. In
  this case, you don't need to manually include the token in the request headers.
</Info>

### Using the access token with popular libraries

When sending requests to your backend, here's how you can include the access token with different HTTP client libraries:

<Tabs>
  <Tab title="fetch">
    ```tsx
    // For bearer token approach (when using local storage)
    const accessToken = await getAccessToken();
    const response = await fetch('<your-api-endpoint>', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    // For HTTP-only cookies approach
    const response = await fetch('<your-api-endpoint>', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include', // This includes cookies automatically
      body: JSON.stringify(data)
    });
    ```
  </Tab>

  <Tab title="axios">
    ```tsx
    import axios from 'axios';

    // For bearer token approach (when using local storage)
    const accessToken = await getAccessToken();
    const response = await axios({
      method: 'post',
      url: '<your-api-endpoint>',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      data: data
    });

    // For HTTP-only cookies approach
    const response = await axios({
      method: 'post',
      url: '<your-api-endpoint>',
      withCredentials: true, // This includes cookies automatically
      data: data
    });
    ```
  </Tab>

  <Tab title="ofetch">
    ```tsx
    import { ofetch } from 'ofetch';

    // For bearer token approach (when using local storage)
    const accessToken = await getAccessToken();
    const response = await ofetch('<your-api-endpoint>', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      body: data
    });

    // For HTTP-only cookies approach
    const response = await ofetch('<your-api-endpoint>', {
      method: 'POST',
      credentials: 'include', // This includes cookies automatically
      body: data
    });
    ```
  </Tab>
</Tabs>

***

## Getting the access token

### Accessing the token from your server

When your server receives a request, the location of the user's access token depends on whether your app uses **local storage** (the default) or **cookies** to manage user sessions.

<Expandable title="local storage setup">
  If you're using local storage for session management, the access token will be passed in the `Authorization` header of the request with the `Bearer` prefix. You can extract it like this:

  <Tabs>
    <Tab title="NodeJS">
      ```tsx
      // Example for Express.js
      const accessToken = req.headers.authorization?.replace('Bearer ', '');

      // Example for Next.js API route
      const accessToken = req.headers.authorization?.replace('Bearer ', '');

      // Example for Next.js App Router
      const accessToken = headers().get('authorization')?.replace('Bearer ', '');
      ```
    </Tab>

    <Tab title="Go">
      ```go
      // Example for Go
      accessToken := r.Header.Get("Authorization")
      accessToken = strings.Replace(accessToken, "Bearer ", "", 1)
      ```
    </Tab>

    <Tab title="Python">
      ```python
      # Example for Python
      accessToken = request.headers.get("Authorization")
      accessToken = accessToken.replace("Bearer ", "")
      ```
    </Tab>
  </Tabs>
</Expandable>

<Expandable title="cookie setup">
  If you're using HTTP-only cookies for session management, the access token will be automatically included in the `privy-token` cookie. You can extract it like this:

  <Tabs>
    <Tab title="NodeJS">
      ```tsx
      // Example for Express.js
      const accessToken = req.cookies['privy-token'];

      // Example for Next.js API route
      const accessToken = req.cookies['privy-token'];

      // Example for Next.js App Router
      const cookieStore = cookies();
      const accessToken = cookieStore.get('privy-token')?.value;
      ```
    </Tab>

    <Tab title="Go">
      ```go
      // Example for Go
      accessToken := r.Cookies["privy-token"]
      ```
    </Tab>

    <Tab title="Python">
      ```python
      # Example for Python
      accessToken = request.cookies.get("privy-token")
      ```
    </Tab>
  </Tabs>
</Expandable>

## Verifying the access token

Once you've obtained the user's access token from a request, you should verify the token against Privy's **verification key** for your app to confirm that the token was issued by Privy and the user referenced by the DID in the token is truly authenticated.

The access token is a standard [ES256](https://datatracker.ietf.org/doc/html/rfc7518#section-3.1) [JWT](https://jwt.io) and the verification key is a standard [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) public key. You can verify the access token against the public key using the **`@privy-io/server-auth`** library or using a third-party library for managing tokens.

<Tabs>
  <Tab title="NodeJS">
    ### Using Privy SDK

    Pass the user's access token as a `string` to the **`PrivyClient`**'s **`verifyAuthToken`** method:

    ```tsx
    // `privy` refers to an instance of the `PrivyClient`
    try {
      const verifiedClaims = await privy.verifyAuthToken(authToken);
    } catch (error) {
      console.log(`Token verification failed with error ${error}.`);
    }
    ```

    If the token is valid, **`verifyAuthToken`** will return an **`AuthTokenClaims`** object with additional information about the request, with the fields below:

    | Parameter    | Type     | Description                                                                   |
    | ------------ | -------- | ----------------------------------------------------------------------------- |
    | `appId`      | `string` | Your Privy app ID.                                                            |
    | `userId`     | `string` | The authenticated user's Privy DID. Use this to identify the requesting user. |
    | `issuer`     | `string` | This will always be `'privy.io'`.                                             |
    | `issuedAt`   | `string` | Timestamp for when the access token was signed by Privy.                      |
    | `expiration` | `string` | Timestamp for when the access token will expire.                              |
    | `sessionId`  | `string` | Unique identifier for the user's session.                                     |

    If the token is invalid, **`verifyAuthToken`** will throw an error and you should **not** consider the requesting user authorized. This generally occurs if the token has expired or is invalid (e.g. corresponds to a different app ID).

    <Tip>
      The Privy Client's `verifyAuthToken` method will make a request to Privy's API to fetch the verification key for your app. You can avoid this API request by copying your verification key from the **Configuration > App settings** page of the [**Dashboard**](https://dashboard.privy.io) and passing it as a second parameter to `verifyAuthToken`:

      ```ts
      const verifiedClaims = await privy.verifyAuthToken(
        authToken,
        'paste-your-verification-key-from-the-dashboard'
      );
      ```
    </Tip>

    ### Using JavaScript libraries

    You can also use common JavaScript libraries to verify tokens:

    <Tabs>
      <Tab title="jose">
        To start, install `jose`:

        ```sh
        npm i jose
        ```

        Then, load your Privy public key using [`jose.importSPKI`](https://github.com/panva/jose/blob/main/docs/functions/key_import.importSPKI.md):

        ```tsx
        const verificationKey = await jose.importSPKI(
          "insert-your-privy-verification-key",
          "ES256"
        );
        ```

        Lastly, using [`jose.jwtVerify`](https://github.com/panva/jose/blob/main/docs/functions/jwt_verify.jwtVerify.md), verify that the JWT is valid and was issued by Privy!

        ```tsx
        const accessToken = "insert-the-users-access-token";
        try {
          const payload = await jose.jwtVerify(accessToken, verificationKey, {
            issuer: "privy.io",
            audience: "insert-your-privy-app-id",
          });
          console.log(payload);
        } catch (error) {
          console.error(error);
        }
        ```

        If the JWT is valid, you can extract the JWT's claims from the [`payload`](https://github.com/panva/jose/blob/main/docs/interfaces/types.JWTPayload.md). For example, you can use `payload.sub` to get the user's Privy DID.

        If the JWT is invalid, this method will throw an error.
      </Tab>

      <Tab title="jsonwebtoken">
        To start, install `jsonwebtoken`:

        ```sh
        npm i jsonwebtoken
        ```

        Then, load your Privy public key as a string.

        ```tsx
        const verificationKey = "insert-your-privy-verification-key".replace(
          /\\n/g,
          "\n"
        );
        ```

        The `replace` operation above ensures that any instances of `'\n'` in the stringified public key are replaced with actual newlines, per the PEM-encoded format.

        Lastly, verify the JWT using [`jwt.verify`](https://github.com/auth0/node-jsonwebtoken#jwtverifytoken-secretorpublickey-options-callback):

        ```tsx
        const accessToken = 'insert-the-user-access-token-from-request';
        try {
          const decoded = jwt.verify(accessToken, verificationKey, {
            issuer: 'privy.io',
            audience: /* your Privy App ID */
          });
          console.log(decoded);
        } catch (error) {
          console.error(error);
        }
        ```

        If the JWT is valid, you can extract the JWT's claims from `decoded`. For example, you can use `decoded.sub` to get the user's Privy DID.

        If the JWT is invalid, this method will throw an error.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Go">
    For Go, the [`golang-jwt`](https://github.com/golang-jwt/jwt) library is a popular choice for token verification. To start, install the library:

    ```sh
    go get -u github.com/golang-jwt/jwt/v5
    ```

    Next, load your Privy verification key and app ID as strings:

    ```go
    verificationKey := "insert-your-privy-verification-key"
    appId := "insert-your-privy-app-id"
    ```

    Then, parse the claims from the JWT and verify that they are valid:

    ```go
    accessToken := "insert-the-users-access-token"

    // Defining a Go type for Privy JWTs
    type PrivyClaims struct {
      AppId      string `json:"aud,omitempty"`
      Expiration uint64 `json:"exp,omitempty"`
      Issuer     string `json:"iss,omitempty"`
      UserId     string `json:"sub,omitempty"`
    }

    // This method will be used to check the token's claims later
    func (c *PrivyClaims) Valid() error {
      if c.AppId != appId {
        return errors.New("aud claim must be your Privy App ID.")
      }
      if c.Issuer != "privy.io" {
        return errors.New("iss claim must be 'privy.io'")
      }
      if c.Expiration < uint64(time.Now().Unix()) {
        return errors.New("Token is expired.");
      }

      return nil
    }

    // This method will be used to load the verification key in the required format later
    func keyFunc(token *jwt.Token) (interface{}, error) {
      if token.Method.Alg() != "ES256" {
        return nil, fmt.Errorf("Unexpected JWT signing method=%v", token.Header["alg"])
      }
        // https://pkg.go.dev/github.com/dgrijalva/jwt-go#ParseECPublicKeyFromPEM
      return jwt.ParseECPublicKeyFromPEM([]byte(verificationKey)), nil
    }

    // Check the JWT signature and decode claims
    // https://pkg.go.dev/github.com/dgrijalva/jwt-go#ParseWithClaims
    token, err := jwt.ParseWithClaims(accessToken, &PrivyClaims{}, keyFunc)
    if err != nil {
        fmt.Println("JWT signature is invalid.")
    }

    // Parse the JWT claims into your custom struct
    privyClaim, ok := token.Claims.(*PrivyClaims)
    if !ok {
        fmt.Println("JWT does not have all the necessary claims.")
    }

    // Check the JWT claims
    err = Valid(privyClaim);
    if err {
        fmt.Printf("JWT claims are invalid, with error=%v.", err);
        fmt.Println();
    } else {
        fmt.Println("JWT is valid.")
        fmt.Printf("%v", privyClaim)
    }
    ```

    If the JWT is valid, you can access its claims, including the user's DID, from the `privyClaim` struct above.

    If the JWT is invalid, an error will be thrown.
  </Tab>

  <Tab title="Python">
    For Python, the [`pyjwt`](https://github.com/jpadilla/pyjwt) library is a popular choice for token verification.

    To start, install the library:

    ```sh
    pip install PyJWT
    ```

    Next, load your Privy public key and app ID as variables:

    ```python
    verificationKey = 'insert-your-privy-verification-key'
    appId = 'insert-your-privy-app-id'
    ```

    Lastly, verify that your JWT is valid using the library's `decode` method:

    ```python
    accessToken = 'insert-the-users-access-token'

    try:
        decoded = jwt.decode(authToken, verificationKey, issuer='privy.io', audience=appId, algorithms=['ES256'])
        print(decoded)
    except:
        print("Token verification failed")
    ```

    If the JWT is valid, you can extract the JWT's claims from the `decoded` object. For example, you can use `decoded['sub']` to get the user's Privy DID.

    If the JWT is invalid, `decode` will throw an error.
  </Tab>
</Tabs>

## Managing expired access tokens

A user's access token might expire while they are actively using your app. For example, if a user does not take action on an application for an extended period of time, the access token can become expired.

* **Handle invalid token errors**: In these scenarios, if a method returns with an **`'invalid auth token'`** error, we recommend calling the **`getAccessToken`** method with a time-based backoff until the user's access token is refreshed with an updated expiration time.
* **Return errors from backend**: If you receive an expired access token in your backend, return an error to your client, and as above, trigger **`getAccessToken`** in your client.
* **Handle failed refreshes**: If the user's access token cannot be refreshed, the user will be logged out.


# Authentication state
Source: https://docs.privy.io/authentication/user-authentication/authentication-state



Throughout your app, you may want to gate certain user experiences based on whether the current user is authenticated or not. Privy makes it easy to check your user's authentication status and handle it appropriately.

<Tabs>
  <Tab title="React">
    You can use the boolean `authenticated` from the `usePrivy` hook to determine if your user is authenticated or not.

    ```tsx
    authenticated: boolean;
    ```

    <Tip>
      Before determining a user's auth status from Privy, you should verify that
      Privy has fully initialized and is **`ready`**
    </Tip>

    ### Usage

    ```tsx
    import { useRouter } from "next/router";

    import { usePrivy } from "@privy-io/react-auth";

    export default function MyComponent() {
    const { ready, authenticated, user } = usePrivy();
    const router = useRouter();

    if (!ready) {
        // Do nothing while the PrivyProvider initializes with updated user state
        return <></>;
    }

    if (ready && !authenticated) {
        // Replace this code with however you'd like to handle an unauthenticated user
        // As an example, you might redirect them to a login page
        router.push("/login");
    }

    if (ready && authenticated) {
        // Replace this code with however you'd like to handle an authenticated user
        return <p>User {user?.id} is logged in.</p>;
    }
    }
    ```
  </Tab>

  <Tab title="React Native">
    You can use the `user` object from the `usePrivy` hook to determine if your user is authenticated or not.

    ```tsx
    user: User | null;
    ```

    ### Usage

    ```tsx
    import { useRouter } from "expo-router";
    import { usePrivy } from "@privy-io/expo";
    import { useEffect } from "react";
    import { Text, View } from "react-native";

    export default function MyComponent() {
      const { isReady, user } = usePrivy();
      const router = useRouter();

      useEffect(() => {
        if (isReady && !user) {
          // Replace this code with however you'd like to handle an unauthenticated user
          // As an example, you might redirect them to a login page
          router.replace("/login");
        }
      }, [isReady, user, router]);

      if (!isReady) {
        // Do nothing while the PrivyProvider initializes with updated user state
        return null;
      }

      if (isReady && !user) {
        // You could show a loading state or handle this differently
        return <Text>Not authenticated</Text>;
      }

      if (isReady && user) {
        // Replace this code with however you'd like to handle an authenticated user
        return (
          <View>
            <Text>User {user.id} is logged in.</Text>
          </View>
        );
      }
    }
    ```
  </Tab>

  <Tab title="Swift">
    You can use the `authState` property from the `Privy` client to determine if your user is authenticated or not.

    ```swift
    public enum AuthState {
      /// AuthState has not been determined yet, show loading
      case notReady
      /// User is unauthenticated
      case unauthenticated
      // User is authenticated and has an associated PrivyUser object
      case authenticated(PrivyUser)
    }
    ```

    Auth state is exposed as a Publisher on the Privy object:

    ```swift
    public protocol Privy {
      /// A publisher that emits auth state changes.
      var authStatePublisher: AnyPublisher<AuthState, Never> { get }
    }
    ```

    There are various ways to determine user's auth state, outlined below:

    #### 1. Directly grab the User

    As a convenience, you can grab the user object directly from the Privy instance. If the user is not null, there is an authenticated user.

    ```swift
    let privyUser = privy.user

    if (privyUser != null) {
      // User is authenticated
      let linkedAccounts = privyUser.linkedAccounts
    }
    ```

    #### 2. Grab the user's current auth state

    ```swift
    public protocol Privy {
      /// The user's current auth state.
      var authState: AuthState { get }
    }
    ```

    ```swift
    // Grab current auth state
    if case .authenticated(let user) = privy.authState {
      // User is authenticated. Grab the user's linked accounts
      let linkedAccounts = user.linkedAccounts
    }
    ```

    #### 3. Subscribe to auth state updates

    ```swift
    privy.authStatePublisher
      .receive(on: RunLoop.main)
      .sink { authState in
        switch authState {
        case .authenticated(let user):
          // User is authenticated. Grab the user's linked accounts
          let linkedAccounts = user.linkedAccounts
        case .notReady:
          // Privy not yet ready. Call privy.awaitReady()
        case .unauthenticated:
          // User in not authenticated. Perhaps show login screen.
        }
      }
    ```
  </Tab>

  <Tab title="Android">
    You can use the `authState` property from the `Privy` client to determine if your user is authenticated or not.

    ```kotlin
    public sealed interface AuthState {
      // AuthState has not been determined yet, show loading
      public data object NotReady : AuthState

      // User is unauthenticated
      public data object Unauthenticated : AuthState

      // User is authenticated and has an associated PrivyUser object
      public data class Authenticated(val user: PrivyUser) : AuthState
    }
    ```

    Auth state is exposed as a StateFlow on the Privy object:

    ```kotlin
    public interface Privy {
     // A state flow that can be subscribed to for auth state updates
     public val authState: StateFlow<AuthState>
    }
    ```

    ### Usage

    There are various ways to determine a user's auth state:

    #### 1. Directly grab the User

    As a convenience, you can grab the user object directly from the Privy instance. If the user is not null, there is an authenticated user.

    ```kotlin
    val privyUser = privy.user

    if (privyUser != null) {
      // User is authenticated
      val linkedAccounts = privyUser.linkedAccounts
    }
    ```

    #### 2. Grab the user's current auth state

    ```kotlin
    // Grab current auth state
    val currentAuthState = privy.authState.value
    if (currentAuthState is AuthState.Authenticated) {
        // User is authenticated. Grab the user's linked accounts
        val privyUser = currentAuthState.user
        val linkedAccount = privyUser.linkedAccounts
    }
    ```

    #### 3. Subscribe to auth state updates

    ```kotlin
    coroutineScope.launch {
        privy.authState.collectLatest { authState ->
            when(authState) {
                is AuthState.Authenticated -> {
                    // User is authenticated. Grab the user's linked accounts
                    val privyUser = authState.user
                    val userId = privyUser.linkedAccounts
                }
                AuthState.NotReady -> {
                    // Privy not yet ready. Call privy.awaitReady()
                }
                AuthState.Unauthenticated -> {
                    // User in not authenticated. Perhaps show login screen.
                }
            }
        }
    }
    ```
  </Tab>

  <Tab title="Unity">
    A Privy user's authentication state is defined by the `AuthState` enum below.

    ```csharp
    public enum AuthState
    {
        NotReady, // Privy has not yet finished initializing
        Unauthenticated, // User is unauthenticated
        Authenticated // User is authenticated
    }
    ```

    You can retrieve the user's `AuthState` at any time via:

    ```csharp
    Debug.Log(PrivyManager.Instance.AuthState);
    ```

    You can also subscribe to `AuthState` updates via:

    ```csharp
    PrivyManager.Instance.SetAuthStateChangeCallback(state =>
    {
        // User's AuthState has updated
        Debug.Log(state);
    });
    ```

    Once your user has successfully authenticated, you can get a `PrivyUser` object containing their account data via:

    ```csharp
    // User will be null if no user is authenticated
    PrivyUser user = PrivyManager.Instance.User;
    ```
  </Tab>

  <Tab title="Flutter">
    A user's authentication state is described by the AuthState sealed class.

    ```dart
    /// Base class representing different authentication states.
    sealed class AuthState {
      const AuthState();
    }

    /// Represents the initial state before authentication status is determined.
    class NotReady extends AuthState {
      const NotReady();
    }

    /// Represents the state when the user is not authenticated.
    class Unauthenticated extends AuthState {
      const Unauthenticated();
    }

    /// Represents the state when the user is authenticated.
    class Authenticated extends AuthState {
      final PrivyUser user;

      /// Constructor accepting the authenticated user's details.
      const Authenticated(this.user);
    }
    ```

    The current auth state and an auth state stream are accessible directly on the Privy object.

    ```dart
    abstract interface class Privy {
      // Get the current authentication state.
      AuthState get currentAuthState;

      // A stream for auth state updates.
      Stream<AuthState> get authStateStream;
    }
    ```

    ### Accessing authentication state

    There are various ways to determine user's auth state, outlined below. Mix and match to fit the needs of your application.

    #### 1. Directly retrieve the user

    As a convenience, you can grab the user object directly from the Privy instance. If the user is not null, there is an authenticated user.

    ```dart
    final privyUser = privy.user;

    if (privyUser != null) {
      // User is authenticated
      final linkedAccounts = privyUser.linkedAccounts;
    }
    ```

    #### 2. Retrieve the current auth state

    ```dart
    // Grab current auth state
    final currentAuthState = privy.currentAuthState;

    if (currentAuthState is Authenticated) {
      // User is authenticated. Retrieve the associated user from the auth state.
      final privyUser = currentAuthState.user;
      final linkedAccounts = privyUser.linkedAccounts;
    }
    ```

    #### 3. Subscribe to auth state updates

    ```dart
    privy.authStateStream.listen((authState) {
      switch (authState) {
        case Authenticated():
          // User is authenticated. Retrieve the user.
          final privyUser = authState.user;
          final userId = privyUser.linkedAccounts;
          break;
        case NotReady():
          // Privy is not yet ready. Ensure Privy is initialized first.
          break;
        case Unauthenticated():
          // User is not authenticated. You may want to show the login screen.
          break;
      }
    });
    ```
  </Tab>
</Tabs>


# Captcha on login
Source: https://docs.privy.io/authentication/user-authentication/captcha



Privy supports adding CAPTCHA to your login flow to prevent botting.

Once CAPTCHA is enabled, import the `Captcha` component and place it as a peer to your login form: *(When this component mounts, it will execute the invisible Captcha.)*

<Tabs>
  <Tab title="React">
    ```tsx
    import {Captcha, useLoginWithEmail} from '@privy-io/react-auth';

    const MyLoginForm = () => {
      const [email, setEmail] = useState('');
      const {sendCode, loginWithCode} = useLoginWithEmail();

      const handleSendCode = async () => {
        try {
          await sendCode(email);
        } catch (err) {
          // Captcha failures due to timeout or otherwise will show up here
          // in addition to possible network errors from the sendCode request
          //
          // The `sendCode` method from `useLoginWithSms` and `initOAuth` method
          // from `useLoginWithOAuth` work exactly the same way.
        }
      };

      return (
        <>
          <input type="text" onChange={(e) => setEmail(e.target.value)} />
          <button onClick={handleSendCode}>Send Code</button>
          <Captcha />
        </>
      );
    };
    ```
  </Tab>
</Tabs>

**That's it! Whenever a user tries to log into your app, Privy will pre-validate the attempt with an invisible captcha.** 🎉

<Info>
  Currently only Cloudflare's [Turnstile](https://www.cloudflare.com/products/turnstile/) is
  supported as a Captcha provider.
</Info>


# JWT-based auth
Source: https://docs.privy.io/authentication/user-authentication/jwt-based-auth



## Overview

Privy supports all JWT-based authentication providers. This includes any OIDC compliant authentication system, including OAuth 2.0, Auth0, Firebase, AWS Cognito, and more.

Using JWT-based authentication integration, you can use your existing authentication system with Privy's services. This approach allows users to maintain their existing login experience while giving them access to embedded wallets.

Privy's authentication is fully compatible with any authentication provider that supports [JWT-based](https://jwt.io/), [stateless](https://auth0.com/blog/stateless-auth-for-stateful-minds/) authentication. When a user logs into your app, your auth provider issues them an access and/or identity token to represent their auth status. Privy validates this token to authenticate your user.

### Setting up JWT-based authentication

To integrate your JWT-based auth provider with Privy:

1. Go to the [**Privy Dashboard**](https://dashboard.privy.io)
2. Select your app from the **App Dropdown** in the left sidebar
3. Request access to **Custom Auth Support** in the [Integrations > Plugins](https://dashboard.privy.io/apps?page=integrations) tab of the Privy dashboard
4. Navigate to the [JWT Dashboard](https://dashboard.privy.io/apps?logins=basics\&page=login-methods) via User management > Authentication > JWT-based auth

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/jwt.png" alt="JWT-based auth" />
</Frame>

You'll need to provide the following information:

<ParamField path="JWT Verification Details" required>
  Privy requires a verification key to ensure the JWTs received are valid. Both the token's signature and its expiration time ([claim](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4)) are verified to ensure secure access. This verification process helps protect user data and prevents unauthorized access to Privy services.

  You can provide the verification key in one of two ways:

  <AccordionGroup>
    <Accordion title="JWKS Endpoint">
      If your provider uses [JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) to sign JWTs, provide a JWKS endpoint URL where Privy can retrieve your auth provider's JWT public key.

      ```json
      {
          "keys": [
              {
              // JWKS
              }
          ]
      }
      ```
    </Accordion>

    <Accordion title="Public Verification Key">
      If your provider uses a single key to sign JWTs, provide the corresponding public key certificate used for verification.

      ```json
      -----BEGIN CERTIFICATE-----
      // Public key
      -----END CERTIFICATE-----
      ```
    </Accordion>
  </AccordionGroup>
</ParamField>

<ParamField path="JWT ID Claim" default="sub">
  Enter the claim from your user's JWT that contains the user's unique ID. In most access tokens and
  identity tokens, this is the claim.
</ParamField>

## Usage

<Tabs>
  <Tab title="React">
    ### Implementation

    To integrate JWT-based authentication with Privy in your React application, you'll need to create a custom `PrivyProvider` wrapper that supplies your auth token to Privy.

    #### Create a custom `PrivyProvider` wrapper

    Create a component that wraps the `PrivyProvider` with your custom auth configuration:

    ```tsx PrivyAuthProvider.tsx
    import { useCallback, PropsWithChildren } from 'react';
    import { PrivyProvider } from '@privy-io/react-auth';

    // Import your auth provider's hook or state management
    import { useAuth } from 'your-auth-provider';

    const PrivyAuthProvider: React.FC<PropsWithChildren> = ({ children }) => {
    // Get auth details from your provider
    const { getToken, isLoading, isAuthenticated } = useAuth();

    // Create a callback to get the token
    const getCustomToken = useCallback(
        async () => {
            // Your logic to retrieve the JWT token from your auth provider
            try {
                const token = await getToken();
                return token;
            } catch (error) {
                // If there's an error, the user is likely not authenticated
                return undefined;
            }
        },
        [isAuthenticated, getToken], // Re-create when auth state changes
    );

    return (
        <PrivyProvider
            appId='your-privy-app-id'
            config={{
                customAuth: {
                    // Indicates if your auth provider is currently updating auth state
                    isLoading: isLoading,
                    // Callback to get the user's JWT token
                    getCustomAccessToken: getCustomToken,
                },
            }}
        >
            {children}
        </PrivyProvider>
        );
    };

    export default PrivyAuthProvider;
    ```

    #### Integrate the provider with your app

    Make sure to nest your custom provider inside your auth provider in your app structure:

    ```tsx App.tsx
    import { AuthProvider } from 'your-auth-provider';
    import PrivyAuthProvider from './PrivyAuthProvider';

    function App() {
    return (
        <AuthProvider>
        {/* Our custom wrapper must be nested inside your AuthProvider */}
        <PrivyAuthProvider>
            {/* Your app content */}
            <MainContent />
        </PrivyAuthProvider>
        </AuthProvider>
    );
    }

    export default App;
    ```

    ### Accessing User Authentication Status

    Once configured, you can access the user's authentication status through the Privy SDK:

    ```tsx
    import { usePrivy } from '@privy-io/react-auth';

    function MainContent() {
    const { user, ready, authenticated } = usePrivy();

    if (!ready) {
        return <div>Loading...</div>;
    }

    if (!authenticated) {
        return <div>Please log in through your authentication provider</div>;
    }

    return (
        <div>
        <p>Welcome, authenticated user!</p>
        <p>User ID: {user.id}</p>
        </div>
    );
    }
    ```

    <Info>
      When using a custom authentication provider, you should not use the Privy `login` method (from `useLogin` or `usePrivy`). Instead, call the login method of your custom provider, and the Privy SDK will automatically synchronize its state.
    </Info>
  </Tab>

  <Tab title="React Native">
    ### Implementation

    To integrate JWT-based authentication with Privy in your React Native application, you'll need to create a custom `PrivyProvider` wrapper that supplies your auth token to Privy.

    #### Create a custom `PrivyProvider` wrapper

    Create a component that wraps the `PrivyProvider` with your custom auth configuration:

    ```tsx PrivyAuthProvider.tsx
    import { useCallback, PropsWithChildren } from 'react';
    import { PrivyProvider } from '@privy-io/expo';

    // Import your auth provider's hook or state management
    import { useAuth0 } from 'react-native-auth0';

    const PrivyAuthProvider: React.FC<PropsWithChildren> = ({ children }) => {
        // Get auth details from your auth provider
        const { user: auth0User, isLoading, getCredentials } = useAuth0();

        // Create a callback to get the token
        const getCustomToken = useCallback(async () => {
            // Your logic to retrieve the JWT token from your auth provider
            try {
                const creds = await getCredentials();
                return creds?.idToken;
            } catch (error) {
                // If there's an error, the user is likely not authenticated
                return undefined;
            }
        }, [isLoading, auth0User, getCredentials]); // Re-create when auth state changes

        return (
            <PrivyProvider
                appId='your-privy-app-id'
                config={{
                    customAuth: {
                        enabled: true,
                        // Indicates if your auth provider is currently updating auth state
                        isLoading: isLoading,
                        // Callback to get the user's JWT token
                        getCustomAccessToken: getCustomToken,
                    }
                }}
            >
                {children}
            </PrivyProvider>
        );
    };

    export default PrivyAuthProvider;
    ```

    #### Integrate the provider with your app

    Make sure to nest your custom provider inside your auth provider in your app structure:

    ```tsx App.tsx
    import { Auth0Provider } from 'react-native-auth0';
    import PrivyAuthProvider from './PrivyAuthProvider';

    function App() {
        return (
            <Auth0Provider
                domain="your-domain.auth0.com"
                clientId="your-client-id"
            >
                {/* Our custom wrapper must be nested inside your AuthProvider */}
                <PrivyAuthProvider>
                    {/* Your app content */}
                    <MainContent />
                </PrivyAuthProvider>
            </Auth0Provider>
        );
    }

    export default App;
    ```

    ### Accessing User Authentication Status

    Once configured, you can access the user's authentication status through the Privy SDK:

    ```tsx
    import { usePrivy } from '@privy-io/expo';
    import { View, Text } from 'react-native';

    function MainContent() {
        const { user, ready } = usePrivy();

        if (!ready) {
            return <Text>Loading...</Text>;
        }

        if (!user) {
            return <Text>Please log in through your authentication provider</Text>;
        }

        return (
            <View>
                <Text>Welcome, authenticated user!</Text>
                <Text>User ID: {user.id}</Text>
            </View>
        );
    }
    ```

    <Info>
      When using a custom authentication provider in React Native, you should let your auth provider handle the authentication flow. Privy will automatically synchronize its state based on the token provided by your `getCustomAccessToken` callback.
    </Info>
  </Tab>

  <Tab title="Swift">
    ### Implementation

    To integrate JWT-based authentication with Privy in your Swift application, you'll need to initialize the Privy SDK with a token provider callback and handle authentication.

    #### Initialize Privy with a token provider callback

    First, initialize the Privy SDK with a `tokenProvider` callback that will provide the JWT from your custom auth provider:

    ```swift Privy initialization with custom auth
    let privy = PrivyConfig(
        appId: "YOUR_APP_ID",
        appClientId: "YOUR_APP_CLIENT_ID",
        customAuthConfig: PrivyLoginWithCustomAuthConfig {
            // Client logic to provide the JWT
            // This might involve network requests or accessing secure storage
            return await fetchAccessTokenFromAuthProvider()
        }
    )
    ```

    ```swift Example token provider implementation
    private func fetchAccessTokenFromAuthProvider() async throws -> String? {
        // Your custom logic to retrieve the JWT token
        // This might be from shared preferences, secure storage, or an API call
        try await yourAuthManager.getAccessToken()
    }
    ```

    This `tokenProvider` callback should:

    * Return the current user's access token as a `String` when authenticated
    * Return `nil` when the user is not authenticated

    #### Authenticate your user

    Once you have defined a `tokenProvider` callback, authenticate your user with Privy using the `loginWithCustomAccessToken` method:

    ```swift Authenticating with Privy
    do {
        try await privy.customJwt.loginWithCustomAccessToken()
        // User is now authenticated with Privy
    } catch {
        // Handle authentication errors
        print("Failed to authenticate with Privy: \(error)")
    }
    ```

    If the provided token is valid, Privy will successfully authenticate your user. If the token is invalid, this method will throw an error.

    #### Example with Auth0

    Here's an example using Auth0's Swift SDK for authentication:

    ```swift Auth0 Integration Example
    // Store the Auth0 token
    var auth0Token: String? = nil

    // Set up the token provider to return the stored token
    let config = PrivyConfig(
        appId: "YOUR_APP_ID",
        appClientId: "YOUR_APP_CLIENT_ID",
        customAuthConfig: PrivyLoginWithCustomAuthConfig {
            return auth0Token
        }
    )

    // Handle Auth0 authentication
    Auth0.webAuth().start { result in
        if case .success(let credentials) = result {
            auth0Token = credentials.accessToken

            Task {
                do {
                    // Authenticate with Privy using the token
                    try await privy.customJwt.loginWithCustomAccessToken()

                    // Now the user is authenticated with Privy
                    // You can access their wallet and other features
                } catch {
                    print("Privy authentication failed: \(error)")
                }
            }
        } else {
            print("Auth0 authentication failed")
        }
    }
    ```

    ### Authentication Flow

    When using custom authentication with the Swift SDK:

    1. When the Privy SDK is first initialized, it attempts to restore any prior session
    2. If a prior session exists, Privy automatically tries to reauthenticate using your `tokenProvider`
    3. You can manually trigger authentication by calling `loginWithCustomAccessToken`
    4. After successful authentication, you have access to the `PrivyUser` object and wallet functionality

    <Info>
      When your app starts up, as soon as you determine your user is authenticated via your custom auth provider, you should call Privy's `loginWithCustomAccessToken` method to synchronize the authentication state.
    </Info>

    ### Accessing User Data

    Once authenticated, you can access the user's data and embedded wallets:

    ```swift
    // Check if user is authenticated
    if let user = privy.user {
        // Access user information
        let userId = user.id

        // Access embedded wallets
        if let wallet = user.embeddedEthereumWallets.first {
            let walletAddress = wallet.address
            print("User has Ethereum wallet with address: \(walletAddress)")
        }
    }
    ```

    Privy identifies users based on the unique ID assigned by your auth provider (stored in the `sub` claim of their access token). You can view all users in the **Users** section of the Privy Developer Dashboard.
  </Tab>

  <Tab title="Android">
    ### Implementation

    To integrate JWT-based authentication with Privy in your Android application, you'll need to initialize the Privy SDK with a token provider callback and handle authentication.

    #### Initialize Privy with a token provider callback

    First, initialize the Privy SDK with a `tokenProvider` callback that will provide the JWT from your custom auth provider:

    ```kotlin Privy initialization with custom auth
    private val privy: Privy = Privy.init(
        context = applicationContext, // Be sure to only pass in Application context
        config = PrivyConfig(
            appId = "YOUR_APP_ID",
            appClientId = "YOUR_APP_CLIENT_ID",
            logLevel = PrivyLogLevel.NONE,
            customAuthConfig = LoginWithCustomAuthConfig(
                tokenProvider = {
                    // Return the user's access token if they're authenticated
                    // Or return null if they're not authenticated
                    fetchTokenFromAuthProvider()
                }
            )
        )
    )

    // Example token provider implementation
    private suspend fun fetchTokenFromAuthProvider(): String? {
        return try {
            // Your custom logic to retrieve the JWT token
            // This might be from shared preferences, secure storage, or an API call
            yourAuthManager.getAccessToken()
        } catch (e: Exception) {
            // If there's an error, the user is likely not authenticated
            null
        }
    }
    ```

    The `tokenProvider` callback should:

    * Return the current user's access token as a `String` when authenticated
    * Return `null` when the user is not authenticated
    * Be implemented as a suspending function that can perform asynchronous operations

    #### Authenticate your user

    Once you've initialized Privy with a `tokenProvider` callback, authenticate your user with Privy using the `loginWithCustomAccessToken` method:

    ```kotlin Authenticating with Privy
    // Make sure to call this in a coroutine scope
    val privyLoginResult = privy.customAuth.loginWithCustomAccessToken()

    privyLoginResult.fold(
        onSuccess = { user ->
            Log.d("Privy", "Privy login success! User: ${user}")
            // Now you can access user information and wallet functionality
        },
        onFailure = { error ->
            Log.d("Privy", "Privy login failure! $error")
            // Handle authentication error
        }
    )
    ```

    If the provided access or identity token is valid, Privy will authenticate your user and return a `Result.success` with the `PrivyUser` object. If the token is invalid, it will return a `Result.failure`.

    #### Example integration with Auth0

    Here's an example of integrating with Auth0 for Android:

    ```kotlin Auth0 Integration Example
    private val auth0 = Auth0(
        clientId = "YOUR_AUTH0_CLIENT_ID",
        domain = "YOUR_AUTH0_DOMAIN"
    )

    // Store the Auth0 token
    private var auth0Token: String? = null

    // Initialize Privy with token provider that returns the Auth0 token
    private val privy = Privy.init(
        context = applicationContext,
        config = PrivyConfig(
            appId = "YOUR_PRIVY_APP_ID",
            appClientId = "YOUR_PRIVY_APP_CLIENT_ID",
            customAuthConfig = LoginWithCustomAuthConfig(
                tokenProvider = { auth0Token }
            )
        )
    )

    // Authenticate with Auth0, then with Privy
    private fun authenticateUser() {
        val callback = object : Callback<Credentials, AuthenticationException> {
            override fun onSuccess(credentials: Credentials) {
                // Store the token
                auth0Token = credentials.accessToken

                // Authenticate with Privy
                lifecycleScope.launch {
                    val privyResult = privy.customAuth.loginWithCustomAccessToken()
                    privyResult.fold(
                        onSuccess = { user ->
                            Log.d("Auth", "Successfully authenticated with Privy")
                            // Proceed with authenticated user
                        },
                        onFailure = { error ->
                            Log.e("Auth", "Failed to authenticate with Privy", error)
                        }
                    )
                }
            }

            override fun onFailure(error: AuthenticationException) {
                Log.e("Auth", "Auth0 authentication failed", error)
            }
        }

        // Start Auth0 authentication
        WebAuthProvider.login(auth0)
            .withScheme("demo")
            .start(this, callback)
    }
    ```

    ### Authentication flow

    When using custom authentication with the Android SDK:

    1. When the Privy SDK is first initialized, it attempts to restore any prior session
    2. If a prior session exists, Privy automatically tries to reauthenticate using your `tokenProvider`
    3. You can manually trigger authentication by calling `loginWithCustomAccessToken`
    4. After successful authentication, you have access to the `PrivyUser` object and wallet functionality

    <Info>
      It's important to await the `privy.ready()` call before triggering any other Privy flows to ensure the SDK has completed initialization and attempted session restoration.
    </Info>

    ### Accessing user data and wallets

    Once authenticated, you can access the user's data and embedded wallets:

    ```kotlin
    // Check if user is authenticated
    val user = privy.user
    if (user != null) {
        // Access user information
        val userId = user.id

        // Access embedded Ethereum wallets
        val ethereumWallets = user.embeddedEthereumWallets
        if (ethereumWallets.isNotEmpty()) {
            val walletAddress = ethereumWallets.first().address
            Log.d("Wallet", "User has Ethereum wallet with address: $walletAddress")
        }
    }
    ```

    Privy identifies users based on the unique ID that your auth provider has assigned (stored in the `sub` claim of their access token). You can view all users in the **Users** section of the Privy Developer Dashboard.
  </Tab>

  <Tab title="Flutter">
    ### Implementation

    To integrate JWT-based authentication with Privy in your Flutter application, you'll need to initialize the Privy SDK with a token provider callback and handle authentication.

    #### Initialize Privy with a token provider callback

    First, initialize the Privy SDK with a `tokenProvider` callback that will provide the JWT from your custom auth provider:

    ```dart Privy initialization with custom auth
    // Define a function to retrieve the token from your auth provider
    Future<String?> _retrieveCustomAuthAccessToken() async {
      // Implement logic to fetch the access token from your auth provider
      // Return the token if the user is authenticated, or null if not
      try {
        // Your custom logic to retrieve the JWT token
        // This might be from secure storage or an API call
        final token = await yourAuthService.getAccessToken();
        return token;
      } catch (e) {
        // If there's an error, the user is likely not authenticated
        return null;
      }
    }

    // Initialize Privy with the token provider
    final privyConfig = PrivyConfig(
      appId: "YOUR_APP_ID",
      appClientId: "YOUR_APP_CLIENT_ID",
      logLevel: PrivyLogLevel.NONE,
      customAuthConfig: LoginWithCustomAuthConfig(
        tokenProvider: _retrieveCustomAuthAccessToken,
      ),
    );

    final privy = Privy(config: privyConfig);
    ```

    The `tokenProvider` callback should:

    * Return the current user's access token as a `String` when authenticated
    * Return `null` when the user is not authenticated
    * Be implemented as an async function that can perform asynchronous operations

    #### Await SDK readiness

    Before performing any operations with the SDK, make sure to await its readiness:

    ```dart Awaiting SDK readiness
    // Wait for the SDK to be ready before proceeding
    await privy.ready;
    ```

    This ensures that the SDK has completed initialization and attempted session restoration if a prior session exists.

    #### Authenticate your user

    Once you've initialized Privy with a `tokenProvider` callback, authenticate your user with Privy using the `loginWithCustomAccessToken` method:

    ```dart Authenticating with Privy
    // Authenticate with Privy
    final result = await privy.customAuth.loginWithCustomAccessToken();

    result.fold(
      onSuccess: (user) {
        print("Privy login success! User: ${user}");
        // Now you can access user information and wallet functionality
      },
      onFailure: (error) {
        print("Privy login failure! ${error.message}");
        // Handle authentication error
      },
    );
    ```

    If the provided access or identity token is valid, Privy will authenticate your user and return a `Result.success` with the `PrivyUser` object. If the token is invalid, it will return a `Result.failure`.

    #### Example integration with Firebase Auth

    Here's an example of integrating with Firebase Authentication:

    ```dart Firebase Auth Integration Example
    import 'package:firebase_auth/firebase_auth.dart';
    import 'package:privy_flutter/privy_flutter.dart';

    class AuthService {
      final FirebaseAuth _auth = FirebaseAuth.instance;
      late final Privy _privy;

      // Initialize Privy with Firebase token provider
      Future<void> initPrivy() async {
        final privyConfig = PrivyConfig(
          appId: "YOUR_PRIVY_APP_ID",
          appClientId: "YOUR_PRIVY_APP_CLIENT_ID",
          logLevel: PrivyLogLevel.NONE,
          customAuthConfig: LoginWithCustomAuthConfig(
            tokenProvider: _getFirebaseIdToken,
          ),
        );

        _privy = Privy(config: privyConfig);

        // Wait for Privy to be ready
        await _privy.awaitReady();
      }

      // Firebase token provider function
      Future<String?> _getFirebaseIdToken() async {
        try {
          final user = _auth.currentUser;
          if (user == null) return null;

          // Get the ID token
          return await user.getIdToken();
        } catch (e) {
          print("Error getting Firebase ID token: $e");
          return null;
        }
      }

      // Sign in with Firebase, then with Privy
      Future<Result<PrivyUser>> signInWithEmailAndPassword(String email, String password) async {
        try {
          // Sign in with Firebase
          await _auth.signInWithEmailAndPassword(
            email: email,
            password: password,
          );

          // After Firebase auth succeeds, authenticate with Privy
          return await _privy.customAuth.loginWithCustomAccessToken();
        } catch (e) {
          return Result.failure(AuthError("Firebase authentication failed: $e"));
        }
      }
    }
    ```

    ### Authentication flow

    When using custom authentication with the Flutter SDK:

    1. When the Privy SDK is first initialized, it attempts to restore any prior session
    2. If a prior session exists, Privy automatically tries to reauthenticate using your `tokenProvider`
    3. You can manually trigger authentication by calling `loginWithCustomAccessToken`
    4. After successful authentication, you have access to the `PrivyUser` object and wallet functionality

    <Info>
      It's important to `await privy.awaitReady()` before triggering any other Privy flows to ensure the SDK has completed initialization and attempted session restoration.
    </Info>

    ### Accessing user data and wallets

    Once authenticated, you can access the user's data and embedded wallets:

    ```dart
    // Check if user is authenticated
    final user = privy.user;
    if (user != null) {
      // Access user information
      final userId = user.id;

      // Access embedded Ethereum wallets
      final ethereumWallets = user.embeddedEthereumWallets;
      if (ethereumWallets.isNotEmpty) {
        final walletAddress = ethereumWallets.first.address;
        print("User has Ethereum wallet with address: $walletAddress");
      }
    }
    ```

    Privy identifies users based on the unique ID that your auth provider has assigned (stored in the `sub` claim of their access token). You can view all users in the **Users** section of the Privy Developer Dashboard.
  </Tab>
</Tabs>


# Email
Source: https://docs.privy.io/authentication/user-authentication/login-methods/email



Privy enables users to login to your application with SMS or email. With Privy, your application can verify ownership of a user's email address or phone number to send them notifications, campaigns, and more to keep them activated.

<Tip>
  Enable email authentication in the [Privy
  Dashboard](https://dashboard.privy.io/apps?page=login-methods) before implementing this feature.
</Tip>

<Tabs>
  <Tab title="React">
    To authenticate your users with a one-time passcode (OTP) sent to their email address, use the `useLoginWithEmail` hook.

    ## Send Code

    ```tsx
    sendCode: ({email: string, disableSignup?: boolean}) => Promise<void>
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The email address of the user to log in.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the email address.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the code is sent.
    </ResponseField>

    ## Login with Code

    ```tsx
    loginWithCode: ({ code: string }) => Promise<void>;
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the user is logged in.
    </ResponseField>

    ## Usage

    ```tsx
    import { useState } from "react";
    import { useLoginWithEmail } from "@privy-io/react-auth";

    export default function LoginWithEmail() {
      const [email, setEmail] = useState("");
      const [code, setCode] = useState("");
      const { sendCode, loginWithCode } = useLoginWithEmail();

      return (
          <div>
              <input onChange={(e) => setEmail(e.currentTarget.value)} value={email} />
              <button onClick={() => sendCode({ email })}>Send Code</button>
              <input onChange={(e) => setCode(e.currentTarget.value)} value={code} />
              <button onClick={() => loginWithCode({ code })}>Login</button>
          </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OTP flow via the `state` variable returned by the
    `useLoginWithEmail` hook.

    ```ts
    type OtpFlowState =
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'sending-code'}
      | {status: 'awaiting-code-input'}
      | {status: 'submitting-code'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the OTP flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OTP flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithEmail` hook to run custom logic after a successful login or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx
    onComplete?: ((params: {
        user: User;
        isNewUser: boolean;
        wasAlreadyAuthenticated: boolean;
        loginMethod: LoginMethod | null;
        loginAccount: LinkedAccountWithMetadata | null;
    }) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user entered the application already authenticated.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login.
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the loginMethod used.
    </ParamField>

    ### `onError`

    ```tsx
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>
  </Tab>

  <Tab title="React Native">
    To authenticate your users with a one-time passcode (OTP) sent to their email address, use the `useLoginWithEmail` hook.

    ## Send Code

    ```jsx
    sendCode: ({email: string}) => Promise<{success: boolean}>
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="success" type="boolean">
      A promise that resolves to an object with a success property indicating if the code was sent successfully.
    </ResponseField>

    ## Login with Code

    ```jsx
    loginWithCode: ({ code: string, email?: string, disableSignup?: boolean }) => Promise<{user: PrivyUser; isNewUser: boolean}>
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="email" type="string">
      The user's email address. Though this parameter is optional, it is highly recommended that you pass the user's email address explicitly.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the email address.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="PrivyUser">
      The user object returned by the login process.
    </ResponseField>

    ## Usage

    ```jsx
    import { useState } from 'react';
    import { useLoginWithEmail } from '@privy-io/expo';

    export default function LoginWithEmail() {
    const [email, setEmail] = useState('');
    const [code, setCode] = useState('');
    const { sendCode, loginWithCode } = useLoginWithEmail();

    return (
        <View>
        <TextInput value={email} onChangeText={setEmail} placeholder="Email" />
        <Button onPress={() => sendCode({ email })}>Send Code</Button>
        <TextInput value={code} onChangeText={setCode} placeholder="Code" />
        <Button onPress={() => loginWithCode({ code, email })}>Login</Button>
        </View>
    );
    }
    ```

    ## Tracking login flow state

    The state variable returned from useLoginWithEmail will always be one of the following values.

    ```ts
    type OtpFlowState =
    | {status: 'initial'}
    | {status: 'error'; error: Error | null}
    | {status: 'sending-code'}
    | {status: 'awaiting-code-input'}
    | {status: 'submitting-code'}
    | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the email login flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the email login flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithEmail` hook to run custom logic after an OTP has been sent, after a successful login, or to handle errors that occur during the flow.

    ### `onSendCodeSuccess`

    ```tsx
    onSendCodeSuccess?: ((email: string) => void) | undefined
    ```

    #### Parameters

    <ParamField path="email" type="string">
      The email the code was sent to.
    </ParamField>

    ### `onLoginSuccess`

    ```tsx
    onLoginSuccess?: ((user: User, isNewUser: boolean) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The PrivyUser returned by loginWithCode.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    ### `onError`

    ```tsx
    onError?: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>
  </Tab>

  <Tab title="Swift">
    To authenticate a user via their email address, use the Privy client's `email` handler.

    ## Send Code

    ```swift
    sendCode(to email: String) async throws
    ```

    ### Parameters

    <ParamField path="to" type="String" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField>
      Nothing, indicating success.
    </ResponseField>

    ### Throws

    An error if sending the code fails.

    ## Login with Code

    ```swift
    loginWithCode(_ code: String, sentTo email: String) async throws -> PrivyUser
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="sentTo" type="String" required>
      The user's email address.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="PrivyUser">
      The authenticated Privy user
    </ResponseField>

    ### Throws

    An error if logging the user in is unsuccessful.

    ## Usage

    ```swift
    // Send code to user's email
    do {
        try await privy.email.sendCode(to: "myuser@privy.io")
        // successfully sent code to users email
    } catch {
        print("error sending code to \(email): \(error)")
    }

    // Log the user in
    do {
        let user = try await privy.email.loginWithCode("123456", sentTo: "myuser@privy.io")
        // user successfully logged in
    } catch {
        print("error logging user in: \(error)")
    }
    ```
  </Tab>

  <Tab title="Android">
    To authenticate a user via their email address, use the Privy client's `email` handler.

    ## Send Code

    ```kotlin
    sendCode(email: String): Result<Unit>
    ```

    ### Parameters

    <ParamField path="email" type="String" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="Result<Unit>" type="Result<Unit>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```kotlin
    loginWithCode(code: String, email: String?): Result<PrivyUser>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="email" type="String">
      (Optional) The user's email address. Though this parameter is optional, it is highly recommended that you pass the user's email address explicitly. If email is omitted, the email from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Result<PrivyUser>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```kotlin
    // Send code to user's email
    val result: Result<Unit> = privy.email.sendCode(email = "user_email@gmail.com")

    result.fold(
      onSuccess = {
        // OTP was successfully sent
      },
      onFailure = {
        println("Error sending OTP: ${it.message}")
      }
    )

    // Authenticate with the OTP code
    val result: Result<PrivyUser> = privy.email.loginWithCode(code = "123456", email = "user_email@gmail.com")

    result.fold(
      onSuccess = { user ->
        // User logged in
      },
      onFailure = {
        println("Error logging in user: ${it.message}")
      }
    )
    ```
  </Tab>

  <Tab title="Unity">
    To authenticate a user via their email address, use the Privy client's `Email` handler.

    ## Send Code

    ```csharp
    SendCode(string email): Task<bool>
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="Task<bool>" type="Task<bool>">
      A Task that resolves to a boolean indicating whether the code was sent successfully.
    </ResponseField>

    ## Login with Code

    ```csharp
    LoginWithCode(string email, string code): Task
    ```

    ### Parameters

    <ParamField path="email" type="string" required>
      The user's email address.
    </ParamField>

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    ### Returns

    <ResponseField name="Task" type="Task">
      A Task that completes when the user is successfully authenticated, or throws an exception if authentication fails.
    </ResponseField>

    ## Usage

    ```csharp
    // Send code to user's email
    bool success = await PrivyManager.Instance.Email.SendCode(email);

    if (success)
    {
        // Prompt user to enter the OTP they received at their email address through your UI
    }
    else
    {
        // There was an error sending an OTP to your user's email
    }

    // Authenticate with the OTP code
    try
    {
        // User will be authenticated if this call is successful
        await PrivyManager.Instance.Email.LoginWithCode(email, code);
        // User is now logged in
    }
    catch
    {
        // If "LoginWithCode" throws an exception, user login was unsuccessful.
        Debug.Log("Error logging user in.");
    }
    ```
  </Tab>

  <Tab title="Flutter">
    To authenticate a user via their email address, use the Privy client's `email` handler.

    ## Send Code

    ```dart
    sendCode(String email): Future<Result<void>>
    ```

    ### Parameters

    <ParamField path="email" type="String" required>
      The email address of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="Result<void>" type="Future<Result<void>>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```dart
    loginWithCode({required String code, String? email}): Future<Result<PrivyUser>>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's email address.
    </ParamField>

    <ParamField path="email" type="String">
      (Optional) The user's email address. Though this parameter is optional, it is highly recommended that you pass the user's email address explicitly. If email is omitted, the email from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Future<Result<PrivyUser>>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```dart
    // Send code to user's email
    final Result<void> result = await privy.email.sendCode(email);

    result.fold(
      onSuccess: (_) {
        // OTP was sent successfully
      },
      onFailure: (error) {
        // Handle error sending OTP
        print(error.message);
      },
    );

    // Authenticate with the OTP code
    final Result<PrivyUser> result = await privy.email.loginWithCode(
      code: code,
      email: email,
    );

    result.fold(
      onSuccess: (user) {
        // User authenticated successfully
      },
      onFailure: (error) {
        // Handle authentication error
      },
    );
    ```
  </Tab>
</Tabs>


# Farcaster
Source: https://docs.privy.io/authentication/user-authentication/login-methods/farcaster



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored onchain.
Privy enables your users to log in to your application using their Farcaster account. Privy uses a standard called **Sign in with Farcaster** ([FIP-11](https://github.com/farcasterxyz/protocol/discussions/110))
to issue a signature request to a user's Farcaster account via the client a user has. Warpcast is currently supported.

Your application can even request permissions from the user to become a signer for their Farcaster account, allowing your application to engage with the Farcaster social graph on their behalf.

<Tip>
  Interested in building a Farcaster frame? Check out our [Farcaster frames
  recipe](/recipes/farcaster/frames)!
</Tip>

<Tabs>
  <Tab title="React">
    <Info>
      Privy currently only supports Farcaster login in React via the Privy UIs. To enable Farcaster login, you need to configure the Privy SDK with the `farcaster` login method.
    </Info>

    ```tsx
    <PrivyProvider
      appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
      config={{
        // This configures farcaster and other login methods for your app.
        appearance: {
            loginMethods: ['farcaster', ...otherLoginMethods]
        },
        ...otherConfig
      }}
    >
    ```

    From there, you can prompt your users to authenticate via the `login` method:

    ```tsx
    import { usePrivy } from '@privy-io/react';
    ...
    const { login } = usePrivy();
    login();
    ```
  </Tab>

  <Tab title="React Native">
    To authenticate a user via Farcaster ([SIWF](https://github.com/farcasterxyz/protocol/discussions/110)), use the `loginWithFarcaster` method
    from the `useLoginWithFarcaster` hook.

    ```javascript
    loginWithFarcaster(input: {
      relyingParty: string;
      redirectUrl?: string;
      disableSignup?: boolean;
    }, config?: {
      pollIntervalMs?: number;
      pollAttempts?: number;
    }): Promise<PrivyUser | null>;
    ```

    ### Initializing the login flow

    To initialize login, use the `loginWithFarcaster` function from the `useLoginWithFarcaster` hook to start the Farcaster login flow.

    ```tsx
    import { useLoginWithFarcaster } from '@privy-io/expo';

    const { loginWithFarcaster, state } = useLoginWithFarcaster();
    ```

    As a parameter to `loginWithFarcaster`, you should pass an object containing:

    <ParamField path="input.relyingParty" type="string" required>
      Your app's website. Described in SIWF spec as "Origin domain of app frontend."
    </ParamField>

    <ParamField path="input.redirectUrl" type="string">
      A URL path that Warpcast will automatically redirect to after successful authentication. This defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    <ParamField path="input.disableSignup" type="boolean">
      If true, the flow will only allow existing users to log in, preventing new account creation.
    </ParamField>

    <ParamField path="options.pollIntervalMs" type="number">
      The interval in milliseconds which your app will poll a status endpoint to check if the user has successfully signed in using Warpcast.
    </ParamField>

    <ParamField path="options.pollAttempts" type="number">
      The number of polling attempts that will be made to check for successful login.
    </ParamField>

    <Warning>
      If you pass in custom polling configuration, make sure to give the user enough time to go through the login process on Warpcast. The default values are `pollIntervalMs = 1000` and `pollAttempts = 10` giving the user 10 seconds to go through the login process. In our testing, this is usually enough time, but you may want to make it longer.
    </Warning>

    When this method is invoked, the user will be deeplinked to the Warpcast app on their device if they have it installed, or an installation page for the app. Within the Warpcast app, they can complete the login flow.

    If `loginWithFarcaster` succeeds, it will return a `PrivyUser` object with details about the authenticated user.

    Reasons `loginWithFarcaster` might fail include:

    * the network request fails
    * the login attempt is made after the user is already logged in
    * the user cancels the login flow after being linked out to Warpcast
    * the user takes too long to login and the polling time expires

    ### Tracking Flow State

    Track the state of the Farcaster flow via the `state` variable returned by the `useLoginWithFarcaster` hook.

    ```tsx
    state:
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'generating-uri'}
      | {status: 'awaiting-uri'}
      | {status: 'polling-status'}
      | {status: 'submitting-token'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'generating-uri' | 'awaiting-uri' | 'polling-status' | 'submitting-token' | 'done'">
      The current state of the Farcaster flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the Farcaster flow (only present when status is 'error').
    </ResponseField>

    ### Usage: Conditional Rendering

    ```tsx
    import { View, ActivityIndicator, Text } from 'react-native';
    import { useLoginWithFarcaster, hasError } from '@privy-io/expo';

    export function LoginScreen() {
      const { state, loginWithFarcaster } = useLoginWithFarcaster();

      return (
        <View>
          <Button
            onPress={() => loginWithFarcaster({ relyingParty: 'https://example.app' })}
            title="Login with Farcaster"
            disabled={state.status !== 'initial' && state.status !== 'error'}
          />

          {state.status === 'polling-status' && (
            <View>
              <ActivityIndicator />
              <Text>Waiting for Warpcast confirmation...</Text>
            </View>
          )}

          {hasError(state) && (
            <Text style={{ color: 'red' }}>
              Error: {state.error.message}
            </Text>
          )}
        </View>
      );
    }
    ```

    ### Callbacks

    You can optionally pass callbacks to the `useLoginWithFarcaster` hook to run custom logic after a successful login or to handle errors.

    #### `onSuccess`

    ```tsx
    onSuccess: (user: PrivyUser, isNewUser: boolean) => Promise<void>
    ```

    ##### Parameters

    <ParamField path="user" type="PrivyUser">
      The user object returned after successful login.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    #### `onError`

    ```tsx
    onError: (error: Error) => Promise<void>
    ```

    ##### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the Farcaster flow.
    </ParamField>

    #### Usage with Callbacks

    ```tsx
    import { useLoginWithFarcaster } from '@privy-io/expo';

    export function LoginScreen() {
      const { loginWithFarcaster } = useLoginWithFarcaster({
        onSuccess(user, isNewUser) {
          console.log('Login successful', { user, isNewUser });
          // Navigate to home screen, show welcome message, etc.
        },
        onError(error) {
          console.error('Login failed', error);
          // Show error toast, update UI, etc.
        }
      });

      return (
        <Button
          onPress={() => loginWithFarcaster({ relyingParty: 'https://example.app' })}
          title="Login with Farcaster"
        />
      );
    }
    ```
  </Tab>
</Tabs>


# Guest accounts
Source: https://docs.privy.io/authentication/user-authentication/login-methods/guest



<Info>
  Privy enables developers to create Guest accounts for users, so that users can immediately use your app without going through a login flow.

  Guest accounts are available in @privy-io/react-auth\@1.77.0 and above.
</Info>

Privy guest accounts have powerful features:

* They are locally persisted, so guest users can leave and return to the same account on the same device.
* They have **fully functioning** embedded wallets that can transact and mint on-chain.
* They are upgradable to fully logged-in accounts by simply calling `login()`.
* They have stable user IDs that do not change once a user is fully logged in.
* They can be logged out and deleted as needed.

## Integration tips

* **Guest account creation:** If a user is not logged in at all (via guest or normal user account), we recommend showing guest account creation and normal user login side-by-side.
  * e.g. a “Continue as Guest” button next to a “Login or Create Account” button. This is so users do not create guest accounts unintentionally when they mean to log in with an existing account.
* **Guest account upgrade:** If a user is logged in as a guest, we recommend showing two options: upgrade or delete.
  * *Upgrade guest account*: When a guest upgrades to a full user, they must enter a new login credential. If they try to upgrade with a credential (e.g. email address) that already is associated with an existing account, they will see a “Could not link existing account” error message.
  * *Delete guest account*: If a guest prefers to use an existing account instead, they must delete their guest account first. We recommend surfacing a “delete” option explicitly so guests can opt-into abandoning their guest account in favor of an existing account.
* You can make use of [login and error callbacks](/authentication/user-authentication/login-methods/email) to customize your desired behavior when a user upgrades out of guest-mode.

## Please note

<Warning>
  Guest accounts are **valid for 30 days**. If the guest does not upgrade to a full user account
  within 30 days, the guest session will expire.
</Warning>

* User data and embedded wallets from guest sessions **cannot** be merged into an existing user account — guest accounts can only be *upgraded* into a new user account. If a guest user wants to log in with an existing account, you must delete the guest user session first.
* Note that Telegram is not available as an upgrade login method for guest accounts.

## Configure guest accounts

<Tip>Enable Guest accounts by toggling on in the Advanced Settings dashboard page.</Tip>

<Tabs>
  <Tab title="React">
    ### Usage

    Use the `createGuestAccount` function from the `useGuestAccounts` hook in the React SDK to integrate guest accounts. The `createGuestAccount` function returns an [authenticated `User` object](/user-management/users/the-user-object).

    ```jsx
    import {useGuestAccounts} from '@privy-io/react-auth';
    // createGuestAccount: () => Promise<User>
    const {createGuestAccount} = useGuestAccounts();
    ```

    `createGuestAccount` is an asynchronous call that will create and authenticate users as guests. If the user is already a guest, this call is idempotent. If the user is already *logged in* as a non-guest user, this will throw an error indicating as such.

    ### Check if a user is a guest

    To check if a User is a guest account, use the `isGuest` property on the `User` object returned by the `usePrivy` hook.

    ```jsx
    const {user} = usePrivy();

    // isGuest: boolean
    user.isGuest;
    ```

    ### Access a guest user ID

    To access the guest’s user data including their stable user ID and wallet address, access the user object from the `usePrivy` hook.

    ```tsx
    const {user} = usePrivy();

    // Get the user's stable User ID and their wallet address.
    user.id;
    user.wallet.address;
    ```

    ### Access a guest user’s embedded wallet

    To transact with the guest user’s embedded wallet, [use the appropriate wallet from the connected `wallets` array.](/wallets/wallets/get-a-wallet) All embedded wallet functionality that is available for logged-in users is also available to guest users.

    ```tsx
    const {wallets} = useWallets();
    const embeddedWallet = getEmbeddedConnectedWallet(wallets);

    // Get the embedded wallet address or send a transaction.
    embeddedWallet.address;
    const provider = await embeddedWallet.getEthereumProvider()
    provider.request({method: 'eth_sendTransaction', params: [...]});
    ```

    ### Upgrade a guest user to a logged-in user

    Simply call `login()` to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.

    ```tsx
    // login: (options?) => void
    const {login} = usePrivy();
    ```

    ### Enable a guest user to delete their guest session

    Call `logout()` to enable the guest user to delete their guest session. This is an important interface to support so that users who start a guest session but would prefer to log in with a pre-existing account, are able to do so.

    ```tsx
    // logout: (options?) => void
    const {logout} = usePrivy();
    ```
  </Tab>

  <Tab title="React Native">
    ### Usage

    Use `guest` from the `useCreateGuestAccount` hook in the React SDK to integrate guest accounts. The `guest.create()` function returns an [authenticated `User` object](/user-management/users/the-user-object).

    ```jsx
    import {useCreateGuestAccount} from '@privy-io/expo';
    const guest = useCreateGuestAccount();
    ```

    `guest.create()` is an asynchronous call that will create and authenticate users as guests. If the user is already a guest, this call is idempotent. If the user is already *logged in* as a non-guest user, this will throw an error indicating as such.

    ### Check if a user is a guest

    To check if a User is a guest account, use the `isGuest` property on the `User` object returned by the `usePrivy` hook.

    ```jsx
    const {user} = usePrivy();

    // isGuest: boolean
    user.isGuest;
    ```

    ### Access a guest user ID

    To access the guest’s user data including their stable user ID and wallet address, access the user object from the `usePrivy` hook.

    ```tsx
    const {user} = usePrivy();

    // Get the user's stable User ID and their wallet address.
    user.id;
    user.wallet.address;
    ```

    ### Access a guest user’s embedded wallet

    To transact with the guest user’s embedded wallet, [use the appropriate wallet from the connected `wallets` array.](/wallets/wallets/get-a-wallet) All embedded wallet functionality that is available for logged-in users is also available to guest users.

    ```tsx
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';
    const {wallets} = useEmbeddedEthereumWallet();
    const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
    ```

    ### Upgrade a guest user to a logged-in user

    Simply call `login()` to enable the guest user to upgrade their account to a logged-in account using any authentication method of their choice.

    ```tsx
    // login: (options?) => void
    const {login} = useLogin();
    ```

    ### Enable a guest user to delete their guest session

    Call `logout()` to enable the guest user to delete their guest session. This is an important interface to support so that users who start a guest session but would prefer to log in with a pre-existing account, are able to do so.

    ```tsx
    // logout: (options?) => void
    const {logout} = usePrivy();
    ```
  </Tab>
</Tabs>


# OAuth
Source: https://docs.privy.io/authentication/user-authentication/login-methods/oauth



Privy offers the ability to sign up and log users in using OAuth providers. Users can sign in with familiar flows on Google, Apple, Twitter, Github, Discord, LinkedIn, TikTok, Spotify, and Instagram.

Login with OAuth is the onboarding flow your users are used to, integrated into your application in just a few lines of code.

<Tabs>
  <Tab title="React">
    <Tip>
      The React SDK supports OAuth login with Google, Apple, Twitter, GitHub, Discord, LinkedIn, Spotify, TikTok, and Instagram.
      For all other OAuth providers, you can use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth).
    </Tip>

    Use `initOAuth` from the `useLoginWithOAuth` hook to trigger the OAuth login flow.

    ```jsx
    initOAuth: ({ provider: OAuthProviderType, disableSignup?: boolean }) => Promise<void>
    ```

    <ParamField path="provider" type="OAuthProviderType" required>
      The OAuth provider to use for authentication. Valid values are: `'google'`, `'apple'`, `'twitter'`,
      `'github'`, `'discord'`, `'linkedin'`, `'spotify'`, `'tiktok'`, `'instagram'`.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      If set to true, the OAuth flow will only allow users to log in with existing accounts and prevent new account creation.
    </ParamField>

    ### Usage

    ```jsx
    import { useLoginWithOAuth } from '@privy-io/react-auth';

    export default function LoginWithOAuth() {
      const { state, loading, initOAuth } = useLoginWithOAuth();

      const handleLogin = async () => {
          try {
              // The user will be redirected to OAuth provider's login page
              await initOAuth({ provider: 'google' });
          } catch (err) {
              // Handle errors (network issues, validation errors, etc.)
              console.error(err);
          }
      };

      return (
          <div>
              <button onClick={handleLogin} disabled={loading}>
                  {loading ? 'Logging in...' : 'Log in with Google'}
              </button>
          </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OAuth flow via the `state` variable returned by the `useLoginWithOAuth` hook.

    ```tsx
    state:
    | {status: 'initial'}
    | {status: 'loading'}
    | {status: 'done'}
    | {status: 'error'; error: Error | null};
    ```

    <ResponseField name="status" type="'initial' | 'loading' | 'done' | 'error'">
      The current state of the OAuth flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OAuth flow (only present when status is 'error').
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks to the `useLoginWithOAuth` hook to run custom logic after a successful login or to handle errors.

    ### `onSuccess`

    ```tsx
    onSuccess: ({user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount}) => void
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object returned after successful login.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user was already authenticated before the OAuth flow.
    </ParamField>

    <ParamField path="loginMethod" type="string">
      The login method used ('google', 'apple', etc.).
    </ParamField>

    <ParamField path="linkedAccount" type="LinkedAccount">
      The linked account if the user was already authenticated.
    </ParamField>

    ### `onError`

    ```tsx
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the OAuth flow.
    </ParamField>

    ### Example with Callbacks

    ```jsx
    import { useLoginWithOAuth } from '@privy-io/react-auth';

    export default function LoginWithOAuth() {
        const { initOAuth } = useLoginWithOAuth({
            onSuccess: ({ user, isNewUser }) => {
                console.log('User logged in successfully', user);
                if (isNewUser) {
                    // Perform actions for new users
                }
            },
            onError: (error) => {
                console.error('Login failed', error);
            }
        });

        return (
            <button onClick={() => initOAuth({ provider: 'google' })}>
                Log in with Google
            </button>
        );
    }
    ```

    ### Security

    We recommend configuring allowed OAuth redirect URLs to restrict where users can be redirected after they log in with an external OAuth provider. [Learn more here](/recipes/react/allowed-oauth-redirects)!
  </Tab>

  <Tab title="React Native">
    <Info>
      The React Native (Expo) SDK supports OAuth login with Google, Apple, Twitter, GitHub, Discord,
      LinkedIn, Spotify, TikTok, and Instagram. For all other OAuth providers, you can use [JWT-based
      authentication](/authentication/user-authentication/jwt-based-auth).
    </Info>

    <Tip>
      Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running
      on iOS. To configure native Apple login, follow this
      [guide](/basics/react-native/advanced/setup-apple-login).
    </Tip>

    Use `login` from the `useLoginWithOAuth` hook to authenticate users using an OAuth provider.

    ```tsx
    login: ({
      provider: OAuthProviderType,
      disableSignup?: boolean
    }) => Promise<PrivyUser>
    ```

    ### Parameters

    <ParamField path="provider" type="OAuthProviderType" required>
      The OAuth provider to use for authentication. Valid values are: `'google'`, `'apple'`, `'twitter'`,
      `'github'`, `'discord'`, `'linkedin'`, `'spotify'`, `'tiktok'`, `'instagram'`.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      If true, the OAuth flow will only allow existing users to log in, preventing new account creation.
    </ParamField>

    ### Response

    <ResponseField name="user" type="PrivyUser">
      The user object returned after successful login.
    </ResponseField>

    ### Usage

    ```tsx
    import { useLoginWithOAuth } from '@privy-io/expo';

    export function LoginButton() {
      const { login, state } = useLoginWithOAuth();

      return (
        <Button
          onPress={() => login({ provider: 'google' })}
          disabled={state.status === 'loading'}
        >
          {state.status === 'loading' ? 'Logging in...' : 'Login with Google'}
        </Button>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OAuth flow via the `state` variable returned by the `useLoginWithOAuth` hook.

    ```tsx
    state:
      | {status: 'initial'}
      | {status: 'loading'}
      | {status: 'done'}
      | {status: 'error'; error: Error | null};
    ```

    <ResponseField name="status" type="'initial' | 'loading' | 'done' | 'error'">
      The current state of the OAuth flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OAuth flow (only present when status is 'error').
    </ResponseField>

    ### Usage: Conditional Rendering

    ```tsx
    import { View, Text, Button } from 'react-native';
    import { usePrivy, useLoginWithOAuth, hasError } from '@privy-io/expo';

    export function LoginScreen() {
      const { user } = usePrivy();
      const { state, login } = useLoginWithOAuth();

      return state.status === 'done' ? (
        <View>
          <Text>You logged in successfully</Text>
        </View>
      ) : (
        <View>
          <Button
            disabled={state.status === 'loading'}
            onPress={() => login({ provider: 'google' })}
            title={state.status === 'loading' ? 'Logging in...' : 'Login with Google'}
          />

          {hasError(state) && (
            <Text>Error: {state.error.message}</Text>
          )}
        </View>
      );
    }
    ```

    ## Callbacks

    You can optionally pass callbacks to the `useLoginWithOAuth` hook to run custom logic after a successful login or to handle errors.

    ### `onSuccess`

    ```tsx
    onSuccess: (user: PrivyUser, isNewUser: boolean) => Promise<void>
    ```

    #### Parameters

    <ParamField path="user" type="PrivyUser">
      The user object returned after successful login.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    ### `onError`

    ```tsx
    onError: (error: Error) => Promise<void>
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the OAuth flow.
    </ParamField>

    ### Usage with Callbacks

    ```tsx
    import { useLoginWithOAuth } from '@privy-io/expo';

    export function LoginScreen() {
      const { login } = useLoginWithOAuth({
        onSuccess(user, isNewUser) {
          console.log('Logged in successfully', { user, isNewUser });
          // Navigate to home screen, show welcome message, etc.
        },
        onError(error) {
          console.error('Login failed', error);
          // Show error message
        }
      });

      return (
        <Button
          onPress={() => login({ provider: 'google' })}
          title="Login with Google"
        />
      );
    }
    ```
  </Tab>

  <Tab title="Swift">
    To authenticate a user via an OAuth account (e.g. Google), use the Privy client's `oAuth` handler.

    <Info>
      The Swift SDK supports OAuth login with Google, Apple, and Twitter.
      For all other OAuth providers, you can use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth).
    </Info>

    <Tip>
      Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running
      on iOS. To configure native Apple login, follow this [guide](/recipes/swift/apple).
    </Tip>

    <Warning>
      Prior to integrating OAuth login, make sure you have properly configured your app's allowed URL schemes in the Privy dashboard. Login with OAuth will **not** work if you have not completed this step.
    </Warning>

    ## Initializing the login flow

    To launch the oAuth flow, simply call `privy.oAuth.login`. As parameters to this method, pass the following fields:

    <ParamField path="provider" type="OAuthProvider" required>
      A member of the `OAuthProvider` enum specifying which OAuth provider the user should login with. Currently, `.google`, `.apple` and `.twitter` are supported.
    </ParamField>

    <ParamField path="appUrlScheme" type="String">
      (Optional). Your app's URL scheme as a string. If you do not pass this value, Privy will use the first valid app URL scheme from your app's `info.plist`.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="PrivyUser">
      The authenticated Privy user
    </ResponseField>

    ### Throws

    An error if logging the user in is unsuccessful.

    ### Usage

    ```swift
    do {
        let privyUser = try await privy.oAuth.login(with: OAuthProvider.google, appUrlScheme: "privyiosdemo")
    } catch {
        print("OAuth login error: \(error)")
    }
    ```

    That's it! If your user was successfully authenticated, the `login` method will return the new AuthSession.

    ### Handling errors

    An error could be thrown if:

    * Your app url scheme is not explicitly provided or set in your info.plist
    * Your app url scheme is not registered in the Privy dashboard.
    * There was an issue generating the OAuth provider login URL
    * The user declined or cancelled the login attempt, or there was another error during authentication

    If an error is thrown, you can get a description of the error as a `string` from the `error` thrown by `privy.oAuth.login`.

    ## Native Apple login

    To configure native apple login, follow this [guide](/recipes/swift/apple).
  </Tab>

  <Tab title="Unity">
    To authenticate a user via an OAuth account (e.g. Google, Discord, Apple), use the Privy client's `OAuth` handler.

    This is a two step process, though Privy's Unity SDK wraps it into a single method call:

    1. Generate an OAuth login URL corresponding to your desired OAuth provider
    2. Redirect the user to the login URL to have them authenticate with the chosen OAuth provider

    ## Supported OAuth Providers

    <Info>
      Privy's Unity SDK currently supports OAuth login with Google, Apple and Discord.
      For all other OAuth providers, you can use [JWT-based authentication](/authentication/user-authentication/jwt-based-auth).
    </Info>

    ## Configure allowed URL schemes

    Prior to integrating OAuth login, make sure you have properly configured your app's allowed URL schemes in the Privy dashboard.

    For non-web platforms, be sure to [setup deeplinking](/basics/get-started/dashboard/app-clients) with your allowed URL scheme.

    <Warning>
      Login with OAuth will **not** work if you have not completed this step.
    </Warning>

    ## Initializing the login flow

    To launch the OAuth flow, simply call `PrivyManager.Instance.OAuth.LoginWithProvider`. As parameters to this method, pass the following fields:

    <ParamField path="provider" type="OAuthProvider" required>
      A member of the `OAuthProvider` enum specifying which OAuth provider the user should login with.
    </ParamField>

    <ParamField path="redirectUri" type="String" required>
      For WebGL builds, this will be your redirect URL. For applications, this will be your app's URL scheme.
    </ParamField>

    ### Usage

    ```csharp
    try
    {
        // Log the user in with Google OAuth
        await PrivyManager.Instance.OAuth.LoginWithProvider(OAuthProvider.Google, "myappscheme");
    }
    catch
    {
        // Login with OAuth was unsuccessful
        Debug.Log("Error logging user in.");
    }
    ```

    That's it! If your user was successfully authenticated, the `LoginWithProvider` method will return the new `AuthState` for a user.

    This method will throw an error if:

    * a `redirectUri` is not provided
    * the network call to authenticate the user fails
  </Tab>
</Tabs>


# Passkey
Source: https://docs.privy.io/authentication/user-authentication/login-methods/passkey



export const ExpoUserObject = ({description}) => {
  return <ResponseField name="user" type="PrivyUser">
      {description}
      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="id" type="string">
          The Privy DID which you may use to identify your user on your backend
        </ResponseField>
        <ResponseField name="created_at" type="number">
          UNIX timestamp of when the user was created
        </ResponseField>
        <ResponseField name="linked_accounts" type="Array">
          An array of the user's linked accounts
          <Expandable title="Account Types">
            <ResponseField name="AppleAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'apple_oauth'
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email address associated with the user's Apple account
                </ResponseField>
                <ResponseField name="subject" type="number">
                  ID of user from Apple's user API
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="CustomJwtAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'custom_auth'
                </ResponseField>
                <ResponseField name="custom_user_id" type="string">
                  ID of user from custom auth provider
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="DiscordAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'discord_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Discord user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from Discord user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  Username of user from Discord user API response, including the 4-digit
                  discriminator prefixed by '#'
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="EmailAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'email'
                </ResponseField>
                <ResponseField name="address" type="string">
                  Email address of user account
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="FarcasterAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'farcaster'
                </ResponseField>
                <ResponseField name="fid" type="number">
                  FID of the user from Farcaster user API response
                </ResponseField>
                <ResponseField name="owner_address" type="string">
                  Wallet address of the user from Farcaster user API response (Farcaster wallet
                  address, not Privy embedded wallet address)
                </ResponseField>
                <ResponseField name="username" type="string" optional>
                  Username of user from Farcaster user API response (does not include the '@')
                </ResponseField>
                <ResponseField name="display_name" type="string" optional>
                  Display name of user from Farcaster user API response
                </ResponseField>
                <ResponseField name="bio" type="string" optional>
                  Bio of user from Farcaster user API response
                </ResponseField>
                <ResponseField name="profile_picture_url" type="string" optional>
                  Profile picture URL of the user from Farcaster user API response
                </ResponseField>
                <ResponseField name="homepage_url" type="string" optional>
                  Profile URL of the user from Farcaster user API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="GithubAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'github_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from GitHub user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from GitHub user API response
                </ResponseField>
                <ResponseField name="name" type="string">
                  Name of user from GitHub user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  Username of user from GitHub user API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="GoogleAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'google_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  'sub' pulled from Google-provided JWT with "openid" scope
                </ResponseField>
                <ResponseField name="email" type="string">
                  'email' from Google-provided JWT with "email" scope
                </ResponseField>
                <ResponseField name="name" type="string">
                  'name' from Google-provided JWT with "profile" scope
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="InstagramAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'instagram_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Instagram user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  The name displayed on a user's profile from Instagram's `/me` API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="LinkedinAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'linkedin_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from LinkedIn user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from LinkedIn user API response
                </ResponseField>
                <ResponseField name="name" type="string">
                  Name of user from LinkedIn user API response (does not include the '@')
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="PhoneAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'phone'
                </ResponseField>
                <ResponseField name="number" type="string">
                  Phone number of user account (non-international numbers default to US)
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="SpotifyAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'spotify_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Spotify user API response
                </ResponseField>
                <ResponseField name="email" type="string">
                  Email of user from Spotify user API
                </ResponseField>
                <ResponseField name="name" type="string">
                  The name displayed on a user's profile from Spotify display_name API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="TelegramAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'telegram'
                </ResponseField>
                <ResponseField name="telegram_user_id" type="string">
                  ID of a user's telegram account
                </ResponseField>
                <ResponseField name="first_name" type="string">
                  The first name displayed on a user's telegram account
                </ResponseField>
                <ResponseField name="last_name" type="string" optional>
                  The last name displayed on a user's telegram account
                </ResponseField>
                <ResponseField name="username" type="string" optional>
                  The username displayed on a user's telegram account
                </ResponseField>
                <ResponseField name="photo_url" type="string" optional>
                  The url of a user's telegram account profile picture
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="TwitterAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'twitter_oauth'
                </ResponseField>
                <ResponseField name="subject" type="string">
                  ID of user from Twitter user API response
                </ResponseField>
                <ResponseField name="name" type="string">
                  Name of user from Twitter user API response
                </ResponseField>
                <ResponseField name="username" type="string">
                  Username of user from Twitter user API response (does not include the '@')
                </ResponseField>
                <ResponseField name="profile_picture_url" type="string" optional>
                  Profile picture URL of the user from Twitter user API response
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
            <ResponseField name="WalletAccount" type="Object">
              <Expandable title="child attributes" defaultOpen="true">
                <ResponseField name="type" type="string">
                  'wallet'
                </ResponseField>
                <ResponseField name="chain_type" type="string">
                  Type of chain for the wallet: 'ethereum' or 'solana'
                </ResponseField>
                <ResponseField name="address" type="string">
                  Checksummed wallet address
                </ResponseField>
                <ResponseField name="first_verified_at" type="number">
                  UNIX timestamp for when the account was first verified and linked to the user
                </ResponseField>
                <ResponseField name="latest_verified_at" type="number">
                  UNIX timestamp for when the account was last verified
                </ResponseField>
              </Expandable>
            </ResponseField>
          </Expandable>
        </ResponseField>
      </Expandable>
    </ResponseField>;
};

Privy offers the ability to sign up and log users in using a passkey. This lets users access their account simply and securely.

<Tabs>
  <Tab title="React">
    ## Login with Passkey

    Use `loginWithPasskey` from the `useLoginWithPasskey` hook to trigger the passkey login flow.

    ```jsx
    loginWithPasskey: ({ passkey?: string }) => void
    ```

    <ParamField path="passkey" type="string">
      Optionally prompt the user to sign in with a specific passkey credential.
    </ParamField>

    ### Usage

    ```jsx
    import { useLoginWithPasskey } from '@privy-io/react-auth';

    export default function LoginWithPasskey() {
      const { loginWithPasskey } = useLoginWithPasskey();

      return (
        <div>
          <button onClick={loginWithPasskey}>Log in with passkey</button>
        </div>
      );
    }
    ```

    ## Sign up with Passkey

    Use `signupWithPasskey` from the `useSignupWithPasskey` hook to trigger the passkey signup flow.

    ```jsx
    signupWithPasskey: () => void
    ```

    ### Usage

    ```jsx
    import { useSignupWithPasskey } from '@privy-io/react-auth';

    export default function SignupWithPasskey() {
      const { signupWithPasskey } = useSignupWithPasskey();

      return (
        <div>
          <button onClick={signupWithPasskey}>Sign up with passkey</button>
        </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the passkey flow via the `state` variable returned by both the
    `useLoginWithPasskey` and `useSignupWithPasskey` hooks.

    ```tsx
    state:
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'generating-challenge'}
      | {status: 'awaiting-passkey'}
      | {status: 'submitting-response'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'generating-challenge' | 'awaiting-passkey' | 'submitting-response' | 'done'">
      The current state of the passkey flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the passkey flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithPasskey` and `useSignupWithPasskey` hooks to run custom logic after a successful login or signup, or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx
    onComplete: ({user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount}) => void
    ```

    #### Parameters

    <ParamField path="User" type="PrivyUser">
      The [user object](/user-management/users/the-user-object) returned after successful login or signup."
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user was already authenticated before the passkey flow.
    </ParamField>

    <ParamField path="loginMethod" type="'passkey'">
      The login method used to authenticate the user.
    </ParamField>

    <ParamField path="linkedAccount" type="LinkedAccount">
      The linked account if the user was already authenticated.
    </ParamField>

    ### `onError`

    ```tsx
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the passkey flow.
    </ParamField>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Follow the [passkeys setup guide](/basics/react-native/advanced/setup-passkeys) to enable passkey authentication in your React Native app.
    </Tip>

    ## Login with Passkey

    Use `loginWithPasskey` from the `useLoginWithPasskey` hook to authenticate users using a passkey. Before using this method, ensure you have setup passkeys as described in this [guide](/basics/react-native/advanced/setup-passkeys).

    ```tsx
    loginWithPasskey: ({ relyingParty: string }) => Promise<PrivyUser>
    ```

    ### Parameters

    <ParamField path="relyingParty" type="string" required>
      The URL origin where your Apple App Site Association or Digital Asset Links are available (e.g. `https://example.com`).
    </ParamField>

    ### Response

    <ExpoUserObject description="The user object returned after successful login." />

    ### Usage

    ```tsx
    import {useLoginWithPasskey} from '@privy-io/expo/passkey';

    export function LoginButton() {
      const {loginWithPasskey} = useLoginWithPasskey();

      return (
        <Button onPress={() => loginWithPasskey({relyingParty: '<your-applications-relying-party>'})}>
          Login
        </Button>
      );
    }
    ```

    ## Sign up with Passkey

    Use `signupWithPasskey` from the `useSignupWithPasskey` hook to sign up users using a passkey.

    ```tsx
    signupWithPasskey: ({ relyingParty: string }) => Promise<PrivyUser>
    ```

    ### Parameters

    <ParamField path="relyingParty" type="string" required>
      The URL origin where your Apple App Site Association or Digital Asset Links are available (e.g. `https://example.com`).
    </ParamField>

    ### Response

    <ExpoUserObject description="The user object returned after successful signup." />

    ### Usage

    ```tsx
    import {useSignupWithPasskey} from '@privy-io/expo/passkey';

    export function SignupButton() {
      const {signupWithPasskey} = useSignupWithPasskey();

      return (
        <Button onPress={() => signupWithPasskey({relyingParty: '<your-applications-relying-party>'})}>
          Signup
        </Button>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the passkey flow via the `state` variable returned by both the
    `useLoginWithPasskey` and `useSignupWithPasskey` hooks.

    {/* spellchecker:off */}

    ```tsx
    state:
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'generating-challenege'}
      | {status: 'awaiting-passkey'}
      | {status: 'submitting-response'}
      | {status: 'done'};
    ```

    {/* spellchecker:on */}

    <ResponseField name="status" type="'initial' | 'error' | 'generating-challenege' | 'awaiting-passkey' | 'submitting-response' | 'done'">
      {/* spellchecker:disable-line */}

      The current state of the passkey flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the passkey flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithPasskey` and `useSignupWithPasskey` hooks to run custom logic after a successful login or signup, or to handle errors that occur during the flow.

    ### `onSuccess`

    ```tsx
    onSuccess: (user: PrivyUser, isNewUser: boolean) => Promise<void>
    ```

    #### Parameters

    <ExpoUserObject description="The user object returned after successful login or signup." />

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    #### Usage

    ```tsx
    import {useLoginWithPasskey} from '@privy-io/expo/passkey';

    export function LoginScreen() {
      const {loginWithPasskey} = useLoginWithPasskey({
        onSuccess(user, isNewUser) {
          // show a toast, send analytics event, etc...
        },
      });

      // ...
    }
    ```

    ### `onError`

    ```tsx
    onError: (error: Error) => Promise<void>
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the passkey flow.
    </ParamField>

    #### Usage

    ```tsx
    import {useLoginWithPasskey} from '@privy-io/expo/passkey';

    export function LoginScreen() {
      const {loginWithPasskey} = useLoginWithPasskey({
        onError(error) {
          // show a toast, update form errors, etc...
        },
      });

      // ...
    }
    ```
  </Tab>
</Tabs>


# SMS
Source: https://docs.privy.io/authentication/user-authentication/login-methods/sms



Privy enables users to login to your application with SMS or email. With Privy, your application can verify ownership of a user's email address or phone number to send them notifications, campaigns, and more to keep them activated.

<Tabs>
  <Tab title="React">
    To authenticate your users with a one-time passcode (OTP) sent to their phone number, use the `useLoginWithSms` hook.

    ## Send Code

    ```tsx
    sendCode: ({phoneNumber: string, disableSignup?: boolean}) => Promise<void>
    ```

    ### Parameters

    <ParamField path="phoneNumber" type="string" required>
      The phone number of the user to log in. Must follow specific formatting conventions (see below).
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the phone number.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the code is sent.
    </ResponseField>

    ## Formatting the phone number

    The `sendCode` method requires a `phoneNumber` string param that must follow these formatting conventions:

    * By default, the implicit phone number country code is +1/US.
    * Explicitly prepending a `(+)1` to the phone number will still be read as a US phone number.
    * For non-US phone numbers, append a `+${countryCode}` to the beginning of the input value.
    * Non-numerical values in the string are ignored, except for a leading `+` that denotes a custom country code.

    ## Login with Code

    ```tsx
    loginWithCode: ({ code: string }) => Promise<void>;
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="Promise<void>">
      A promise that resolves when the user is logged in.
    </ResponseField>

    ## Usage

    ```tsx
    import { useState } from "react";
    import { useLoginWithSms } from "@privy-io/react-auth";

    export default function LoginWithSms() {
      const [phoneNumber, setPhoneNumber] = useState("");
      const [code, setCode] = useState("");
      const { state, sendCode, loginWithCode } = useLoginWithSms();

      return (
        <div>
          {/* Prompt your user to enter their phone number */}
          <input onChange={(e) => setPhoneNumber(e.currentTarget.value)} value={phoneNumber} />
          {/* Once a phone number has been entered, send the OTP to it on click */}
          <button onClick={() => sendCode({ phoneNumber })}>Send Code</button>

          {/* Prompt your user to enter the OTP */}
          <input onChange={(e) => setCode(e.currentTarget.value)} value={code} />
          {/* Once an OTP has been entered, submit it to Privy on click */}
          <button onClick={() => loginWithCode({ code })}>Log in</button>
        </div>
      );
    }
    ```

    ## Tracking Flow State

    Track the state of the OTP flow via the `state` variable returned by the
    `useLoginWithSms` hook.

    ```ts
    type OtpFlowState =
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'sending-code'}
      | {status: 'awaiting-code-input'}
      | {status: 'submitting-code'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the OTP flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the OTP flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithSms` hook to run custom logic after a successful login or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx
    onComplete?: ((params: {
        user: User;
        isNewUser: boolean;
        wasAlreadyAuthenticated: boolean;
        loginMethod: LoginMethod | null;
        loginAccount: LinkedAccountWithMetadata | null;
    }) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user entered the application already authenticated.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login.
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the loginMethod used.
    </ParamField>

    ### `onError`

    ```tsx
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>
  </Tab>

  <Tab title="React Native">
    To authenticate your users with a one-time passcode (OTP) sent to their phone number, use the `useLoginWithSMS` hook.

    ## Send Code

    ```jsx
    sendCode: ({phone: string}) => Promise<{success: boolean}>
    ```

    ### Parameters

    <ParamField path="phone" type="string" required>
      The phone number of the user to log in.
    </ParamField>

    ### Returns

    <ResponseField name="success" type="boolean">
      A promise that resolves to an object with a success property indicating if the code was sent successfully.
    </ResponseField>

    ## Login with Code

    ```jsx
    loginWithCode: ({ code: string, phone?: string, disableSignup?: boolean }) => Promise<{user: PrivyUser; isNewUser: boolean}>
    ```

    ### Parameters

    <ParamField path="code" type="string" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="phone" type="string">
      The user's phone number. Though this parameter is optional, it is highly recommended that you pass the user's phone number explicitly.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable the ability to sign up with the phone number.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="PrivyUser">
      The user object returned by the login process.
    </ResponseField>

    ## Usage

    ```jsx
    import { useState } from 'react';
    import { useLoginWithSMS } from '@privy-io/expo';

    export function LoginScreen() {
      const [phone, setPhone] = useState('');
      const [code, setCode] = useState('');
      const { sendCode, loginWithCode } = useLoginWithSMS();

      return (
        <View style={styles.container}>
          <Text>Login</Text>
          <TextInput value={phone} onChangeText={setPhone} placeholder="Phone" inputMode="tel" />
          <Button onPress={() => sendCode({ phone })}>Send Code</Button>

          <TextInput value={code} onChangeText={setCode} placeholder="Code" inputMode="numeric" />
          <Button onPress={() => loginWithCode({ code, phone })}>Login</Button>
        </View>
      );
    }
    ```

    ## Tracking login flow state

    The state variable returned from useLoginWithSMS will always be one of the following values.

    ```ts
    type OtpFlowState =
      | {status: 'initial'}
      | {status: 'error'; error: Error | null}
      | {status: 'sending-code'}
      | {status: 'awaiting-code-input'}
      | {status: 'submitting-code'}
      | {status: 'done'};
    ```

    <ResponseField name="status" type="'initial' | 'error' | 'sending-code' | 'awaiting-code-input' | 'submitting-code' | 'done'">
      The current state of the SMS login flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the SMS login flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithSMS` hook to run custom logic after an OTP has been sent, after a successful login, or to handle errors that occur during the flow.

    ### `onSendCodeSuccess`

    ```tsx
    onSendCodeSuccess?: ((phone: string) => void) | undefined
    ```

    #### Parameters

    <ParamField path="phone" type="string">
      The phone number the code was sent to.
    </ParamField>

    ### `onLoginSuccess`

    ```tsx
    onLoginSuccess?: ((user: User, isNewUser: boolean) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The PrivyUser returned by loginWithCode.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    ### `onError`

    ```tsx
    onError?: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>
  </Tab>

  <Tab title="Swift">
    To authenticate a user via their phone number, use the Privy client's `sms` handler.

    ## Send Code

    ```swift
    sendCode(to phoneNumber: String) async throws
    ```

    ### Parameters

    <ParamField path="to" type="String" required>
      The phone number of the user to log in. Must be in E.164 format (e.g., "+14155552671").
    </ParamField>

    ### Returns

    <ResponseField>
      Nothing, indicating success.
    </ResponseField>

    ### Throws

    An error if sending the code fails.

    ## Login with Code

    ```swift
    loginWithCode(_ code: String, sentTo phoneNumber: String) async throws -> PrivyUser
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="sentTo" type="String" required>
      The user's phone number.
    </ParamField>

    ### Returns

    <ResponseField name="PrivyUser" type="PrivyUser">
      The authenticated Privy user
    </ResponseField>

    ### Throws

    An error if logging the user in is unsuccessful.

    ## Usage

    ```swift
    // Send code to user's phone
    do {
        try await privy.sms.sendCode(to: "+14155552671")
        // successfully sent code to users phone
    } catch {
        print("error sending code: \(error)")
    }

    // Log the user in
    do {
        let user = try await privy.sms.loginWithCode("123456", sentTo: "+14155552671")
        // user successfully logged in
    } catch {
        print("error logging user in: \(error)")
    }
    ```
  </Tab>

  <Tab title="Android">
    To authenticate a user via their phone number, use the Privy client's `sms` handler.

    ## Send Code

    ```kotlin
    sendCode(phoneNumber: String): Result<Unit>
    ```

    ### Parameters

    <ParamField path="phoneNumber" type="String" required>
      The phone number of the user to log in. Must be in E.164 format (e.g., "+14155552671").
    </ParamField>

    ### Returns

    <ResponseField name="Result<Unit>" type="Result<Unit>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```kotlin
    loginWithCode(code: String, phoneNumber: String?): Result<PrivyUser>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="phoneNumber" type="String">
      (Optional) The user's phone number. Though this parameter is optional, it is highly recommended that you pass the user's phone number explicitly. If phone number is omitted, the phone number from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Result<PrivyUser>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```kotlin
    // Send code to user's phone number
    val result: Result<Unit> = privy.sms.sendCode(phoneNumber = "+14155552671")

    result.fold(
      onSuccess = {
        // OTP was successfully sent
      },
      onFailure = {
        println("Error sending OTP: ${it.message}")
      }
    )

    // Authenticate with the OTP code
    val result: Result<PrivyUser> = privy.sms.loginWithCode(code = "123456", phoneNumber = "+14155552671")

    result.fold(
      onSuccess = { user ->
        // User logged in
      },
      onFailure = {
        println("Error logging in user: ${it.message}")
      }
    )
    ```
  </Tab>

  <Tab title="Flutter">
    To authenticate a user via their phone number, use the Privy client's `sms` handler.

    ## Send Code

    ```dart
    sendCode(String phoneNumber): Future<Result<void>>
    ```

    ### Parameters

    <ParamField path="phoneNumber" type="String" required>
      The phone number of the user to log in. Must be in E.164 format (e.g., "+14155552671").
    </ParamField>

    ### Returns

    <ResponseField name="Result<void>" type="Future<Result<void>>">
      A Result object that indicates whether the operation was successful. Returns Result.success if the code was sent successfully, or Result.failure if there was an error.
    </ResponseField>

    ## Login with Code

    ```dart
    loginWithCode({required String code, String? phoneNumber}): Future<Result<PrivyUser>>
    ```

    ### Parameters

    <ParamField path="code" type="String" required>
      The one-time passcode sent to the user's phone number.
    </ParamField>

    <ParamField path="phoneNumber" type="String">
      (Optional) The user's phone number. Though this parameter is optional, it is highly recommended that you pass the user's phone number explicitly. If phone number is omitted, the phone number from sendCode will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<PrivyUser>" type="Future<Result<PrivyUser>>">
      A Result object containing the PrivyUser if successful, or an error if the operation failed.
    </ResponseField>

    ## Usage

    ```dart
    // Send code to user's phone number
    final Result<void> result = await privy.sms.sendCode("+14155552671");

    result.fold(
      onSuccess: (_) {
        // OTP was sent successfully
      },
      onFailure: (error) {
        // Handle error sending OTP
        print(error.message);
      },
    );

    // Authenticate with the OTP code
    final Result<PrivyUser> result = await privy.sms.loginWithCode(
      code: code,
      phoneNumber: phoneNumber,
    );

    result.fold(
      onSuccess: (user) {
        // User authenticated successfully
      },
      onFailure: (error) {
        // Handle authentication error
      },
    );
    ```
  </Tab>
</Tabs>


# Telegram
Source: https://docs.privy.io/authentication/user-authentication/login-methods/telegram



Telegram is an end to end encrypted messaging platform with in-application experiences.

Privy enables your application to easily integrate Login with Telegram in multiple ways. From a regular web environment, users can authenticate to your application with their Telegram account.

<Tip>
  Privy also enables seamless login within Telegram, so users can zero-click authenticate to your
  Telegram bot or mini-app. Check out our recipe for setting up [seamless login with
  Telegram](/recipes/react/seamless-telegram).
</Tip>

<Tabs>
  <Tab title="React">
    To authenticate your users with Telegram, use the `useLoginWithTelegram` hook.

    ```tsx
    login: () => Promise<void>
    ```

    ## Usage

    ```tsx
    import {useLoginWithTelegram} from '@privy-io/react-auth';

    export default function LoginWithTelegram() {
      const {login, state} = useLoginWithTelegram();

      const handleLogin = async () => {
        try {
          // Telegram's authentication pop-up will emerge, the user can then follow the steps to link its account.
          // If the login is successful, the user will be authenticated and the authentication information will be returned as a result
          const authenticationInfo = await login();
        } catch (err) {
          // Handle errors due to network availability, captcha failure, or input validation here
        }
      };

      return <button onClick={handleLogin}>Log in with Telegram</button>;
    }
    ```

    <Tip>
      Before using the `useLoginWithTelegram` hook, ensure that Telegram is enabled in **Socials** tab of the **Login Methods** page on the the Privy [dashboard](https://dashboard.privy.io/apps?page=login-methods\&logins=socials)
    </Tip>

    ## Tracking Flow State

    Track the state of the Telegram authentication flow via the `state` variable returned by the
    `useLoginWithTelegram` hook.

    ```ts
    type TelegramAuthFlowState =
      | {status: 'initial'}
      | {status: 'loading'}
      | {status: 'done'}
      | {status: 'error'; error: Error | null};
    ```

    <ResponseField name="status" type="'initial' | 'loading' | 'done' | 'error'">
      The current state of the Telegram authentication flow.
    </ResponseField>

    <ResponseField name="error" type="Error | null">
      The error that occurred during the Telegram authentication flow.
    </ResponseField>

    ## Callbacks

    You can optionally pass callbacks into the `useLoginWithTelegram` hook to run custom logic after a successful login or to handle errors that occur during the flow.

    ### `onComplete`

    ```tsx
    onComplete?: ((params: {
        user: User;
        isNewUser: boolean;
        wasAlreadyAuthenticated: boolean;
        loginMethod: LoginMethod | null;
        loginAccount: LinkedAccountWithMetadata | null;
    }) => void) | undefined
    ```

    #### Parameters

    <ParamField path="user" type="User">
      The user object corresponding to the authenticated user.
    </ParamField>

    <ParamField path="isNewUser" type="boolean">
      Whether the user is a new user or an existing user.
    </ParamField>

    <ParamField path="wasAlreadyAuthenticated" type="boolean">
      Whether the user entered the application already authenticated.
    </ParamField>

    <ParamField path="loginMethod" type="LoginMethod | null">
      The method used by the user to login.
    </ParamField>

    <ParamField path="loginAccount" type="LinkedAccountWithMetadata | null">
      The account corresponding to the loginMethod used.
    </ParamField>

    ### `onError`

    ```tsx
    onError: (error: Error) => void
    ```

    #### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the login flow.
    </ParamField>
  </Tab>
</Tabs>


# Wallet
Source: https://docs.privy.io/authentication/user-authentication/login-methods/wallet



For users who already have wallets, Privy supports signing in with Ethereum (SIWE) or Solana (SIWS). With this flow, users who are already onchain can bring their existing wallet to your app, verify ownership of assets, and take onchain actions.

<Tabs>
  <Tab title="React">
    To have users login to your app with a wallet, use the `login` method from the `usePrivy` hook.

    <Info>
      Login with wallet is only available using Privy UIs.
    </Info>

    ```javascript
    login: ({ loginMethods?: ['wallet'], walletChainType?: 'ethereum-only' | 'solana-only' | 'ethereum-and-solana', disableSignup?: boolean }) => void;
    ```

    ### Parameters

    <ParamField path="loginMethods" type="string[]">
      The login methods to enable.
    </ParamField>

    <ParamField path="walletChainType" type="'ethereum-only' | 'solana-only' | 'ethereum-and-solana'">
      The chain type of the wallet to login with.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Whether to disable signup for the login method.
    </ParamField>

    ### Returns

    <ResponseField name="void" type="void">
      This method does not return anything.
    </ResponseField>

    ### Usage

    ```tsx
    import { useLogin, usePrivy } from '@privy-io/react-auth';

    function LoginButton() {
        const { ready, authenticated } = usePrivy();
        const { login } = useLogin();
        // Disable login when Privy is not ready or the user is already authenticated
        const disableLogin = !ready || (ready && authenticated);

        return (
            <button
                disabled={disableLogin}
                onClick={() => login({
                    loginMethods: ['wallet'],
                    walletChainType: 'ethereum-and-solana',
                    disableSignup: false
                })}
            >
                Log in
            </button>
        );
    }
    ```

    ### Sign in with Ledger on Solana

    Currently, Ledger Solana hardware wallets only support transaction signatures, not the message signatures required
    for Sign-In With Solana (SIWS) authentication. In order to authenticate with a Solana Ledger wallet,
    you will need to mount the following hook in your application:

    ```tsx
    import {useSolanaLedgerPlugin} from '@privy-io/react-auth/solana';
    ...
    // Ensure this is mounted throughout the entire sign in flow
    useSolanaLedgerPlugin();
    ```

    Then, when you attempt to login with a Phantom Solana wallet, you will be prompted to indicate whether you are signing with a Ledger wallet,
    which will initiate a separate SIWS flow wherein which a no-op transaction will be signed and used for verification.
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Ethereum (SIWE)">
        To authenticate a user via an Ethereum wallet *([SIWE](https://eips.ethereum.org/EIPS/eip-4361))*, use the React Native SDK's `useLoginWithSiwe` hook.

        <Info>
          In order to use Privy's login with wallet flow, users must actively have an ethereum wallet connected to your app from which you can request signatures.
        </Info>

        ## Generate SIWE message

        ```tsx
        generateSiweMessage({wallet: {chainId: string, address: string}, from: {domain: string, uri: string}}) => Promise<string>
        ```

        ### Parameters

        <ParamField path="wallet" type="Object">
          Wallet object containing EIP-55 compliant wallet address and chainId in CAIP-2 format.

          <Expandable defaultOpen="true">
            <ParamField path="chainId" type="string" required>
              The chain ID of the wallet.
            </ParamField>

            <ParamField path="address" type="string" required>
              The address of the wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="from" type="Object">
          Origin object containing domain and uri.

          <Expandable defaultOpen="true">
            <ParamField path="domain" type="string" required>
              The domain of the origin.
            </ParamField>

            <ParamField path="uri" type="string" required>
              The uri of the origin.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="message" type="string">
          A SIWE message that can be signed by the wallet.
        </ResponseField>

        ### Usage

        ```tsx
        import {useLoginWithSiwe} from '@privy-io/expo';

        export function LoginScreen() {
        const [address, setAddress] = useState('');
        const [message, setMessage] = useState('');
        const {generateSiweMessage} = useLoginWithSiwe();

        const handleGenerate = async () => {
            const message = await generateSiweMessage({
            from: {
                domain: 'my-domain.com',
                uri: 'https://my-domain.com',
            },
            wallet: {
                // sepolia chainId with CAIP-2 prefix
                chainId: `eip155:11155111`,
                address,
            },
            });

            setMessage(message);
        };

        return (
            <View>
            <TextInput
                value={address}
                onChangeText={setAddress}
                placeholder="0x..."
                inputMode="ascii-capable"
            />

            <Button onPress={handleGenerate}>Generate Message</Button>

            {Boolean(message) && <Text>{message}</Text>}
            </View>
        );
        }
        ```

        ## Sign the [SIWE message](https://eips.ethereum.org/EIPS/eip-4361)

        Then, request an [ EIP-191 ](https://eips.ethereum.org/EIPS/eip-191) `personal_sign` signature for the `message` returned by `generateSiweMessage`, from a connected wallet.

        <Tip>
          There are many ways to connect a wallet to a mobile app, a few good options are:

          * [Mobile Wallet Protocol](https://mobilewalletprotocol.github.io/wallet-mobile-sdk/)
          * [Metamask React Native SDK](https://docs.metamask.io/wallet/how-to/use-sdk/javascript/react-native/)
          * [WalletConnectClient SDK](https://github.com/WalletConnect/react-native-examples)
        </Tip>

        ## Login with SIWE

        ```tsx
        loginWithSiwe({signature: string, messageOverride?: string, disableSignup?: boolean}) => Promise<Result<PrivyUser>>
        ```

        ### Parameters

        <ParamField path="signature" type="string" required>
          The signature of the SIWE message, signed by the user's wallet.
        </ParamField>

        <ParamField path="messageOverride" type="string">
          An optional override for the message that is signed.
        </ParamField>

        <ParamField path="disableSignup" type="boolean">
          If true, the user will not be automatically created if they do not exist in the Privy database.
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="PrivyUser">
          A PrivyUser object containing the user's information.
        </ResponseField>

        ## Usage

        ```tsx
        import {useLoginWithSiwe, usePrivy} from '@privy-io/expo';

        export function LoginScreen() {
        const [signature, setSignature] = useState('');

        const {user} = usePrivy();
        const {loginWithSiwe} = useLoginWithSiwe();

        if (user) {
            return (
            <>
                <Text>Logged In</Text>
                <Text>{JSON.stringify(user, null, 2)}</Text>
            </>
            );
        }

        return (
            <View>
            <TextInput
                value={signature}
                onChangeText={setSignature}
                placeholder="0x..."
                inputMode="ascii-capable"
            />

            <Button onPress={() => loginWithSiwe({signature})}>Login</Button>
            </View>
        );
        }
        ```

        ## Callbacks

        You can optionally pass callbacks into the `useLoginWithSiwe` hook to run custom logic after a message has been generated, after a successful login, or to handle errors that occur during the flow.

        ### `onGenerateMessage`

        ```tsx
        onGenerateMessage?: ((message: string) => void) | undefined
        ```

        #### Parameters

        <ParamField path="message" type="string">
          The SIWE message that was generated.
        </ParamField>

        ### `onSuccess`

        ```tsx
        onSuccess?: ((user: PrivyUser, isNewUser: boolean) => void) | undefined
        ```

        #### Parameters

        <ParamField path="user" type="PrivyUser">
          The user object corresponding to the authenticated user.
        </ParamField>

        <ParamField path="isNewUser" type="boolean">
          Whether the user is a new user or an existing user.
        </ParamField>

        ### `onError`

        ```tsx
        onError?: (error: Error) => void
        ```

        #### Parameters

        <ParamField path="error" type="Error">
          The error that occurred during the login flow.
        </ParamField>

        ## Usage

        ```tsx
        import {useLoginWithSiwe} from '@privy-io/expo';

        export function LoginScreen() {
          const {generateSiweMessage, loginWithSiwe} = useLoginWithSiwe({
            onGenerateMessage(message) {
              // show a toast, send analytics event, etc...
            },
            onSuccess(user, isNewUser) {
              // show a toast, send analytics event, etc...
            },
            onError(error) {
              // show a toast, update form errors, etc...
            },
          });

          // ...
        }
        ```

        ## Tracking login flow state

        The `state` variable returned from `useLoginWithSiwe` will **always be one** of the following values.

        ```tsx
        type SiweFlowState =
          | { status: "initial" }
          | { status: "error"; error: Error | null }
          | { status: "generating-message" }
          | { status: "awaiting-signature" }
          | { status: "submitting-signature" }
          | { status: "done" };
        ```
      </Tab>

      <Tab title="Solana (SIWS)">
        To authenticate a user via a Solana wallet *([SIWS](https://github.com/phantom/sign-in-with-solana))*, use the React Native SDK's `useLoginWithSiws` hook.

        <Info>
          In order to use Privy's login with wallet flow, users must actively have a Solana wallet connected to your app from which you can request signatures.
        </Info>

        ## Generate SIWS message

        ```tsx
        generateMessage({wallet: {address: string}, from: {domain: string, uri: string}}) => Promise<{message: string}>
        ```

        ### Parameters

        <ParamField path="wallet" type="Object">
          Wallet object containing Solana wallet address.

          <Expandable defaultOpen="true">
            <ParamField path="address" type="string" required>
              The address of the wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="from" type="Object">
          Origin object containing domain and uri.

          <Expandable defaultOpen="true">
            <ParamField path="domain" type="string" required>
              The domain of the origin.
            </ParamField>

            <ParamField path="uri" type="string" required>
              The uri of the origin.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="message" type="string">
          A SIWS message that can be signed by the wallet.
        </ResponseField>

        ### Usage

        ```tsx
        import {useLoginWithSiws} from '@privy-io/expo';

        export function LoginScreen() {
          const [address, setAddress] = useState('');
          const [message, setMessage] = useState('');
          const {generateMessage} = useLoginWithSiws();

          const handleGenerate = async () => {
            const {message} = await generateMessage({
              from: {
                domain: 'my-domain.com',
                uri: 'https://my-domain.com',
              },
              wallet: {
                address,
              },
            });

            setMessage(message);
          };

          return (
            <View>
              <TextInput
                value={address}
                onChangeText={setAddress}
                placeholder="0x..."
                inputMode="ascii-capable"
              />

              <Button onPress={handleGenerate}>Generate Message</Button>

              {Boolean(message) && <Text>{message}</Text>}
            </View>
          );
        }
        ```

        ## Sign the SIWS message

        Then, request a signature for the `message` returned by `generateMessage`, from a connected wallet.

        ## Login with SIWS

        ```tsx
        login({signature: string, message: string, wallet: {walletClientType: string, connectorType: string}, disableSignup?: boolean}) => Promise<Result<PrivyUser>>
        ```

        ### Parameters

        <ParamField path="signature" type="string" required>
          The signature of the SIWS message, signed by the user's wallet.
        </ParamField>

        <ParamField path="message" type="string" required>
          The original message that was signed.
        </ParamField>

        <ParamField path="wallet" type="Object" required>
          <Expandable defaultOpen="true">
            <ParamField path="walletClientType" type="string" required>
              The client of the connected wallet (e.g. 'phantom').
            </ParamField>

            <ParamField path="connectorType" type="string" required>
              The type of the connector (e.g. 'wallet\_connect' or 'mobile\_wallet\_protocol').
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField path="disableSignup" type="boolean">
          If true, the user will not be automatically created if they do not exist in the Privy database.
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="PrivyUser">
          A PrivyUser object containing the user's information.
        </ResponseField>

        ## Usage

        ```tsx
        import {useLoginWithSiws, usePrivy} from '@privy-io/expo';

        export function LoginScreen() {
          const [signature, setSignature] = useState('');

          const {user} = usePrivy();
          const {login} = useLoginWithSiws();

          if (user) {
            return (
              <>
                <Text>Logged In</Text>
                <Text>{JSON.stringify(user, null, 2)}</Text>
              </>
            );
          }

          return (
            <View>
              <TextInput
                value={signature}
                onChangeText={setSignature}
                placeholder="0x..."
                inputMode="ascii-capable"
              />

              <Button
                onPress={() =>
                  login({
                    signature,
                    message,
                    wallet: {
                      walletClientType,
                      connectorType,
                    },
                  })
                }
              >
                Login
              </Button>
            </View>
          );
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Ethereum (SIWE)">
        To authenticate a user via an Ethereum wallet *([SIWE](https://eips.ethereum.org/EIPS/eip-4361))*, use the Privy client's `siwe` handler.

        ## Generate SIWE message

        ```swift
        func generateSiweMessage(params: SiweMessageParams) async throws -> String
        ```

        ### Parameters

        <ParamField path="params" type="SiweMessageParams">
          Set of parameters required to generate the message.

          <Expandable defaultOpen="true">
            <ParamField path="appDomain" type="String" required>
              Your app's domain. e.g. "my-domain.com"
            </ParamField>

            <ParamField path="appUri" type="String" required>
              Your app's URI. e.g. "[https://my-domain.com](https://my-domain.com)"
            </ParamField>

            <ParamField path="chainId" type="String" required>
              EVM Chain ID, e.g. "1" for Ethereum Mainnet
            </ParamField>

            <ParamField path="walletAddress" type="String" required>
              The user's [ERC-55](https://eips.ethereum.org/EIPS/eip-55) compliant wallet address.
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="String" type="String">
          A SIWE message that can be signed by the wallet.
        </ResponseField>

        ### Usage

        ```swift
        do {
            let params = SiweMessageParams(
                appDomain: "my-domain.com",
                appUri: "https://my-domain.com",
                chainId: "1",
                walletAddress: "0x12345..."
            )

            let siweMessage = try await privy.siwe.generateSiweMessage(params: params)
        } catch {
            // An error can be thrown if the network call to generate the message fails,
            // or if invalid metadata was passed in.
        }
        ```

        ## Sign the SIWE message

        Using the message returned by `generateSiweMessage`, request an EIP-191 `personal_sign` signature from the user's connected wallet. You should do this using the library your app uses to connect to external wallets (e.g. the MetaMask iOS SDK or WalletConnect).
        Once the user successfully signs the message, store the signature in a variable.

        ## Login with SIWE

        ```swift
        func loginWithSiwe(
            message: String,
            signature: String,
            params: SiweMessageParams,
            metadata: WalletLoginMetadata?
        ) async throws -> PrivyUser
        ```

        ### Parameters

        <ParamField path="message" type="String" required>
          The message returned from "generateSiweMessage".
        </ParamField>

        <ParamField path="signature" type="String" required>
          The signature of the SIWE message, signed by the user's wallet.
        </ParamField>

        <ParamField path="signature" type="String" required>
          The same SiweMessageParams passed into "generateSiweMessage".
        </ParamField>

        <ParamField path="metadata" type="WalletLoginMetadata">
          (Optional) you can pass additional metadata that will be stored with the linked wallet.

          <Expandable defaultOpen="true">
            <ParamField path="walletClientType" type="WalletClientType">
              An enum specifying the type of wallet used to login. e.g. WalletClientType.metamask
            </ParamField>

            <ParamField path="connectorType" type="String">
              A string identifying how wallet was connected. e.g. "wallet\_connect"
            </ParamField>
          </Expandable>
        </ParamField>

        ### Returns

        <ResponseField name="PrivyUser" type="PrivyUser">
          The authenticated Privy user
        </ResponseField>

        ### Throws

        An error if logging the user in is unsuccessful.

        ## Usage

        ```swift
        do {
            let params = SiweMessageParams(
                appDomain: "my-domain.com",
                appUri: "https://my-domain.com",
                chainId: "1",
                walletAddress: "0x12345..."
            )

            // Generate SIWE message
            let siweMessage = try await privy.siwe.generateSiweMessage(params: siweParams)

            // Optional metadata
            let metadata = WalletLoginMetadata(
                walletClientType: WalletClientType.metamask,
                connectorType: "wallet_connect"
            )

            // Login
            try await privy.siwe.loginWithSiwe(
              message: siweMessage,
              // the signature generated by the user's wallet
              signature: signature,
              params: siweParams,
              metadata: metadata
            )
        } catch {
            // error logging user in
        }
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Logging users out
Source: https://docs.privy.io/authentication/user-authentication/logout



Logging out a user ends their authenticated session, removing their access credentials from the device and requiring them to authenticate again to access protected resources.

<Tabs>
  <Tab title="React">
    ```tsx
    logout: () => Promise<void>
    ```

    ### Usage

    To log a user out, use the `logout` method from the `usePrivy` hook:

    ```tsx
    import { usePrivy } from '@privy-io/react-auth';

    function LogoutButton() {
      const { ready, authenticated, logout } = usePrivy();

      // Disable logout when Privy is not ready or the user is not authenticated
      const disableLogout = !ready || (ready && !authenticated);

      return (
        <button disabled={disableLogout} onClick={logout}>
          Log out
        </button>
      );
    }
    ```

    ### Callbacks

    You can attach callbacks to the logout process using the `useLogout` hook:

    ```tsx
    import { useLogout } from '@privy-io/react-auth';

    function LogoutButton() {
      const { logout } = useLogout({
        onSuccess: () => {
          console.log('User successfully logged out');
          // Redirect to landing page or perform other post-logout actions
        },
        onError: (error) => {
          console.error('Logout failed', error);
        }
      });

      return <button onClick={logout}>Log out</button>;
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```tsx
    logout: () => Promise<void>
    ```

    ### Usage

    To log a user out, use the `logout` method from the `usePrivy` hook:

    ```tsx
    import { usePrivy } from '@privy-io/expo';

    function LogoutButton() {
      const { logout } = usePrivy();

      return <Button onPress={() => logout()}>Log out</Button>;
    }
    ```

    ### Async Handling

    Since `logout` returns a Promise, you can await it to run code after the user has been logged out:

    ```tsx
    import { usePrivy } from '@privy-io/expo';

    function LogoutButton() {
      const { logout } = usePrivy();

      const handleLogout = async () => {
        await logout();
        // Perform actions after logout completes
        console.log('User logged out successfully');
      };

      return <Button onPress={handleLogout}>Log out</Button>;
    }
    ```
  </Tab>

  <Tab title="Swift">
    ```swift
    func logout()
    ```

    ### Usage

    To log out an authenticated user, call the `logout` method on the user object:

    ```swift
    privy.user.logout()
    ```

    ### Example

    ```swift
    import PrivySDK

    class ProfileViewController: UIViewController {
      @IBAction func logoutButtonTapped(_ sender: UIButton) {
        // Check if user is authenticated
        if let user = privy.user {
          user.logout()
          // Navigate back to login screen
          self.navigationController?.popToRootViewController(animated: true)
        }
      }
    }
    ```

    ### Effect

    This will clear the user state and delete the persisted user session.
  </Tab>

  <Tab title="Android">
    ```kotlin
    suspend fun logout()
    ```

    ### Usage

    To log out an authenticated user, call the `logout` method:

    ```kotlin
    coroutineScope.launch {
      privy.logout()
    }
    ```

    ### Example

    ```kotlin
    import io.privy.android.Privy
    import kotlinx.coroutines.launch
    import kotlinx.coroutines.CoroutineScope
    import kotlinx.coroutines.Dispatchers

    class ProfileActivity : AppCompatActivity() {
      private val coroutineScope = CoroutineScope(Dispatchers.Main)

      private fun setupLogoutButton() {
        logoutButton.setOnClickListener {
          coroutineScope.launch {
            privy.logout()
            // Navigate back to login activity
            startActivity(Intent(this@ProfileActivity, LoginActivity::class.java))
            finish()
          }
        }
      }
    }
    ```

    ### Effect

    This will clear the user state and delete the persisted user session.
  </Tab>

  <Tab title="Flutter">
    ```dart
    Future<void> logout()
    ```

    ### Usage

    To log out an authenticated user, call the `logout` method:

    ```dart
    await privy.logout();
    ```

    ### Example

    ```dart
    import 'package:flutter/material.dart';
    import 'package:privy_flutter/privy_flutter.dart';

    class ProfileScreen extends StatelessWidget {
      final Privy privy;

      const ProfileScreen({Key? key, required this.privy}) : super(key: key);

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Profile')),
          body: Center(
            child: ElevatedButton(
              onPressed: () async {
                await privy.logout();
                // Navigate back to login screen
                Navigator.of(context).pushReplacementNamed('/login');
              },
              child: Text('Log out'),
            ),
          ),
        );
      }
    }
    ```

    ### Effect

    This will clear the user state and delete the persisted user session.
  </Tab>
</Tabs>


# Using custom UIs
Source: https://docs.privy.io/authentication/user-authentication/mfa/custom-ui



<Tip>
  **By default, Privy's wallet MFA feature will use Privy's UIs** for enrolling users in MFA, managing MFA methods, and having users complete MFA to authorize signatures and transactions for the embedded wallet.

  This section is intended only for apps that would like to use wallet MFA with their own custom UIs, instead of Privy's defaults.
</Tip>

<Warning>
  Implementing wallet MFA with custom UIs is *substantially* more involved than integrating Privy's
  out-of-the-box wallet MFA feature. Make sure to consider the development trade-offs of using
  custom UIs over Privy defaults before finalizing on your approach!
</Warning>

<Tabs>
  <Tab title="React">
    ### Configuring MFA to be used with custom UIs

    If you plan to use your own custom UIs for wallet MFA, **set the `mfa.noPromptOnMfaRequired` field to true in the Privy provider**.

    ```tsx
    function MyApp({Component, pageProps}: AppProps) {
      return (
        <>
          <PrivyProvider
            appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
            config={{
              mfa: {
                // Defaults to 'false'
                noPromptOnMfaRequired: true,
              },
              ...insertTheRestOfYourConfig,
            }}
          >
            <Component {...pageProps} />
          </PrivyProvider>
        </>
      );
    }
    ```

    This will configure Privy to not show its default UIs for wallet MFA, and instead rely on your custom implementation.

    ### Enrolling in MFA

    To enroll your users in MFA, use the  hook from Privy. Currently, users can enroll in three MFA methods:

    * **SMS**, where users authenticate with a 6-digit MFA code sent to their phone number
    * **TOTP**, where users authenticate with a 6-digit MFA code from an authentication app, like Authy or Google Authenticator
    * **Passkey**, where users verify with a previously registered passkey, generally through biometric authentication on their device

    #### SMS

    To enroll your users in MFA with SMS, use the  and  methods returned by the  hook:

    ```tsx
    const {initEnrollmentWithSms, submitEnrollmentWithSms} = useMfaEnrollment();
    ```

    First, initiate enrollment by prompting your user to enter the phone number they'd like to use for MFA. Then, call Privy's  method. As a parameter to this , pass a JSON object with a  field that contains the user's provide phone number as a string.

    ```tsx
    // Prompt the user for their phone number
    const phoneNumberInput = 'insert-phone-number-from-user';
    // Send an enrollment code to their phone number
    await initEnrollmentWithSms({phoneNumber: phoneNumberInput});
    ```

    Once  is called with a valid , Privy will then send a 6-digit MFA enrollment code to the provided number. This method returns a `Promise` that will resolve to `void` if the code was successfully sent, or will reject with an `error` if there was an error sending the code (e.g. invalid phone number).

    Next, prompt the user to enter the 6-digit code that was sent to their phone number, and use the  method to complete enrollment of that phone number. As a parameter to , you must pass a JSON object with both the original  that the user enrolled, and the  they received at that number.

    ```tsx
    // Prompt the user for the code sent to their phone number
    const mfaCodeInput = 'insert-mfa-code-received-by-user';
    await submitEnrollmentWithSms({
      phoneNumber: phoneNumberInput, // From above
      mfaCode: mfaCodeInput,
    });
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with SMS">
      The component below serves as a reference implementation for how to enroll your users in MFA with SMS!

      ```tsx Example enrolling a phone number for MFA
      import {useMfaEnrollment} from '@privy-io/react-auth';

      export default function MfaEnrollmentWithSms() {
        const {initEnrollmentWithSms, submitEnrollmentWithSms} = useMfaEnrollment();

        const [phoneNumber, setPhoneNumber] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);
        const [pendingMfaCode, setPendingMfaCode] = useState<boolean>(false);

        // Handler for when the user enters their phone number to enroll in MFA.
        const onEnteredPhoneNumber = () => {
          await initEnrollmentWithSms({phoneNumber: phoneNumber}); // Sends an MFA code to the `phoneNumber`
          setPendingMfaCode(true);
        }

        // Handler for when the user enters the MFA code sent to their phone number.
        const onEnteredMfaCode = () => {
          await submitEnrollmentWithSms({phoneNumber: phoneNumber, mfaCode: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithSms`
          setPendingMfaCode(false);
        }

        // If no MFA code has been sent yet, prompt the user for their phone number to enroll
        if (!pendingMfaCode) {
          // Input field for the user to enter the phone number they'd like to enroll for MFA
          return <>
            <input placeholder='(555) 555 5555' onChange={(event) => setPhoneNumber(event.target.value)}/>
            <button onClick={onEnteredPhoneNumber}>Enroll a Phone with MFA</button>
          </>;
        }

        // Input field for the user to enter the MFA code sent to their phone number
        return <>
          <input placeholder='123456' onChange={(event) => setMfaCode(event.target.value)}/>
          <button onClick={onEnteredMfaCode}>Submit Enrollment Code</button>
        </>;
      }
      ```
    </Accordion>

    <Info>
      If your app has enabled SMS as a possible *login* method, users will **not** be able to enroll SMS as a valid *MFA* method.

      SMS must be either be used as a login method to secure user accounts, or as an MFA method for additional security on the users' wallets.
    </Info>

    #### TOTP

    To enroll your users in MFA with TOTP, use the  and  methods returned by the  hook:

    ```tsx
    const {initEnrollmentWithTotp, submitEnrollmentWithTotp} = useMfaEnrollment();
    ```

    First, initiate enrollment by calling Privy's  method with no parameters. This method returns a `Promise` for an  and  that the user will need in order to complete enrollment.

    ```tsx
    const {authUrl, secret} = await initEnrollmentWithTotp();
    ```

    Then, to have the user enroll, you can either:

    * display the TOTP  as a QR code to the user, and prompt them to scan it with their TOTP client (commonly, a mobile app like Google Authenticator or Authy)
    * allow the user to copy the TOTP  and paste it into their TOTP client

    <Tip>
      You can directly pass in the  from above into a library like  to render the URL as a QR code to your user.
    </Tip>

    Once your user has successfully scanned the QR code, an enrollment code for Privy will appear within their TOTP client. Prompt the user to enter this code in your app, and call Privy's  method. As a parameter to , pass a JSON object with an  field that contains the MFA code from the user as a string.

    ```tsx
    const mfaCodeInput = 'insert-mfa-code-from-user-totp-app'; // Prompt the user for the code in their TOTP app
    await submitEnrollmentWithTotp({mfaCode: mfaCodeInput});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with TOTP">
      The component below serves as a reference implementation for how to enroll your users in MFA with TOTP!

      ```tsx Example enrolling a TOTP client for MFA
      import {useMfaEnrollment} from '@privy-io/react-auth';
      import QRCode from 'react-qr-code';
      import {CopyableElement} from '../components/CopyableElement';

      export default function MfaEnrollmentWithTotp() {
        const {initEnrollmentWithTotp, submitEnrollmentWithTotp} = useMfaEnrollment();
        const [totpAuthUrl, setTotpAuthUrl] = useState<string | null>(null);
        const [totpSecret, setTotpSecret] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);

        // Handler for when the user is ready to enroll in TOTP MFA
        const onGenerateTotpUrl = async () => {
          const {authUrl, secret} = await initEnrollmentWithTotp();
          setTotpAuthUrl(authUrl);
          setTotpSecret(secret);
        }

        // Handler for when the user enters the MFA code from their TOTP client
        const onEnteredMfaCode = async () => {
          await submitEnrollmentWithTotp({mfaCode: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithTotp`
        }

        return(
          <div>
            {/* QR code for the user to scan */}
            {totpAuthUrl && totpSecret ?
              {/* If TOTP values have been generated... */}
              <>
                {/* ...show the user a QR code with the `authUrl` that they can scan...  */}
                <QRCode value={totpAuthUrl} />
                {/* ...or give them the option to copy the `secret` into their TOTP client  */}
                <CopyableElement value={totpSecret} />
              </> :
              {/* Else, show a button to generate the totpAuthUrl */}
              <button onClick={() => onGenerateTotpUrl()}>Show QR Code</button>
            }
            {/* Input field for the user to enter their MFA code */}
            <p>Enter the code from your authenticator app below.</p>
            <input placeholder='123456' onChange={(event) => setMfaCode(event.target.value)}/>
            <button onClick={() => submitEnrollmentWithTotp({mfaCode: mfaCode})}>Submit Enrollment Code</button>
          </div>
        );
      }
      ```
    </Accordion>

    #### Passkey

    <Tip>
      In order to use passkeys as a MFA method, make sure a valid passkey is linked to the user. You can set this up by following the steps [here](user-management/users/linking-accounts)!
    </Tip>

    To enroll your users in MFA with passkeys, use the  and  methods returned by the  hook:

    ```tsx
    const {initEnrollmentWithPasskey, submitEnrollmentWithPasskey} = useMfaEnrollment();
    ```

    First, initiate enrollment by calling Privy's  method with no parameters. This method returns a `Promise` that will resolve to `void` indicating success.

    ```tsx
    await initEnrollmentWithPasskey();
    ```

    Then, to have the user enroll, you must call Privy's `submitEnrollmentWithPasskey` method with a list of the user's passkey account `credentialIds`. You can find this list by querying the `user`'s `linkedAccounts` array for all accounts of `type: 'passkey'`:

    ```tsx
    const {user} = usePrivy();

    // ...

    const credentialIds = user.linkedAccounts
      .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
      .map((x) => x.credentialId);

    await submitEnrollmentWithPasskey({credentialIds});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with passkeys">
      The component below serves as a reference implementation for how to enroll your users in MFA with passkeys!

      ```tsx Example enrolling passkeys for MFA
      import {useMfaEnrollment} from '@privy-io/react-auth';

      export default function MfaEnrollmentWithPasskey() {
        const {user} = usePrivy();
        const {initEnrollmentWithPasskey, submitEnrollmentWithPasskey} = useMfaEnrollment();

        const handleEnrollmentWithPasskey = async () => {
          await initEnrollmentWithPasskey();

          const credentialIds = user.linkedAccounts
            .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
            .map((x) => x.credentialId);

          await submitEnrollmentWithPasskey({credentialIds});
        };

        return (
          <div>
            <div>Enable your passkeys for MFA</div>
            {user.linkedAccounts
              .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
              .map((account) => (
                <div key={account.id}>{account.credentialId}</div>
              ))}
            <button onClick={handleEnrollmentWithPasskey}>Enroll</button>
          </div>
        );
      }
      ```
    </Accordion>

    ### Completing MFA

    Once users have successfully enrolled in MFA with Privy, they will be required to complete MFA whenever the private key for their embedded wallet must be used. This includes signing messages and transactions, recovering the embedded wallet on new devices, exporting the wallet's private key, and setting a password on the wallet.

    **To ensure users can complete MFA when required, your app must do the following:**

    1. Set up a flow to guide the user through completing MFA when required.
    2. Register an event listener to configure Privy to invoke the flow from step (1) whenever MFA is required.

    <Tip>
      Once a user has completed MFA on a given device, they can continue to use the wallet on that device *without* needing to complete MFA for 15 minutes.

      After 15 minutes have elapsed, Privy will require that the user complete MFA again to re-authorize use of the wallet's private key.
    </Tip>

    #### Guiding the user through MFA

    To set up a flow to have the user complete MFA, use Privy's  hook.

    ```tsx
    const {init, submit, cancel} = useMfa();
    ```

    This flow has three core components:

    1. Requesting an MFA code be sent to the user's MFA method ()
    2. Submitting the MFA code provided by the user ()
    3. Cancelling an in-progress MFA flow ()

    ## Requesting an MFA challenge

    To request an MFA challenge for the current user, call the  method from the  hook, passing the user's desired MFA method (`'sms'`, `'totp'`, or `'passkey'`) as a parameter.

    ```tsx
    const selectedMfaMethod = 'sms'; // Must be 'sms', 'totp' or 'passkey'
    await init(selectedMfaMethod);
    ```

    The  method will then prepare an MFA challenge for the desired MFA method, and returns a `Promise` that resolves if the challenge was successfully created, and rejects with an error if there was an issue.

    * If the MFA method is `'sms'`, the user will receive an SMS with their MFA code at the phone number they originally enrolled.
    * If the MFA method is `'totp'`, the user will receive the MFA code within their authenticator app.
    * If the MFA method is `'passkey'`, `init` will return an object with options to pass to the native passkey system

    ## Submitting the MFA verification

    <Tabs>
      <Tab title="Submitting a user-input code (SMS/TOTP)">
        Once  has resolved successfully, prompt the user to get their MFA code from their MFA method and to enter it within your app. Then, call the  method from . As parameters to , pass the MFA method being used (`'sms'` or `'totp'`) and the MFA code that the user entered.

        ```tsx
        const mfaCode = 'insert-mfa-code-from-user';
        await submit(selectedMfaMethod, mfaCode);
        ```
      </Tab>

      <Tab title="Submitting a passkey">
        Once  has resolved successfully, prompt the user to select a passkey by calling `submit` with the options returned from the `init` method.

        ```tsx
        const options = await init('passkey');

        // Submit will trigger the system's native passkey prompt
        await submit('passkey', options);
        ```
      </Tab>
    </Tabs>

    ## Cancelling the MFA flow

    After  has been called and the corresponding  call has not yet occurred, the user may cancel their in-progress MFA flow if they wish.

    To cancel the current MFA flow, call the  method from the  hook.

    ```tsx
    cancel();
    ```

    <Accordion title="See a recommended abstraction for guiding users to complete MFA">
      To simplify the implementation, we recommend abstracting the logic above into a self-contained component that can be used whenever the user needs to complete an MFA flow.

      For instance, you might write an `MFAModal` component that allows the user to (1) select their desired method of their enrolled MFA methods, (2) request an MFA code, and (3) submit the MFA code to Privy for verification. A sample implementation is below:

      ```tsx Example modal for guiding users through the MFA flow
      import Modal from 'react-modal';

      import {
        useMfaEnrollment,
        errorIndicatesMfaVerificationFailed,
        errorIndicatesMfaMaAttempts,
        errorIndicatesMfaTimeout,
        MfaMethod,
      } from '@privy-io/react-auth';

      type Props = {
        // List of available MFA methods that the user has enrolled in
        mfaMethods: MfaMethod[];
        // Boolean indicator to determine whether or not the modal should be open
        isOpen: boolean;
        // Helper function to open/close the modal */
        setIsOpen: (isOpen: boolean) => void;
      };

      export const MFAModal = ({mfaMethods, isOpen, setIsOpen}: Props) => {
        const {init, submit, cancel} = useMfa();
        // Stores the user's selected MFA method
        const [selectedMethod, setSelectedMethod] = useState<MfaMethod | null>(null);
        // Stores the user's MFA code
        const [mfaCode, setMfaCode] = useState('');
        // Stores the options for passkey MFA
        const [options, setOptions] = useState(null);
        // Stores an error message to display
        const [error, setError] = useState('');

        // Helper function to request an MFA code for a given method
        const onMfaInit = async (method: MfaMethod) => {
          const response = await init(method);
          setError('');
          setSelectedMethod(method);
          if (method === 'passkey') {
            setOptions(response);
          }
        };

        // Helper function to submit an MFA code to Privy for verification
        const onMfaSubmit = async () => {
          try {
            if (selectedMethod === 'passkey') {
              await submit(selectedMethod, options);
            } else {
              await submit(selectedMethod, mfaCode);
            }
            setSelectedMethod(null); // Clear the MFA flow once complete
            setIsOpen(false); // Close the modal
          } catch (e) {
            // Handling possible errors with MFA code submission
            if (errorIndicatesMfaVerificationFailed(e)) {
              setError('Incorrect MFA code, please try again.');
              // Allow the user to re-enter the code and call `submit` again
            } else if (errorIndicatesMfaMaxAttempts(e)) {
              setError('Maximum MFA attempts reached, please request a new code.');
              setSelectedMethod(null); // Clear the MFA flow to allow the user to try again
            } else if (errorIndicatesMfaTimeout(e)) {
              setError('MFA code has expired, please request a new code.');
              setSelectedMethod(null); // Clear the MFA flow to allow the user to try again
            }
          }
        };

        // Helper function to clean up state when the user closes the modal
        const onModalClose = () => {
          cancel(); // Cancel any in-progress MFA flows
          setIsOpen(false);
        };

        return (
          <Modal isOpen={isOpen} onAfterClose={onModalClose}>
            {/* Button for the user to select an MFA method and request an MFA code */}
            {mfaMethods.map((method) => (
              <button onClick={() => onMfaInit(method)}>Choose to MFA with {method}</button>
            ))}
            {/* Input field for the user to enter their MFA code and submit it */}
            {selectedMethod && selectedMethod !== 'passkey' && (
              <div>
                <p>Enter your MFA code below</p>
                <input placeholder="123456" onChange={(event) => setMfaCode(event.target.value)} />
                <button onClick={() => onMfaSubmit()}>Submit Code</button>
              </div>
            )}
            {/* Display error message if there is one */}
            {!!error.length && <p>{error}</p>}
          </Modal>
        );
      };
      ```

      Notice how the modal contains all logic for requesting the MFA code, submitting the MFA code, handling errors, and cancelling an in-progress MFA code.

      Then, when your app needs to prompt a user to complete MFA, they can simply display this  component and configure the  prop with the list of MFA methods that are available for the current user.
    </Accordion>

    #### Registering an event listener

    Once you've set up your app's logic for guiding a user to complete MFA, you lastly need to configure Privy to invoke this logic whenever MFA is required by the user's embedded wallet.

    To set up this configuration, use Privy's  hook. As a parameter to , you must pass a JSON object with an  callback, described below.

    ## onMfaRequired

    Privy will invoke the  callback you set whenever the user is required to complete MFA to use the embedded wallet. When this occurs, any use of the embedded wallet will be "paused" until the user has successfully completed MFA with Privy.

    In this callback, you should invoke your app's logic for guiding through completing MFA (done via the  hook, as documented above). Within this callback, you can also access an  parameter that contains a list of available MFA methods that the user has enrolled in (`'sms'` and/or `'totp'` and/or `'passkey'`).

    <Tabs>
      <Tab title="Registering an event listener">
        ```tsx MFAProvider.tsx
        import {useRegisterMfaListener, MfaMethod} from '@privy-io/react-auth';

        import {MFAModal} from '../components/MFAModal';

        export const MFAProvider = ({children}: {children: React.ReactNode}) => {
          const [isMfaModalOpen, setIsMfaModelOpen] = useState(false);
          const [mfaMethods, setMfaMethods] = useState<MfaMethod[]>([]);

          useRegisterMfaListener({
            // Privy will invoke this whenever the user is required to complete MFA
            onMfaRequired: (methods) => {
              // Update app's state with the list of available MFA methods for the user
              setMfaMethods(methods);
              // Open MFA modal to allow user to complete MFA
              setIsMfaModalOpen(true);
            },
          });

          return (
            <div>
              {/* This `MFAModal` component includes all logic for completing the MFA flow with Privy's `useMfa` hook */}
              <MFAModal isOpen={isMfaModalOpen} setIsOpen={setIsMfaModalOpen} mfaMethods={mfaMethods} />
              {children}
            </div>
          );
        };
        ```
      </Tab>
    </Tabs>

    <Info>
      In order for Privy to invoke your app's MFA flow, the component that calls Privy's  hook **must be mounted** whenever the user's embedded wallet requires that they complete MFA.

      In kind, we recommend that you render this component near the root of your application, so that it is always rendered whenever the embedded wallet may be used.
    </Info>

    ### Handling errors with code submission

    When both enrolling in and completing MFA, Privy sends a 6-digit code to the user's selected MFA method, that the user must submit to Privy in order to verify their identity.

    When submitting this MFA code, Privy may respond with an error if the code is incorrect, if the user has reached the maximum number of attempts for this MFA flow, or if the MFA flow has timed out. If the user enters in an incorrect code (e.g. by mistyping), the user is allowed to retry code submission up to a **maximum of four attempts.**

    **To simplify handling errors with MFA code submission, Privy provides the following helper functions to parse errors raised by the MFA code submission methods listed above.** Each of these functions accepts the raw  raised as a parameter, and returns a `Boolean` indicating if the error meets a certain condition:

    * : indicates the user entered an incorrect MFA code
    * indicates has reached the maximum number of attempts for this MFA flow, and that a new MFA code must be requested via
    * indicates that the current MFA code has expired, and that a new MFA code must be requested via

    As an example, to handle errors raised by , you might use these helpers like so:

    ```tsx Handling errors during MFA code submission
    try {
      // Errors from `submitEnrollmentWithSms` and `submitEnrollmentWithTotp` can be handled similarly
      await submit('insert-mfa-code', 'insert-mfa-method');
    } catch (e) {
      if (errorIndicatesMfaVerificationFailed(e)) {
        console.error('Incorrect MFA code, please try again.');
        // Allow the user to re-enter the code and call `submit` again
      } else if (errorIndicatesMfaMaxAttempts(e)) {
        console.error('Maximum MFA attempts reached, please request a new code.');
        // Allow the user to request a new code with `init`
      } else if (errorIndicatesMfaTimeout(e)) {
        console.error('MFA code has expired, please request a new code.');
        // Allow the user to request a new code with `init`
      }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ### Enrollment flows with custom UIs in Expo

    To enroll your users in MFA, use the  and  methods returned by the  hook:

    ```tsx
    const {initMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();
    ```

    Currently, users can enroll in three MFA methods:

    * , where users authenticate with a 6-digit MFA code sent to their phone number
    * , where users authenticate with a 6-digit MFA code from an authentication app, like Authy or Google Authenticator
    * , where users verify with a previously registered passkey, generally through biometric authentication on their device

    #### SMS

    First, initiate enrollment by prompting your user to enter the phone number they'd like to use for MFA. Then, call Privy's  method with the appropriate parameters:

    ```tsx
    // Prompt the user for their phone number
    const phoneNumberInput = 'insert-phone-number-from-user';
    // Send an enrollment code to their phone number
    await initMfaEnrollment({method: 'sms', phoneNumber: phoneNumberInput});
    ```

    Once  is called with a valid , Privy will then send a 6-digit MFA enrollment code to the provided number.

    Next, prompt the user to enter the 6-digit code that was sent to their phone number, and use the  method to complete enrollment:

    ```tsx
    // Prompt the user for the code sent to their phone number
    const mfaCodeInput = 'insert-mfa-code-received-by-user';
    await submitMfaEnrollment({
      method: 'sms',
      phoneNumber: phoneNumberInput, // From above
      code: mfaCodeInput,
    });
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with SMS">
      The component below serves as a reference implementation for how to enroll your users in MFA with SMS!

      ```tsx Example enrolling a phone number for MFA
      import {useMfaEnrollment} from '@privy-io/expo';

      export default function MfaEnrollmentWithSms() {
        const {initMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();

        const [phoneNumber, setPhoneNumber] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);
        const [pendingMfaCode, setPendingMfaCode] = useState<boolean>(false);

        // Handler for when the user enters their phone number to enroll in MFA.
        const onEnteredPhoneNumber = () => {
          await initMfaEnrollmen({method: 'sms', phoneNumber: phoneNumber}); // Sends an MFA code to the `phoneNumber`
          setPendingMfaCode(true);
        }

        // Handler for when the user enters the MFA code sent to their phone number.
        const onEnteredMfaCode = () => {
          await submitMfaEnrollment({ method: 'sms', phoneNumber: phoneNumber, code: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithSms`
          setPendingMfaCode(false);
        }

        // If no MFA code has been sent yet, prompt the user for their phone number to enroll
        if (!pendingMfaCode) {
          // Input field for the user to enter the phone number they'd like to enroll for MFA
          return (
            <YStack gap={12}>
              <Input value={mfaCode}
                onChangeText={setPhoneNumber}
                flex={1}
                keyboardType="number-pad"
              />
              <Button onPress={onEnteredPhoneNumber} flex={1}>
                <Text>Enroll a Phone with MFA</Text>
              </Button>
            </YStack>
          )
        }

        // Input field for the user to enter the MFA code sent to their phone number
        return
        <>
          <Input value={mfaCode} onChangeText={setMfaCode}/>
          <Button onPress={onEnteredMfaCode}><Text>Submit Enrollment Code</Text></Button>
        </>;
      }
      ```
    </Accordion>

    <Info>
      If your app has enabled SMS as a possible *login* method, users will **not** be able to enroll SMS as a valid *MFA* method.

      SMS can be either be used as a login method to secure user accounts, or as an MFA method for additional security on the users' wallets, but cannot be used for both.
    </Info>

    #### TOTP

    First, initiate enrollment by calling Privy's  method with a JSON parameter of :

    ```tsx
    const {authUrl} = await initMfaEnrollment({method: 'totp'});
    ```

    Then, to have the user enroll, you can display the TOTP  as a QR code to the user, and prompt them to scan it with their TOTP client.

    <Tip>
      You can directly pass in the  from above into a library like  to deep link into a TOTP application for MFA.
    </Tip>

    Once your user has successfully linked into their TOTP application, prompt the user to enter the code in your app, and call Privy's  method:

    ```tsx
    const mfaCodeInput = 'insert-mfa-code-from-user-totp-app'; // Prompt the user for the code in their TOTP app
    await submitMfaEnrollment({method: 'totp', mfaCode: mfaCodeInput});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with TOTP">
      The component below serves as a reference implementation for how to enroll your users in MFA with TOTP!

      ```tsx Example enrolling a TOTP client for MFA
      import {useMfaEnrollment} from '@privy-io/expo';

      export default function MfaEnrollmentWithTotp() {
        const {initMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();
        const [totpAuthUrl, setTotpAuthUrl] = useState<string | null>(null);
        const [mfaCode, setMfaCode] = useState<string | null>(null);

        // Handler for when the user is ready to enroll in TOTP MFA
        const onGenerateTotpUrl = async () => {
          const {authUrl} = await initMfaEnrollment({method: 'totp'});
          setTotpAuthUrl(authUrl);
        }

        // Handler for when the user enters the MFA code from their TOTP client
        const onMfaEnrollmentSubmit = async () => {
          await submitMfaEnrollment({method: 'totp', code: mfaCode});
          // See the "Handling errors with code submission" section of this guide
          // for details on how to handle errors raised by `submitEnrollmentWithTotp`
        }

        return(
            {/* QR code for the user to scan */}
            <YStack gap={12}>
                    <Text>TOTP MFA Enrollment</Text>
                    {
                      // Check to see if the totpUrl is generated
                      !!totpUrl && <Text onPress={() => Linking.openURL(totpUrl)} >{totpUrl}</Text>
                      <XStack gap={12}>
                        <Input
                          value={totpCode}
                          onChangeText={setTotpCode}
                          flex={1}
                          keyboardType="number-pad"
                        />
                        {// Once the TOTP code is received in the authenticator app and input above, submit for enrollment}
                        <Button onPress={onMfaEnrollmentSubmit} flex={1}>
                          <Text>Verify OTP</Text>
                        </Button>
                      </XStack>
                    }
                  </YStack>
        );
      }
      ```
    </Accordion>

    #### Passkey

    <Tip>
      In order to use passkeys as a MFA method, make sure a valid passkey is linked to the user. You can set this up by following the steps [here](user-management/users/linking-accounts)!
    </Tip>

    First, initiate enrollment by calling Privy's  method with a JSON parameter of :

    ```tsx
    await initMfaEnrollment({method: 'passkey'});
    ```

    Then, to have the user enroll, you must call Privy's `submitMfaEnrollment` method with a list of the user's passkey account `credentialIds`:

    ```tsx
    const {user} = usePrivy();

    // ...

    const credentialIds = user.linked_accounts
      .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
      .map((x) => x.credentialId);

    await submitMfaEnrollment({method: 'passkey', credentialIds});
    ```

    <Accordion title="See an end-to-end example of enrolling users in MFA with passkeys">
      The component below serves as a reference implementation for how to enroll your users in MFA with passkeys!

      ```tsx Example enrolling passkeys for MFA
      import {useMfaEnrollment, usePrivy} from '@privy-io/expo';

      export default function MfaEnrollmentWithPasskey() {
        const {user} = usePrivy();
        const {iniMfaEnrollment, submitMfaEnrollment} = useMfaEnrollment();

        const handleEnrollmentWithPasskey = async () => {
          await initMfaEnrollment({method: 'passkey'});

          const credentialIds = user.linked_accounts
            .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
            .map((x) => x.credentialId);

          await submitMfaEnrollment({method: 'passkey', credentialIds});
        };

        return (
          <YStack>
            <Text>Enable your passkeys for MFA</Text>
            {user.linkedAccounts
              .filter((account): account is PasskeyWithMetadata => account.type === 'passkey')
              .map((account) => (
                <Text >ID: {account.id} {' '} Credential ID: {account.credentialId}</div>
              ))}
            {// Initialize and submit the passkey credentials for MFA enrollment in one step }
            <Button onPress={handleEnrollmentWithPasskey}>
              <Text>Enroll</Text>
            </Button>
          </YStack>
        );
      }
      ```
    </Accordion>

    ### Completing MFA with custom UIs in Expo

    To set up a flow to have the user complete MFA, use Privy's  hook:

    ```tsx
    const {init, submit, cancel} = useMfa();
    ```

    This flow has three core components:

    1. Requesting an MFA code be sent to the user's MFA method ()
    2. Submitting the MFA code provided by the user ()
    3. Cancelling an in-progress MFA flow ()

    #### Requesting and submitting an MFA challenge

    <Tabs>
      <Tab title="Submitting a user-input code (SMS/TOTP)">
        To request an MFA challenge and then submit the code:

        ```tsx
        const selectedMfaMethod = 'sms'; // Must be 'sms', 'totp' or 'passkey'
        await init({method: selectedMfaMethod});

        // After user enters the code
        const mfaCode = 'insert-mfa-code-from-user';
        await submit({method: selectedMfaMethod, mfaCode});
        ```
      </Tab>

      <Tab title="Submitting a passkey">
        For passkey verification:

        ```tsx
        const options = await init({method: 'passkey'});

        // Submit will trigger the system's native passkey prompt
        await submit({method: 'passkey', mfaCode: options});
        ```
      </Tab>
    </Tabs>

    When invoked,  returns a `Promise` that resolves to `void` if the user has successfully completed MFA, or rejects with an error if there was an issue completing MFA.

    #### Cancelling the MFA flow

    To cancel the current MFA flow, call the  method from the  hook:

    ```tsx
    cancel();
    ```

    <Accordion title="See a recommended abstraction for guiding users to complete MFA">
      To simplify the implementation, we recommend abstracting the logic into a self-contained component. For example:

      ```tsx Example modal for guiding users through the MFA flow
      import Modal from 'react-native';

      import {
        errorIndicatesMfaVerificationFailed,
        errorIndicatesMfaMaAttempts,
        errorIndicatesMfaTimeout,
        MfaMethod,
      } from '@privy-io/expo';

      type Props = {
        // List of available MFA methods that the user has enrolled in
        mfaMethods: MfaMethod[];
        // Boolean indicator to determine whether or not the modal should be open
        isOpen: boolean;
        // Helper function to open/close the modal */
        setIsOpen: (isOpen: boolean) => void;
      };

      export const MFAModal = ({mfaMethods, isOpen, setIsOpen}: Props) => {
        const {init, submit, cancel} = useMfa();
        const [selectedMethod, setSelectedMethod] = useState<MfaMethod | null>(null);
        const [mfaCode, setMfaCode] = useState('');
        const [options, setOptions] = useState(null);
        const [error, setError] = useState('');

        const onMfaInit = async (method: MfaMethod) => {
          const response = await init({method});
          setError('');
          setSelectedMethod(method);
          if (method === 'passkey') {
            setOptions(response);
          }
        };

        const onMfaSubmit = async () => {
          try {
            if (selectedMethod === 'passkey') {
              await submit({method: selectedMethod, mfaCode: options});
            } else {
              await submit({method: selectedMethod, mfaCode});
            }
            setSelectedMethod(null);
            setIsOpen(false);
          } catch (e) {
            if (errorIndicatesMfaVerificationFailed(e)) {
              setError('Incorrect MFA code, please try again.');
            } else if (errorIndicatesMfaMaxAttempts(e)) {
              setError('Maximum MFA attempts reached, please request a new code.');
              setSelectedMethod(null);
            } else if (errorIndicatesMfaTimeout(e)) {
              setError('MFA code has expired, please request a new code.');
              setSelectedMethod(null);
            }
          }
        };

        const onModalClose = () => {
          cancel();
          setIsOpen(false);
        };

        return (
          <Modal visible={isOpen} animationType="slide" onRequestClose={onModalClose}>
            <View style={{padding: 20}}>
              {mfaMethods.map((method) => (
                <Button
                  key={method}
                  title={`Choose to MFA with ${method}`}
                  onPress={() => onMfaInit(method)}
                />
              ))}

              {selectedMethod && selectedMethod !== 'passkey' && (
                <View>
                  <Text>Enter your MFA code below</Text>
                  <TextInput
                    placeholder="123456"
                    value={mfaCode}
                    onChangeText={setMfaCode}
                    keyboardType="numeric"
                    style={{borderBottomWidth: 1, marginBottom: 10}}
                  />
                  <Button title="Submit Code" onPress={onMfaSubmit} />
                </View>
              )}

              {error.length > 0 && <Text style={{color: 'red'}}>{error}</Text>}
              <Button title="Close" onPress={onModalClose} />
            </View>
          </Modal>
        );
      };
      ```
    </Accordion>

    #### Registering an event listener

    To set up this configuration, use Privy's  hook:

    ```tsx MFAProvider.tsx
    import {useRegisterMfaListener, MfaMethod} from '@privy-io/expo';

    import {MFAModal} from '../components/MFAModal';

    export const MFAProvider = ({children}: {children: React.ReactNode}) => {
      const [isMfaModalOpen, setIsMfaModelOpen] = useState(false);
      const [mfaMethods, setMfaMethods] = useState<MfaMethod[]>([]);

      useRegisterMfaListener({
        // Privy will invoke this whenever the user is required to complete MFA
        onMfaRequired: (methods) => {
          // Update app's state with the list of available MFA methods for the user
          setMfaMethods(methods);
          // Open MFA modal to allow user to complete MFA
          setIsMfaModalOpen(true);
        },
      });

      return (
        <View>
          {/* This `MFAModal` component includes all logic for completing the MFA flow with Privy's `useMfa` hook */}
          <MFAModal isOpen={isMfaModalOpen} setIsOpen={setIsMfaModalOpen} mfaMethods={mfaMethods} />
          {children}
        </View>
      );
    };
    ```

    <Info>
      In order for Privy to invoke your app's MFA flow, the component that calls Privy's  hook **must be mounted** whenever the user's embedded wallet requires that they complete MFA.

      We recommend that you render this component near the root of your application, so that it is always rendered whenever the embedded wallet may be used.
    </Info>

    ### Managing MFA methods

    Privy also allows users to also delete MFA methods via the  method returned from the  hook:

    ```tsx Example unenrolling SMS/TOTP/passkey
    import {useMfaEnrollment} from '@privy-io/expo';

    export default function MfaUnenrollment() {
      const {unenrollWithSms, unenrollWithTotp} = useMfaEnrollment();

      return (
        <YStack>
          <Button onClick={() => unenrollMfa({method: 'sms'})}>
            <Text>Unenroll SMS</Text>
          </Button>
          <Button onClick={() => unenrollMfa({method: 'totp'})}>
            <Text>Unenroll TOTP</Text>
          </Button>
          <Button onClick={() => unenrollMfa({method: 'passkey'})}>
            <Text>Unenroll passkey</Text>
          </Button>
        </YStack>
      );
    }
    ```

    <Info>
      By default, unenrolling a passkey will also unlink it as a valid login method. In order to modify this behavior, you can set the `removeForLogin` option to `false` on the `unenrollMfa` call:

      ```tsx
      <Button onClick={() => unenrollMfa({method: 'passkey', removeForLogin: false})}>
        <Text>Unenroll passkey, keep as login method</Text>
      </Button>
      ```
    </Info>
  </Tab>
</Tabs>


# Using default Privy UIs
Source: https://docs.privy.io/authentication/user-authentication/mfa/default-ui



<Tabs>
  <Tab title="React">
    ### Enrolling users in MFA

    Once you have enabled MFA for your app, **to prompt your users to enroll in MFA for their embedded wallet, use the `showMfaEnrollmentModal` method from the `useMfaEnrollment` hook.**

    ```tsx Example button for enrolling in wallet MFA
    import {useMfaEnrollment} from '@privy-io/react-auth';

    function MfaEnrollmentButton() {
      const {showMfaEnrollmentModal} = useMfaEnrollment();
      return <button onClick={showMfaEnrollmentModal}>Enroll in MFA</button>;
    }
    ```

    When invoked,  will open a Privy modal that prompts the user to select their desired MFA method from the ones you've enabled for your app, and will guide them through the enrollment process.

    ![images/MFA.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/MFA.png)

    Once a user has successfully enrolled an MFA method, the user's enrolled method will appear under the  field of their  object:

    ```tsx
    const {user} = usePrivy();
    console.log(user.mfaMethods);
    // ['sms', 'totp', 'passkey'] for a user who has enrolled in all of SMS, TOTP, and passkey MFA
    ```

    ### Managing MFA methods

    To allow your users to modify their MFA methods, **simply invoke the `showMfaEnrollmentModal` method from the `useMfaEnrollment` hook.**  This is the *same* method you would use to prompt your user to enroll in MFA for the first time.

    Within this modal, users can **remove existing MFA methods or enroll in additional ones** for their embedded wallet. Prior to making changes to their MFA methods, users will be prompted to re-verify their identity using one of their existing MFA methods.

    <Info>
      By default, removing a passkey as MFA will also unlink it as a valid login method. In order to modify this behavior, you can set the `shouldUnlinkOnUnenrollMfa` option to `false` under the `passkeys` config in `PrivyProvider`.

      ```tsx
      <PrivyProvider
        appId="your-privy-app-id"
        config={{
          ...theRestOfYourConfig,
          passkeys: {
            // Set this to `false` if you wish to keep the passkey as a login method after unenrolling from MFA.
            shouldUnlinkOnUnenrollMfa: false,
          },
        }}
      >
        {/* your app's content */}
      </PrivyProvider>
      ```
    </Info>

    ### Authorizing signatures and transactions

    Once a user has enrolled in MFA, **every attempt to use the wallet's private key (every signature or transaction) will require the user to complete MFA using their method.** This logic is automatic; you do not need to do anything else once your user has enrolled in wallet MFA.

    When your app requests a signature or a transaction from the embedded wallet, **Privy will show the user a modal prompting them to enter a 6-digit MFA code sent to their MFA method.** If the user has enrolled in multiple MFA methods, they can choose which method they'd like to use for this given request.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/mfa-usage.png" alt="Authorizing signatures and transactions with wallet MFA" />

    Users must enter their MFA code within 5 minutes of receiving it, and are allowed up to a maximum of 4 code attempts if they incorrectly enter their code.

    **If the user correctly enters their MFA code, the signature or transaction request will be processed by the wallet.** Additionally, their MFA verification status will be cached for **15 minutes**. This means that for additional signatures or transactions requested within this window, Privy will **not** prompt the user to re-complete MFA.

    **If the user does not complete MFA or enters in an incorrect code 4 times or more, the signature or transaction will raise an error as if the user rejected the request.**
  </Tab>

  <Tab title="React Native">
    ### Setting up MFA UIs in React Native

    Once you've set up `PrivyElements`, you can use Privy's default UIs to enroll your users in MFA and prompt them for MFA during wallet actions.

    <Info>
      Before integrating MFA UIs, make sure to also set up multi-factor authentication in the dashboard per [this guide](/authentication/user-authentication/mfa).
    </Info>

    ### MFA enrollment

    Privy's default UIs for React Native can also be used for allowing your users to enroll their first MFA verification method, or any number of additional ones.

    For this, use the `useMfaEnrollmentUI` hook to get an `init` method, that you can use to launch the flow. This method takes in a configuration object with the following fields:

    <ParamField path="mfaMethods" type="MfaMethod[]">
      This will be the array of mfa methods that will be available in the UI. Make sure to have the methods you set here enabled.
    </ParamField>

    <ParamField path="relyingParty" type="string">
      It should be the URL origin where your [Apple App Site Association](/authentication/user-authentication/login-methods/passkey) or [Digital Asset Links](/authentication/user-authentication/login-methods/passkey) are available (e.g. `https://example.com`).
    </ParamField>

    ```tsx
    import {useMfaEnrollmentUI} from '@privy-io/expo/ui';

    export function EnrollMFAMethodButton() {
      const {init: initMfaEnrollmentUI} = useMfaEnrollmentUI();

      const onEnrollMfa = async () => {
        try {
          await initMfaEnrollmentUI({mfaMethods: ['sms', 'totp', 'passkey']});
          // Your code on actions to execute after successful mfa enrollment
        } catch (error) {
          // Your code on cancelled or otherwise unsuccessful mfa enrollment
        }
      };

      return <Button onPress={onEnrollMfa}>Enroll an MFA method</Button>;
    }
    ```

    <Tip>
      The UIs that will show up using `useMfaEnrollmentUI` will also **allow the user to unenroll** MFA methods.
    </Tip>

    ### Passkey unenrollment

    Using the MFA enrollment UIs means users will also be able to **unenroll** a method they had previously set up too.

    For passkeys, the default behavior when unenrolling is that the passkey is also **removed** as a valid login method.

    You can change this behavior in the MFA UIs, by setting the `shouldUnlinkOnUnenrollMfa` option in the `PrivyElements` component:

    ```tsx
    import {PrivyElements} from '@privy-io/expo/ui';

    export default function RootLayout() {
      return (
        <>
          {/* Your app's content */}
          <PrivyElements config={{passkeys: {shouldUnlinkOnUnenrollMfa: false}}} />
        </>
      );
    }
    ```

    ### MFA verification

    Privy's default UIs for React Native can be used for your users to verify their already set MFA methods, such as SMS or passkeys.

    <Tip>
      You can use Privy's default UIs for MFA verification even if you're using headless flows for working with the wallet. This way, Privy's UIs can integrate smoothly with your custom flows and experiences.
    </Tip>

    To do this, you must enable the `enableMfaVerificationUIs` option on the `PrivyElements` component:

    ```tsx
    import {PrivyElements} from '@privy-io/expo/ui';

    export default function RootLayout() {
      return (
        <>
          {/* Your app's content */}
          <PrivyElements config={{mfa: {enableMfaVerificationUIs: true}}} />
        </>
      );
    }
    ```

    After doing this, all operations you do on the wallet (such as signing messages or preparing transactions) will automatically trigger the MFA UIs if MFA verification is required at that moment.

    <Warning>
      If you were using the `useRegisterMfaListener` hook before you should now remove it from your codebase, as Privy will handle the MFA events and UI for you.
    </Warning>
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/authentication/user-authentication/mfa/overview



**Privy enables users to set up multi-factor authentication (MFA) for embedded wallets on both EVM networks and Solana.** MFA helps secure the embedded wallet by requiring additional verification of a user's identity when the wallet is used.

![images/MFA.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/MFA.png)

Once a user enrolls in wallet MFA, **any action that requires use of the embedded wallet's private key will require the user to complete MFA verification.** This includes signing messages, sending transactions, exporting the embedded wallet, and recovering the embedded wallet for use on new devices.

**Privy currently supports three methods of wallet MFA:**

* **SMS**, where users verify with a 6-digit MFA code sent to their phone number
* **Time-based one-time password (TOTP)**, where users verify with a 6-digit MFA code from an authentication app, like Authy or Google Authenticator
* **Passkeys**, where users verify with a previously registered passkey, generally through biometric authentication on their device

<Tip>
  If a user has multiple embedded wallets (e.g. on EVM and Solana, or multiple HD addresses),
  enrolling in MFA will require MFA for signatures and transactions from **any** of their embedded
  wallets.
</Tip>


# Setting up wallet MFA for your app
Source: https://docs.privy.io/authentication/user-authentication/mfa/setup



To enable MFA for your app, select your desired app from the sidebar and navigate to the **User management > Authentication > MFA** page.

Within the **MFA** tab, scroll down to the **Enable MFA for transactions** section and **select the desired MFA methods** you'd like to enable for your app.

![images/MFA2.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/MFA2.png)

Once you have selected your desired MFA methods and saved changes, you can prompt your users to enroll in any of the methods you've enabled!

Please note that:

* If your app has SMS enabled as a login method, you **may not** enable SMS as an MFA method as well.
  With SMS login enabled, SMS can already be used as the primary factor to authenticate the user for access to their wallet; it cannot be enabled as an additional factor as well.
* To use passkeys as an MFA method, you *must* also enable passkeys as a login method

## Implementation Options

Privy offers two main approaches to implement wallet MFA in your application:

1. **Using Privy's default UIs** - The simplest approach where Privy handles the UI components
2. **Building custom UIs (headless)** - More involved but gives you complete control over the user experience


# UI components
Source: https://docs.privy.io/authentication/user-authentication/ui-component



Privy supports easy onboarding with an out-of-the-box user interface to log users in.

The fastest way to integrate Privy is with the Privy login modal. Your application can integrate this modal in just a few lines of code and easily toggle on login methods for your application in the Privy dashboard.

You can also design your own login UIs, and integrate with Privy’s authentication APIs to offer a login experience that feels seamless within your application.

![images/Onboard.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Onboard.png)

<Info>
  [Configure your login methods](/basics/get-started/dashboard/configure-login-methods) in the Privy
  Dashboard before using the UI components.
</Info>

<Tabs>
  <Tab title="React">
    <Tip>
      Privy's UIs are highly-customizable to seamlessly match the branding and design system of your
      app. Learn more about [customizing the login modal](/basics/react-native/advanced/configuring-appearance).
    </Tip>

    To have users login to your app with Privy's UIs, use the `login` method from the `useLogin` hook.

    ```tsx
    login: ({ loginMethods: PrivyClientConfig['loginMethods'], prefill?: { type: 'email' | 'phone', value: string }, disableSignup?: boolean, walletChainType?: 'ethereum-only' | 'solana-only' | 'ethereum-or-solana' }) => PrivyUser;
    ```

    ### Usage

    ```tsx
    import { useLogin, usePrivy } from '@privy-io/react-auth';

    function LoginButton() {
        const { ready, authenticated} = usePrivy();
        const { login } = useLogin();
        // Disable login when Privy is not ready or the user is already authenticated
        const disableLogin = !ready || (ready && authenticated);

        return (
            <button disabled={disableLogin} onClick={login}>
                Log in
            </button>
        );
    }
    ```

    ### Parameters

    <ParamField path="loginMethods" type="PrivyClientConfig['loginMethods']">
      Optionally specify which login methods to display in the modal.

      <Expandable title="Login Methods">
        The following login methods are supported:

        <ul>
          <ParamField path="wallet" type="string" />

          <ParamField path="email" type="string" />

          <ParamField path="sms" type="string" />

          <ParamField path="google" type="string" />

          <ParamField path="twitter" type="string" />

          <ParamField path="discord" type="string" />

          <ParamField path="github" type="string" />

          <ParamField path="linkedin" type="string" />

          <ParamField path="spotify" type="string" />

          <ParamField path="instagram" type="string" />

          <ParamField path="tiktok" type="string" />

          <ParamField path="apple" type="string" />

          <ParamField path="farcaster" type="string" />

          <ParamField path="telegram" type="string" />

          <ParamField path="passkey" type="string" />
        </ul>
      </Expandable>
    </ParamField>

    <ParamField path="prefill" type="{ type: 'email' | 'phone', value: string }">
      Optionally pre-fill the login modal with the user's email or phone number.
    </ParamField>

    <ParamField path="disableSignup" type="boolean">
      Prevent users from signing up for your app. This is useful when you want to enforce that users can only log in with existing accounts.
    </ParamField>

    <ParamField path="walletChainType" type="'ethereum-only' | 'solana-only' | 'ethereum-or-solana'">
      Filter the login wallet options to only show wallets that support the specified chain type.
    </ParamField>

    ### Callbacks

    You can easily attach callbacks to the `login` method using the `useLogin` hook. This allows you to run custom logic when a user successfully logs in or when there's an error.

    ```tsx
    import { useLogin } from '@privy-io/react-auth';

    function LoginButton() {
        const { login } = useLogin({
            onSuccess: (user) => {
                console.log('User logged in successfully', user);
                // Navigate to dashboard, show welcome message, etc.
            },
            onError: (error) => {
                console.error('Login failed', error);
                // Show error message
            }
        });

        return <button onClick={login}>Log in</button>;
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tip>
      Make sure you have [properly configured PrivyElements](/basics/react-native/advanced/setup-privyelements) before using UI components for authentication.
    </Tip>

    <Info>
      Privy's UIs are highly-customizable to seamlessly match the branding and design system of your app. Learn more about [customizing the login modal](/basics/react-native/advanced/configuring-appearance).
    </Info>

    To have users login to your app with Privy's UIs, use the `login` method from the `useLogin` hook.

    ```javascript
    login: ({ loginMethods: LoginMethod[], appearance?: { logo?: string } }) => void;
    ```

    ### Usage

    ```tsx
    import { useLogin } from '@privy-io/expo/ui';

    function LoginButton() {
        const { login } = useLogin();

        return (
            <Button
                onPress={() => {
                    login({ loginMethods: ['email', 'sms']})
                        .then((session) => {
                            console.log('User logged in', session.user);
                        })
                }}
                title="Log in"
            />
        );
    }
    ```

    ### Parameters

    <ParamField path="loginMethods" type="LoginMethod[]">
      An array of login methods for your users to choose from. The supported methods are `'email'`, `'sms'`, `'discord'`, `'twitter'`, `'github'`, `'spotify'`, `'instagram'`, `'tiktok'`, `'linkedin'`, and `'apple'`.
    </ParamField>

    <ParamField path="appearance.logo" type="string">
      (Optional) a url for the logo shown in the Login Method selection step. Aspect ratio should be 2:1.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="PrivyUser">
      The user that logged in, with all of their properties.
    </ResponseField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/android/installation



## Requirements

* Android API 27+ (Android 8.1 Oreo or newer)
* Kotlin 2.1.0+

## Installation

The Privy Android SDK is available on Maven Central.

1. Include the `mavenCentral()` repository in your gradle files:

```kotlin
repositories {
    google()
    mavenCentral()
}
```

2. Add the latest Privy SDK dependency to your app's `build.gradle` file:

```kotlin
dependencies {
  // Privy Core
  implementation("io.privy:privy-core:X.Y.Z") // Replace with the latest version

  // other dependencies
}
```

The latest version can be found [here](https://mvnrepository.com/artifact/io.privy/privy-core).


# Quickstart
Source: https://docs.privy.io/basics/android/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Android app

## Prerequisites

This guide assumes that you have completed the [setup](/basics/android/setup) guide.

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via SMS.

This is a two step process:

1. Send an OTP to the user provided phone number.
2. Verify the OTP sent to the user.

<Note>
  Please be sure to configure SMS as a login method on the [**Privy Developer
  Dashboard**](https://dashboard.privy.io) under User Management > Authentication.
</Note>

#### 1. Send an OTP to the user's phone number via SMS

After collecting and validating your users phone number, send an OTP by calling the **`sendCode`** method.
Note: you must provide the phone number in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).

```kotlin
val result: Result<Unit> = privy.sms.sendCode(phoneNumber = "+14155552671")

result.fold(
  onSuccess = {
    // OTP was successfully sent
  },
  onFailure = {
    println("Error sending OTP: ${it.message}")
  }
)
```

If the OTP is sent successfully, `sendCode` will return `Result.success` with no associated type.
If the provided phone number is invalid, or sending the OTP fails, **`sendCode`** will return `Result.failure`.

#### 2. Authenticate with OTP

The user will then receive an SMS with a 6-digit OTP. Prompt for this OTP within your application, then authenticate the user with the `loginWithCode` method. Pass the following parameters to this method:

<ParamField name="code" type="String">
  OTP code inputted by the user in your app.
</ParamField>

<ParamField name="phoneNumber" type="String">
  The user's phone number.
</ParamField>

```kotlin
val result: Result<PrivyUser> = privy.sms.loginWithCode(code = "123456", phoneNumber = "+14155552671")

result.fold(
  onSuccess = { user ->
    // User logged in
  },
  onFailure = {
    println("Error logging in user: ${it.message}")
  }
)
```

If the OTP/phone number combination is valid, Privy will successfully authenticate your user and `loginWithCode` will return `Result.success` with an encapsulated `PrivyUser`.
If the provided OTP/phone number combination is invalid, `loginWithCode` will return `Result.failure`.

## The Embedded wallet

<Tabs>
  <Tab title="Ethereum">
    ### Create an embedded wallet

    To create an EVM embedded wallet for your user, call the `createEthereumWallet` method on your `PrivyUser` instance.

    ```kotlin
    public interface PrivyUser {
      // Other privy user methods

      public suspend fun createEthereumWallet(allowAdditional: Boolean = false):  Result<EmbeddedEthereumWallet>

      // ...
    }
    ```

    <ParamField name="allowAdditional" type="Boolean" optional default="false">
      Ethereum embedded wallets are [hierarchical deterministic (HD)
      wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets),
      and a user's seed entropy can support multiple separate embedded wallets. If a user already has a
      wallet and you'd like to create additional HD wallets for them, pass in `true` for the
      `allowAdditional` parameter.
    </ParamField>

    If a wallet is successfully created for the user, an **`EmbeddedEthereumWallet`** object is returned as an encapsulated value of Result.success.

    This method will `Result.failure` if:

    * The user is not authenticated
    * If a user already has 9 or more wallets
    * If the network call to create the wallet fails
    * If a user already has an embedded wallet and `allowAdditional` is not set to true.

    #### Example

    ```kotlin
    privy.user?.let { privyUser ->
      // non null user means user is authenticated
      val result = privyUser.createEthereumWallet(allowAdditional = false)

      result.fold(
        onSuccess = { ethereumWallet ->
          println("Created wallet with address: ${ethereumWallet.address}")
        },
        onFailure = {
          println("Error creating Ethereum wallet: ${it.message}")
        }
      )
    }
    ```

    ### Using the embedded wallet

    To enable your app to request signatures and transactions from the embedded wallet, Privy Ethereum embedded wallets expose a provider *inspired by* the [**EIP-1193 provider**](https://eips.ethereum.org/EIPS/eip-1193) standard. This allows you request signatures and transactions from the wallet via a familiar [**JSON-RPC API**](https://ethereum.org/en/developers/docs/apis/json-rpc/) (e.g. [`personal_sign`](https://docs.metamask.io/wallet/reference/personal_sign/)).

    Once you have an instance of an `EmbeddedEthereumWallet`, you can make RPC requests by using the `provider: EmbeddedEthereumWalletProvider` hook and using its `request` method. For example, `wallet.provider.request(request: rpcRequest)`. This request method will suspend and await if the embedded wallet needs to wait for any internal ready state.

    ```kotlin
    public interface EmbeddedEthereumWalletProvider {
     /**
      * Sends a request to the Ethereum provider
      *
      * @param The RPC request
      * @return The response received
      */
     public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    }
    ```

    As a parameter to this method, to this method, pass an **`EthereumRpcRequest`** object that contains:

    * **`method`**: the name of the JSON-RPC method for the wallet to execute (e.g. `'personal_sign'`)
    * **`params`**: an array of parameters required by your specified **`method`**

    By default, embedded wallets are connected to the Ethereum mainnet. To send a transaction on a different network, simply set the wallet's `chainId` in the transaction request.

    Example usage:

    ```kotlin
    // Get Privy user
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
      // Retrieve list of user's embedded Ethereum wallets
      val ethereumWallets = user.embeddedEthereumWallets

      if (ethereumWallets.isNotEmpty()) {
        // Grab the desired wallet. Here, we retrieve the first wallet
        val ethereumWallet = ethereumWallets.first()

        // Make an rpc request
        ethereumWallet.provider.request(
          request = EthereumRpcRequest(
            method = "personal_sign",
            params = listOf("A message to sign", ethereumWallet.address),
          ),
        )
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Create an embedded wallet

    To create a Solana embedded wallet for your user, call the `createSolanaWallet` method on your `PrivyUser` instance.

    ```kotlin
    public interface PrivyUser {
      // Other privy user methods

      public suspend fun createSolanaWallet():  Result<EmbeddedSolanaWallet>

      // ...
    }
    ```

    If a wallet is successfully created for the user, an **`EmbeddedSolanaWallet`** object is returned as an encapsulated value of Result.success.

    This method will `Result.failure` if:

    * The user is not authenticated
    * A user already has a Solana wallet
    * If the network call to create the wallet fails

    #### Example

    ```kotlin
    privy.user?.let { privyUser ->
      // non null user means user is authenticated
      val result = privyUser.createSolanaWallet()

      result.fold(
        onSuccess = { solanaWallet ->
          println("Created wallet with address: ${solanaWallet.address}")
        },
        onFailure = {
          println("Error creating Solana wallet: ${it.message}")
        }
      )
    }
    ```

    ### Using the embedded wallet

    Privy supports requesting signatures on messages and transactions from a user's Solana embedded wallet using the `signMessage` RPC. To request a signature, get the Solana embedded wallet provider and call the `signMessage` method on it with a base-64 encoded message to sign. If the signature is computed successfully, `signMessage` will return it as a base64-encoded string.

    ```kotlin
    public interface EmbeddedSolanaWalletProvider {
      /**
       * Request a signature on a Base64 encoded message or transaction
       *
       * @param message Base64 encoded message or transaction
       * @return The Base64 encoded computed signature
       */
      public suspend fun signMessage(message: String): Result<String>
    }
    ```

    Example usage:

    ```kotlin
    // Get current auth state
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
        // Retrieve the user's Solana wallet
        val solanaWallet = user.embeddedSolanaWallets.first()

        if (solanaWallet != null) {
            // Base 64 encoded: "Hello! I am the base64 encoded message to be signed."
            val result = solanaWallet.provider.signMessage("SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")
        }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/android/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow this guide to configure an app client by
  following this guide [here](/basics/get-started/dashboard/app-clients).
</Warning>

## Initializing Privy

Initialize a **Privy** instance with your application context and a **`PrivyConfig`** object:

```kotlin
private val privy: Privy =
   Privy.init(
       context = applicationContext, // be sure to only pass in Application context
       config = PrivyConfig(
           appId = "YOUR_APP_ID",
           appClientId = "YOUR_APP_CLIENT_ID",
           logLevel = PrivyLogLevel.VERBOSE
       )
   )
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField body="appId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField body="appClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<ParamField body="logLevel" type="PrivyLogLevel" optional>
  (Optional) Your preferred log level. If no log level is specified, it will default to
  `PrivyLogLevel.NONE`.
</ParamField>

<ParamField body="customAuthConfig" type="LoginWithCustomAuthConfig" optional>
  (Optional) Only use this if you plan to use custom authentication. Find more information
  [here](/authentication/user-authentication/jwt-based-auth).
</ParamField>

<Tip>
  Be sure to maintain a single instance of Privy across the lifetime of your application.
  Initializing multiple instances of Privy will result in unexpected errors.
</Tip>

## Waiting for Privy to be ready

When the Privy SDK is initialized, the user's authentication state will be set to `NotReady` until Privy finishes initialization. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until Privy has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

For your convenience, we've added a suspending `awaitReady()` function that you can use to wait for Privy to finish initializing:

```kotlin
// Launch a coroutine in order to await Privy's ready state
viewModelScope.launch {
  // Show loading UI
  uiState = .loading

  // Await ready
  privy.awaitReady()

  // Check if user is authenticated
  val isPrivyUserAuthenticated = privy.authState.value.isAuthenticated()

  // Show loaded UI accordingly
  uiState = .loaded(isPrivyUserAuthenticated)
}
```


# null
Source: https://docs.privy.io/basics/flutter/installation



## Supported Platforms

* ✅ Android
* ✅ iOS
* ❌ Web

## Requirements

* Flutter: 3.24.0+
* Dart: 3.0.0+
* Android: API 27+ (Android 8.1 Oreo or newer) and Kotlin 2.1.0+
* iOS: 16+ and Swift Package Manager

## Installation

### Enable Swift Package Manager

The Privy Flutter SDK uses Swift Package Manager. To enable it, run:

```bash
flutter config --enable-swift-package-manager
```

<Note>
  You'll need to either use Flutter 3.24.0 on the main channel (experimental) or Flutter 3.27.0+ on
  stable. While 3.24.0 support is available by switching to Flutter's main channel, this is not
  recommended for production apps as the main channel can be unstable.
</Note>

### Add the Dependency

1. The Privy Flutter SDK is available on pub.dev. Add it to your `pubspec.yaml` file:

```yaml
dependencies:
  flutter:
    sdk: flutter
  privy_flutter: X.Y.Z # Replace with the latest version from pub.dev
```

2. Run the following command to install the dependency:

```bash
flutter pub get
```


# Quickstart
Source: https://docs.privy.io/basics/flutter/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Flutter app

## Prerequisites

This guide assumes that you have completed the [setup](/basics/flutter/setup) guide.

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via SMS.

This is a two step process:

1. Send an OTP to the user provided phone number.
2. Verify the OTP sent to the user.

<Note>
  Please be sure to configure SMS as a login method on the [**Privy Developer
  Dashboard**](https://dashboard.privy.io) under User Management > Authentication.
</Note>

#### 1. Send an OTP to the user's phone number via SMS

After collecting and validating your users phone number, send an OTP by calling the **`sendCode`** method.
Note: you must provide the phone number in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).

```dart
final Result<void> result = await privy.sms.sendCode("+14155552671");

result.fold(
  onSuccess: (_) {
    // OTP was sent successfully
  },
  onFailure: (error) {
    // Handle error sending OTP
    print(error.message);
  },
);

```

If the OTP is sent successfully, **`sendCode`** will return `Success()` with no associated type. If the provided email address is invalid, or sending the OTP fails, **`sendCode`** will return `Failure()` containing a `PrivyException`.

#### 2. Authenticate with OTP

The user will then receive an SMS with a 6-digit OTP. Prompt for this OTP within your application, then authenticate the user with the `loginWithCode` method. Pass the following parameters to this method:

<ParamField name="code" type="String" required>
  OTP code inputted by the user in your app.
</ParamField>

<ParamField name="phoneNumber" type="String" required>
  The user's phone number.
</ParamField>

```dart
final Result<PrivyUser> result = await privy.sms.loginWithCode(
  code: code,
  phoneNumber: phoneNumber,
);

result.fold(
  onSuccess: (user) {
    // User authenticated successfully
  },
  onFailure: (error) {
    // Handle authentication error
  },
);

```

If the OTP/phone number combination is valid, Privy will successfully authenticate your user and `loginWithCode` will return `Result.Success()` with an encapsulated `PrivyUser`.
If the provided OTP/phone number combination is invalid, `loginWithCode` will return `Result.Failure()`, containing a PrivyException.

## The embedded wallet

<Tabs>
  <Tab title="Ethereum">
    ### Create an embedded wallet

    To create an EVM embedded wallet for your user, call the `createEthereumWallet` method on your `PrivyUser` instance.

    ```dart
    abstract class PrivyUser {
      // Other privy user methods

      /// Creates an Ethereum embedded wallet for the user.
      Future<Result<EmbeddedEthereumWallet>> createEthereumWallet({bool allowAdditional = false});
    }

    ```

    <ParamField name="allowAdditional" type="Bool" optional default="false">
      Ethereum embedded wallets are [hierarchical deterministic (HD)
      wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets),
      and a user's seed entropy can support multiple separate embedded wallets. If a user already has a
      wallet and you'd like to create additional HD wallets for them, pass in `true` for the
      `allowAdditional` parameter.
    </ParamField>

    If a wallet is successfully created for the user, an **`EmbeddedEthereumWallet`** object is returned as an encapsulated value of `Success()`.

    This method will fail if:

    * The user is not authenticated
    * If a user already has 9 or more wallets
    * If the network call to create the wallet fails
    * If a user already has an embedded wallet and `allowAdditional` is not set to true.

    ### Using the embedded wallet

    To enable your app to request signatures and transactions from the embedded wallet, Privy Ethereum embedded wallets expose a provider *inspired by* the [**EIP-1193 provider**](https://eips.ethereum.org/EIPS/eip-1193) standard. This allows you request signatures and transactions from the wallet via a familiar [**JSON-RPC API**](https://ethereum.org/en/developers/docs/apis/json-rpc/) (e.g. [`personal_sign`](https://docs.metamask.io/wallet/reference/personal_sign/)).

    Once you have an instance of an `EmbeddedEthereumWallet`, you can make RPC requests by using the `provider: EmbeddedEthereumWalletProvider` hook and using its `request` method. For example, `wallet.provider.request(request: rpcRequest)`. This request method will suspend and await if the embedded wallet needs to wait for any internal ready state.

    ```dart
    /// Defines the Ethereum Wallet Provider interface for sending RPC requests.
    abstract class EmbeddedEthereumWalletProvider {
       /**
        * Sends a request to the Ethereum provider
        *
        * @param The RPC request
        * @return The response received
        */
      Future<Result<EthereumRpcResponse>> request(EthereumRpcRequest request);
    }
    ```

    As a parameter to this method, to this method, pass an **`EthereumRpcRequest`** object that contains:

    * **`method`**: the name of the JSON-RPC method for the wallet to execute (e.g. `'personal_sign'`)
    * **`params`**: an array of parameters required by your specified **`method`**

    By default, embedded wallets are connected to the Ethereum mainnet. To send a transaction on a different network, simply set the wallet's `chainId` in the transaction request.

    Example usage:

    ```dart
    // Get the Privy user
    final user = privy.user;

    // Check if the user is authenticated
    if (user != null) {
      // Retrieve the list of user's embedded Ethereum wallets
      final ethereumWallets = user.embeddedEthereumWallets;

      if (ethereumWallets.isNotEmpty) {
        // Grab the desired wallet. Here, we retrieve the first wallet
        final ethereumWallet = ethereumWallets.first;

        // Make an RPC request
        ethereumWallet.provider.request(
          request: EthereumRpcRequest(
            method: "personal_sign",
            params: ["A message to sign", ethereumWallet.address],
          ),
        );
      }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Creating the embedded wallet

    To create a Solana embedded wallet for your user, call the `createSolanaWallet` method on your `PrivyUser` instance.

    ```dart
    abstract class PrivyUser {
      /// Creates a Solana embedded wallet for the user.
      Future<Result<EmbeddedSolanaWallet>> createSolanaWallet();
    }
    ```

    If a wallet is successfully created for the user, an **`EmbeddedSolanaWallet`** object is returned as an encapsulated value of `Result.Success()`.

    This method will `Result.Failure()` with a PrivyException if:

    * The user is not authenticated
    * A user already has a Solana wallet
    * If the network call to create the wallet fails

    ### Using the embedded wallet

    Privy supports requesting signatures on messages and transactions from a user's Solana embedded wallet using the `signMessage` RPC. To request a signature, get the Solana embedded wallet provider and call the `signMessage` method on it with a base-64 encoded message to sign. If the signature is computed successfully, `signMessage` will return it as a base64-encoded string.

    ```dart
    abstract class EmbeddedSolanaWalletProvider {
      /**
       * Request a signature on a Base64 encoded message or transaction
       *
       * @param message Base64 encoded message or transaction
       * @return The Base64 encoded computed signature
       */
      Future<Result<String>> signMessage(String message);
    }
    ```

    Example usage:

    ```dart
    // Get the current user
    final user = privy.user;

    // Check if the user is authenticated
    if (user != null) {
      // Check if the user has at least one Solana wallet
      if (user.embeddedSolanaWallets.isNotEmpty) {
        // Retrieve the user's Solana wallet
        final solanaWallet = user.embeddedSolanaWallets.first;

        // Sign a message
        final result = await solanaWallet.provider.signMessage(
          // Base 64 encoded: "Hello! I am the base64 encoded message to be signed."
          "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lY3NhZ2UgdG8gYmUgc2lnbmVkLg=="
        );
      }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/flutter/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow this guide to configure an app client by
  following this guide [here](/basics/get-started/dashboard/app-clients).
</Warning>

## Initializing Privy

First, import the Privy package at the top of your file:

```dart
import 'package:privy_flutter/privy_flutter.dart';
```

Initialize a **Privy** instance with a **`PrivyConfig`** object:

```dart
final privyConfig = PrivyConfig(
  appId: "YOUR_APP_ID",
  appClientId: "YOUR_CLIENT_ID",
  logLevel: PrivyLogLevel.verbose,
);

final privy = Privy(config: privyConfig);
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField body="appId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField body="appClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<ParamField body="logLevel" type="PrivyLogLevel" optional>
  (Optional) Your preferred log level. If no log level is specified, it will default to
  `PrivyLogLevel.NONE`.
</ParamField>

<ParamField body="customAuthConfig" type="LoginWithCustomAuthConfig" optional>
  (Optional) Only use this if you plan to use custom authentication. Find more information
  [here](/authentication/user-authentication/jwt-based-auth).
</ParamField>

<Tip>
  Be sure to maintain a single instance of Privy across the lifetime of your application.
  Initializing multiple instances of Privy will result in unexpected errors.
</Tip>

## Waiting for Privy to be ready

When the Privy SDK is initialized, the user's authentication state will be set to `NotReady` until Privy finishes initialization. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until Privy has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

For your convenience, we've added an async `awaitReady()` function that you can use to wait for Privy to finish initializing:

```dart
Future<void> checkPrivyAuth() async {
  // Show loading state
  setState(() => isLoading = true);

  // Wait for Privy SDK to be ready
  await privy.awaitReady();

  // Check if user is authenticated
  bool isAuthenticated = privy.currentAuthState.isAuthenticated;

  // Update UI based on authentication state
  setState(() {
    isLoading = false;
    isUserAuthenticated = isAuthenticated;
  });
}

// Example usage in a widget
@override
Widget build(BuildContext context) {
  return isLoading
    ? LoadingScreen()
    : (isUserAuthenticated ? AppScreen() : LoginScreen());
}
```


# About Privy
Source: https://docs.privy.io/basics/get-started/about



Privy builds authentication and wallet infrastructure to enable better products built on
crypto rails. Get started in minutes to onboard users with wallets, spin up self-custodial wallets for users,
and securely sign transactions through your app.

Broadly, Privy enables:

**User onboarding** — Privy helps developers onboard users regardless of their experience with crypto-based systems. This means libraries to authenticate them, help them connect their existing wallets and provision self-custodial embedded wallets for them if they don't already have one.

**Wallet infrastructure** — Developers can spin up user-centric wallets from the client or general-purpose wallets from their backend directly to provision and manage cross-chain wallets for any use case.

Privy surfaces both user-centric abstractions enabling you to authenticate users and generate wallets for them, as well as wallet-centric abstractions whereby you can create wallets with assigned authorization keys to control them.

## Engineering principles

At Privy, we believe technical decisions are moral decisions. Below are the principles that guide our engineering decisions.

### Secure

Nothing is more important than your user's security. Privy’s key management system uses distributed key sharding to ensure Privy can never access them and only their rightful owner can. Keys are only ever reconstituted in a secure execution environment at the point of signing a message or sending a transaction.

Privy regularly undergoes rigorous audits to ensure your users control and privacy over their wallets.

### Flexible

Privy gives your application low level access to users and their wallets to support a fully customized product experience. Your application can access Privy's functionality all the way down to the API level, supporting unique wallet flows including provisioning multiple wallets per user.

### Easy to use

Privy has out of the box UIs so your app can support authentication and wallet flows in minutes. These UIs are highly customizable and can even be fully whitelabled. This means access to out of the box funding methods, smart wallet creation pipelines, and more.

### Portable

Privy is compatible with any chain your application operates on. Your application can provision embedded wallets (or link external wallets to a Privy account) on Solana, Ethereum, and all EVM compatible chains. Privy is at the bleeding edge of distributed systems so when you want to build on a new chain, that chain is already supported.

With layers of customizability, Privy supports a wide range of product experiences.

![images/Customization.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Customization.png)


# Create an account
Source: https://docs.privy.io/basics/get-started/account



To get started, visit the [Privy Dashboard](https://dashboard.privy.io) and create an account. You can use the Dashboard to manage your apps, configurations, wallets, users, and more.

While setting up your account, Privy will prompt you to share some basic information about what you're building and your technical stack. These details will be used to set up default configurations for your apps that are optimized for your setup.

![images/Dash.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Dash.png)


# null
Source: https://docs.privy.io/basics/get-started/dashboard/app-clients



App clients allow you to create configure specific settings for different consumers/platforms for your app, including
mobile apps, web apps, and more.

To add a client, go to the [Configuration > App settings page > Clients](https://dashboard.privy.io/apps?setting=clients\&page=settings) tab, and find the "Add app client" button.

<Tip>
  This step is optional if you're using the React SDK. App clients are required for all other mobile
  and non-web platforms to allow your app to interact with the Privy API.
</Tip>

<Tabs>
  <Tab title="Web Environments">
    ### Cookies

    Once you enable HttpOnly cookies on your app and add an app domain, Privy will automatically store a user's token as an HttpOnly cookie on the app domain.
    You can use app clients to enable or disable cookies for different environments.

    [Learn more about cookies here!](/recipes/react/cookies).

    ### Allowed origins

    Each app client can have a different set of allowed origins. You can set allowed origins on your app client.
    Note that if cookies are enabled, the app's domain must be one of the allowed origins.

    [Learn more about allowed origins here!](/recipes/react/allowed-domains).

    ### Session duration

    You can set the session duration for each app client. The session duration is the number of days that a user's session will last before they are logged out.

    ### Apple OAuth Client ID override

    If your application uses Apple as a social login method, you can specify a different client ID depending on which environment your application is running in. In order to use Apple login on any platform other than an iOS native app, the `Client ID` must be the `Identifier` of the [Sign in with Apple service](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple#Create-a-Services-ID).
  </Tab>

  <Tab title="Mobile/Other Environments">
    ### Allowed app identifiers

    To enforce secure usage of your Privy App ID, configure Privy to restrict which mobile apps can use your Privy App ID based on your mobile applications' application identifiers.
    An empty list will mean all requests are denied. You **must** configure at least one application identifier to use the React Native SDK.

    <Tabs>
      <Tab title="React Native">
        We'll use the unique value that identifies your app in the Apple App Store or Google Play Store.

        * For iOS apps, this is the [`bundleIdentifier`](https://docs.expo.dev/versions/latest/config/app/#bundleidentifier).
        * For Android apps, this is the [`package`](https://docs.expo.dev/versions/latest/config/app/#package).

        <CodeGroup>
          ```ts ios {2}
          "iOS": {
              "bundleIdentifier": "com.myorg.app"
          }
          ```

          ```ts Android {2}
          "android": {
              "package": "com.myorg.app"
          }
          ```
        </CodeGroup>

        <Tip>
          If you are using [Expo Go](https://expo.dev/client), add `host.exp.Exponent` to allow requests.
        </Tip>
      </Tab>

      <Tab title="Swift">
        We'll use your project's bundle identifier, which you can find under the "Identity" section of your app's target file.
        It likely has reverse domain format, like "com.myorg.app".
      </Tab>

      <Tab title="Android">
        We'll use your projects application ID from your app's build.gradle file.

        ```kotlin {3}
        android {
            defaultConfig {
                applicationId = "com.myorg.app"
            }
        }
        ```
      </Tab>

      <Tab title="Unity">
        Copy your project's bundle identifier, which you can find under the "Identity" section of your app's target file. It likely has reverse domain format, like "com.myorg.app".
      </Tab>

      <Tab title="Flutter">
        To enforce secure usage of your Privy client ID, register your app's bundle identifier under the app client that was just created.

        1. Copy your iOS project's bundle identifier, which you can find under the "Identity" section of your app's target file.
        2. Copy your Android project's application ID from your app's build.gradle file.
      </Tab>
    </Tabs>

    ### Allowed URL schemes

    To use Privy's social login flows (Apple, Google, etc.), you must also register the [**URL scheme**](https://docs.expo.dev/guides/linking/#custom-url-schemes) (e.g. `myapp://`) for your application with Privy.
    You **must** register at least one URL scheme, and multiple URL schemes can be added for the same Privy App ID.

    An empty list will mean that requests coming from URL schemes other than web defaults (`http` and `https`) will be rejected. You **must** register at least one URL scheme.

    <Tip>A full URL scheme, including path (e.g. `myapp://shire`) will only allow exactly that path. By specifying a scheme only (e.g. `myapp`), all paths will be supported.</Tip>

    <Tabs>
      <Tab title="React Native">
        To register your URL scheme, **copy your application's URL scheme from `app.json` or `app.config.ts`** and register it in the app client settings.

        <Warning>For **development only** if you are using [Expo Go](https://expo.dev/client), enter **`exp`** as the URL scheme for the Expo Go app.</Warning>
      </Tab>

      <Tab title="Swift">
        First, register your URL scheme in your Xcode project. If you're unsure how, you can follow [these steps](https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app#Register-your-URL-scheme).
        Then, use the URL scheme you registered in the app client settings.
      </Tab>

      <Tab title="Unity">
        For non-web platforms, be sure to [setup deeplinking](https://docs.unity3d.com/Manual/deep-linking.html) with your allowed URL scheme.
      </Tab>
    </Tabs>

    <details>
      <summary><b>Why is this required?</b></summary>

      Certain flows within the Privy authentication process require Privy to register allowed callback URLs with third-party service providers. The plainest example of this is social login flows using the OAuth 2.0 Protocol, where Privy must register allowed callback URLs with Google, Apple, and other OAuth login providers.

      Configuring your allowed URL schemes in the Privy Dashboard ensures Privy updates the appropriate settings with these third-party service providers!
    </details>

    ### Session duration

    You can set the session duration for each app client. The session duration is the number of days that a user's session will last before they are logged out.

    ### Apple OAuth Client ID override

    If your application uses Apple as a social login method, you can specify a different client ID depending on which environment your application is running in. In order to use Apple login on an iOS app, the `Client ID` must be the Apple OAuth `bundleId`. All other platforms will require the `Client ID` to be the `Identifier` of the [Sign in with Apple service](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple#Create-a-Services-ID).
  </Tab>
</Tabs>


# Configure login methods
Source: https://docs.privy.io/basics/get-started/dashboard/configure-login-methods



If you plan on using Privy for user onboarding, you'll need to configure the login methods you want to use in your app.
All client SDKs require at least one login method to be enabled - follow the steps below to set up different options for your users!

{/* Setting up basic login methods */}

### Basic login methods

For most apps, we recommend either including alternative login options alongside the following, or enabling [Multi-Factor Authentication](/authentication/user-authentication/mfa). This ensures broad accessibility across all regions and that users can continue accessing their accounts in the event that they lose access to one login method.

<AccordionGroup>
  <Accordion title="Email login">
    Privy enables your users to log in via email or link verified email addresses to their account. You can enable email login and linking via the Login Methods page of the dashboard.

    #### One-Time Password Authentication

    When a user attempts to log in with their email, a one-time password (OTP) will be sent to their email address. This password is valid for 10 minutes and must be entered to complete the authentication process.

    #### Allow/disallow `+` in email addresses

    You can configure whether to allow email addresses containing the + character in the Login Methods page of the dashboard.

    This is useful for users who want to use email aliases.

    <Info>
      Allowing + in email addresses enables users to create multiple accounts using
      email aliases with a single base email address. Consider your application's
      security requirements when configuring this option.
    </Info>
  </Accordion>

  <Accordion title="SMS login">
    Privy enables your users to log in via SMS or link verified phone numbers to their account. You can enable SMS login and linking via the **Login Methods** page of the dashboard.

    #### One-Time Password Authentication

    Similar to email authentication, when a user attempts to log in via SMS, a one-time password (OTP) will be sent to their phone number. This password is valid for 10 minutes and must be entered to complete the authentication process.

    #### Region support

    US- and Canada-only region support is included at no additional cost on all plans (Developer, Pro, and Enterprise).

    You can request access to international SMS via the **Login Methods** page of the dashboard. Once approved, international SMS will automatically be enabled for all apps on your account. International region support is available on the Enterprise plan.

    <Info>
      If you enable SMS login, you may be responsible for additional charges per SMS sent. Underlying
      Twilio network costs will be passed through directly. See Twilio's pricing page
      [here](https://assets.cdn.prod.twilio.com/pricing-csv/SMSPricing.csv).
    </Info>

    #### International region support

    You can request access to international SMS via the **Login Methods** page of the dashboard. By default, Privy supports the following regions for the international SMS plan:

    <details>
      <summary>See a list of supported international regions for SMS</summary>

      | Region         | Region Code |
      | -------------- | ----------- |
      | Argentina      | +54         |
      | Australia      | +61         |
      | Canada         | +1          |
      | Chile          | +56         |
      | Czech Republic | +420        |
      | Germany        | +49         |
      | Hong Kong      | +852        |
      | Hungary        | +36         |
      | Japan          | +81         |
      | New Zealand    | +64         |
      | Portugal       | +351        |
      | Saudi Arabia   | +966        |
      | Singapore      | +65         |
      | South Korea    | +82         |
      | Sweden         | +46         |
      | Taiwan         | +886        |
      | Thailand       | +66         |
      | Turkey         | +90         |
      | United Kingdom | +44         |
      | United States  | +1          |
    </details>

    <Info>
      Region support is subject to change. If you would like to request access to
      additional SMS regions for your account, please reach out to [support@privy.io](mailto:support@privy.io)!
    </Info>
  </Accordion>

  <Accordion title="Wallet login">
    Privy supports blockchain wallet-based authentication methods that allow users to securely connect using their existing wallets.

    #### Supported wallet types

    Currently, Privy supports both **Sign in with Ethereum (SIWE)** and **Sign in with Solana (SIWS)** to authenticate your user into the application with any EVM or SVM compatible wallet.

    <Note>
      We're actively working to expand our support for other networks, such as Bitcoin, Sui, etc.
      Interested in a specific network that isn't currently supported? Contact us at [support@privy.io](mailto:support@privy.io) to
      inquire about additional chain support or to discuss your specific use case requirements.
    </Note>

    #### Restrict Users to a Single Wallet

    You can enable the **`Restrict users to linking a single third-party wallet`** option for your application.

    When enabled, users can only link one wallet to their account, preventing potential confusion or security issues that might arise from multiple linked wallets.
  </Accordion>
</AccordionGroup>

{/* Setting up social login methods */}

### Social providers

Privy allows you to log users into their accounts with existing social accounts, such as Google, Twitter, Farcaster, Telegram, and more! Follow the steps below to enable different social account login methods for your users.

<AccordionGroup>
  <Accordion title="OAuth login methods (Google, Twitter, etc.)">
    ## OAuth login methods

    Privy allows you to log users in with their existing social accounts via the [OAuth 2.0 protocol](https://datatracker.ietf.org/doc/html/rfc6749). Privy currently supports many of the most popular OAuth providers (Google, Twitter, etc.) -- follow the guide below in order to enable these login methods for your application.

    ### Default vs custom credentials

    You can enable OAuth (social) logins quickly by just toggling it on in the Dashboard page. This will use default OAuth credentials that the Privy team has configured with each provider.

    However, best practice is to **configure your own app's OAuth credentials for each account type.**

    **Configuring your own OAuth credentials has many benefits:**

    * Your app has more control over security and resiliency.
    * Your users will see your branding on the social login provider's authentication screen.

    <Tip>
      **Just getting started with Privy?** We recommend you complete your integration in development
      using Privy's default credentials first. Before going to production, you can easily swap in your
      own credentials!
    </Tip>

    ### Configure your OAuth credentials

    Follow this guide to configure your own app's OAuth credentials.

    <Steps>
      <Step title="Setup your OAuth apps for each provider">
        To configure OAuth credentials for a given provider, first create an OAuth app with your chosen provider, following the provider-specific instructions below.

        For all providers, during setup, specify Privy's OAuth callback endpoint as your redirect URI:

        ```
        https://auth.privy.io/api/v1/oauth/callback
        ```
      </Step>

      <Step title="Configure your credentials with Privy">
        <Warning>
          Your custom credentials will go live to all your users as soon as you save them in the dashboard.
          We highly encourage you to test them in a development app before setting them for your production
          app.
        </Warning>

        Navigate to the **Login methods** page on the [Privy dashboard](https://dashboard.privy.io) by selecting your app and clicking Login Methods on the side bar. Click on the socials tab to see the social providers. Enter the OAuth credentials under the drop down for you set up.

        If a provider does not have a drop down, it does not currently support configuring your own credentials.

        <AccordionGroup>
          <Accordion title="Apple">
            #### Apple

            Follow [this](https://developer.apple.com/documentation/signinwithapple/configuring-your-environment-for-sign-in-with-apple) guide to configure your Apple app, service, and key. Note that Apple differs from the rest of the providers in a few ways.

            <Info>
              When creating the Service ID with the associated `Sign in with Apple` feature, be sure to add
              `https://auth.privy.io/api/v1/oauth/callback` as a registered redirect URI for your service.
            </Info>

            You will need to provide the following to Privy upon completion:

            * Team ID: the identifier associated with your Apple developer account.
            * Service ID: this will be used as your `Client ID`. You can find this value listed under the `Identifier` field in the `Service IDs` section:
              {" "}
              <Frame>
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/apple-services-id.png" alt="Apple services id" />
              </Frame>

            <Tip>
              If you are building a mobile app, you will need to use the App ID instead of the Service ID. This
              should be the same as your application's `BundleId` and should be entered as your `Client ID` in
              the privy dashboard. You will still need to create a `Sign in with Apple` service associated with
              this App ID.
            </Tip>

            * Key ID: the identifier associated with your key, found in the `Keys` section of the Apple Developer dashboard.
            * Key: this private key will be generated alongside the `Key ID` and will be used as your `Signing key`. Be sure to copy and paste the entire key with the header and footer into the `Signing key` input.

            <Info>
              If you have an app that has users who have already logged in using Privy's default credentials, we
              do not yet support migrating these users. If you'd like to test using your own credentials in a
              development environment, you can do so by creating a new app and setting your credentials before
              any Apple users log in.
            </Info>
          </Accordion>

          <Accordion title="Discord">
            #### Discord

            Follow [this](https://discord.com/developers/docs/topics/oauth2) guide to register a developer application. After Creating a Discord app, use the OAuth2 settings to generate a `Client Secret` and set `Redirects`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret
          </Accordion>

          <Accordion title="GitHub">
            #### GitHub

            Follow [this](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app) guide to create a GitHub OAuth App. Do not enable device flow. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client secret
          </Accordion>

          <Accordion title="Google">
            #### Google

            Follow [this](https://support.google.com/cloud/answer/6158849?hl=en) guide. When you are creating your app, make sure to specify `Web App` for your app type (it will be treated as a web app in the context of OAuth since you are using Privy). You will need to provide the following to Privy upon completion:

            * Client ID
            * Client secret
          </Accordion>

          <Accordion title="Instagram">
            #### Instagram

            Privy makes use of the Instagram API to allow your users to log in with and connect their Instagram business profiles to a Privy application. Follow [this](https://developers.facebook.com/docs/instagram-platform/instagram-api-with-instagram-login/create-a-meta-app-with-instagram/) guide to create a Facebook Business application with an associated Instagram product, from which you can access the [Instagram API with Instagram Login](https://developers.facebook.com/docs/instagram-platform/instagram-api-with-instagram-login). After creating the Instagram product, use the OAuth2 settings to generate a `Client Secret` and set `Redirects`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret

            Please note that this is the Client ID and Secret associated with the Instagram **Product** associated with your Facebook app, and not the Client ID and secret associated with the Facebook app.

            <Info>
              The Instagram API only allows for login with Instagram
              [business](https://www.facebook.com/business/instagram) or
              [creator](https://help.instagram.com/2358103564437429/?helpref=uf_share) accounts. Personal
              Instagram accounts cannot be used to log into Privy applications.
            </Info>
          </Accordion>

          <Accordion title="LinkedIn">
            #### LinkedIn

            Follow [this](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow?context=linkedin%2Fcontext\&tabs=HTTPS1#step-1-configure-your-application) guide. You will need to provide the following to Privy upon completion:

            * Client ID
            * Primary Client Secret

            <Info>
              If you have an app that has users who have already logged in using Privy's default credentials, we
              do not yet support migrating these users. If you'd like to test using your own credentials in a
              development environment, you can do so by creating a new app and setting your credentials before
              any LinkedIn users log in.
            </Info>
          </Accordion>

          <Accordion title="Spotify">
            #### Spotify

            Follow [this](https://developer.spotify.com/documentation/web-api/concepts/apps) guide to register a developer application. After Creating a Spotify app, use the OAuth2 settings to generate a `Client Secret` and set `Redirects`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret
          </Accordion>

          <Accordion title="TikTok">
            #### TikTok

            Follow the instructions in the 'Prerequisites' section of [this](https://developers.tiktok.com/doc/login-kit-desktop/) guide to register your app and enable LoginKit. When you are creating your app, make sure to specify `Configure for Web` for your app type (it will be treated as a web app in the context of OAuth since you are using Privy).

            TikTok is different from other providers in a few key ways:

            * Your OAuth `client_id` is referred to as `client_key`.
            * You are required to provide a Terms of Service URL and Privacy Policy URL when creating your app.
            * TikTok conducts a review process, and your new credentials will not work until your app is approved and move to `Production` status.

            You will need to provide the following to Privy upon completion:

            * Client key (as described above)
            * Client secret

            <Info>
              If you have an app that has users who have already logged in using Privy's default credentials, we
              do not yet support migrating these users. If you'd like to test using your own credentials in a
              development environment, you can do so by creating a new app and setting your credentials before
              any TikTok users log in.
            </Info>
          </Accordion>

          <Accordion title="X (formerly known as Twitter)">
            #### X (formerly known as Twitter)

            Follow [this](https://developer.twitter.com/en/docs/apps/app-management) guide to create an X (formerly known as Twitter) app. Make sure to configure your app as a "Confidential client". In the application authentication settings this is the `Web app, Automated App or Bot` option for `Type of App`. You will need to provide the following to Privy upon completion:

            * Client ID
            * Client Secret

            The X option for Native App doesn't enforce the use of a Client Secret. This is useful for authenticating with X on your mobile device, without any server involved in the process. You can learn more about Confidential clients [in the official X developer documentation](https://developer.x.com/en/docs/authentication/oauth-2-0/authorization-code).

            <Accordion title="OAuth 1.0a for Twitter">
              #### Setting up Twitter OAuth 1.0a

              To configure [OAuth 1.0a](https://docs.x.com/resources/fundamentals/authentication/oauth-1-0a/api-key-and-secret) for X integration with Privy, first ensure your X developer account has at least Basic tier access, as OAuth 1.0a is only available for this tier and higher.

              Then, configure your app's permissions to match your integration needs (Read or Read and Write).

              Once you have completed setting up your Twitter app to allow for OAuth 1.0a authorization, you will need to provide the following to Privy in the dashboard:

              * Consumer API Key
              * Consumer API Secret

              #### Which OAuth version should I use?

              This guide explains the differences between OAuth 2.0 and OAuth 1.0a to help you determine which is most appropriate for your implementation. You can also read more about the differences between the 2 versions in the [X API docs.](https://docs.x.com/resources/fundamentals/authentication/overview)

              ##### OAuth 2.0

              OAuth 2.0 is the default authentication flow and recommended for most integrations due to its simplicity and ease of setup.

              #### Advantages

              * **Simple Implementation**: This flow is straightforward to set up and implement.
              * **Granular Permission Scopes**: You can specify which permissions to request (e.g., `users.tweet.read`, `users.tweet.write`).

              #### Limitations

              * **API Restriction**: OAuth 2.0 tokens can only access the X v2 API, not the v1.1 API.
              * **App-wide Rate Limits**: Rate limits are enforced across your entire application rather than per user.
                * For example, if the `users/me` endpoint has a rate limit of 450 requests per 15 minutes, and 500 users attempt to authenticate, the last 50 users would be rate-limited and unable to complete the login process.

              ### OAuth 1.0a

              OAuth 1.0a provides a different authentication approach with user-specific access tokens and separate rate limits.

              #### Advantages

              * **User-Specific Rate Limits**: Each user's API usage is rate-limited individually, preventing one user's activity from affecting others.
              * **Broader API Access**: OAuth 1.0a tokens can access both v2 and v1.1 APIs.
              * **Isolated User Authorization**: Returns user-specific access tokens with either read-only or read-write permissions.

              #### Limitations

              * **Less Granular Permissions**: OAuth 1.0a offers less specific permission control—tokens typically grant either full read access, full read-write access, or no authorization.
              * **Higher Tier Requirement**: Only supported for X developer accounts with Basic tier or higher.
              * **Implementation Complexity**: Creating OAuth signatures for API requests requires [additional code and setup](https://docs.x.com/resources/fundamentals/authentication/oauth-1-0a/creating-a-signature) compared to OAuth 2.0.
            </Accordion>
          </Accordion>
        </AccordionGroup>
      </Step>

      <Step title="Configure token return and custom scopes">
        For any OAuth login method for which you configure your own credentials, you are able to have the user's OAuth and Refresh access tokens returned to your application's front by toggling `Return OAuth tokens` and making use of the [useOAuthTokens](/recipes/react/oauth-tokens) hook.

        If you allow for your application to return OAuth tokens to the front-end, you are also able to configure custom scopes for the OAuth authorization flow, so that the OAuth token returned can be authorized to make API requests beyond the standard scope (such as writes, or authorized access to more granular user data).

        <Warning>
          It is important that OAuth and refresh tokens are highly sensitive tokens that should be handled
          and stored in a secure fashion, inaccessible to any other third-party systems. Contact us if you
          have questions or would like guidance on token management best practices.
        </Warning>
      </Step>
    </Steps>

    ### Notes

    * You can update them anytime, with the exception of Apple, LinkedIn, and TikTok.
    * You can set and save credentials for disabled providers. These credentials will be stored and will be used for that provider’s requests once you enable it.
    * If you are experiencing an issue after setting your own credentials, you can roll back to using Privy's default credentials by removing your own from the configuration screen. We only recommend doing this if you are experiencing an issue as moving to use your own credentials is best practice. This will not work for Apple, LinkedIn, or TikTok if you have existing users.

    ### FAQ

    <br />

    #### Can I delete my custom credentials and go back to using the Privy default ones?

    You can remove your credentials from the same page you configured them to go back to using Privy's defaults. We only recommend doing this if you are experiencing an issue with your own credentials as migrating to your own credentials is the best practice.

    For Apple, LinkedIn, and TikTok, once your credentials are in use, you will not be able to reset them due to user migration (see below).

    #### Will migrating to custom credentials impact my users?

    For most providers, the change will be undetectable by end users, other than their seeing your app’s name next time the log in (rather than Privy’s). For Apple, LinkedIn, and TikTok, if your app currently uses Privy's default credentials, we do not support updating to custom credentials. This process requires a migration which we have not yet built.

    #### Can I configure my own custom OAuth provider to work with Privy?

    No, we do not support the use of OAuth providers outside of our supported set. If you'd like to use a different provider, you may be able to through the use of [custom auth](/authentication/user-authentication/jwt-based-auth).
  </Accordion>

  <Accordion title="Telegram login">
    ## Telegram Login

    Follow [this](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) guide to create a telegram bot. After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. You will need to provide the following to Privy via the Privy Dashboard upon completion:

    * Bot token (eg: `1234567890:AzByCxDwEvFuGtHsIr1k2M4o5Q6s7U8w9Y0`)
    * Bot handle (eg: `@MyBot_bot`)

    Note that when configuring Telegram login:

    * Your domain must be configured as your bot's allowed domain.
    * If you have CSP enforcement, you’ll need to update these directives:
      * `script-src` must allow `https://telegram.org` in order to be able to download Telegram's widget script.
      * `frame-src` must allow `https://oauth.telegram.org` in order to be able to render Telegram's widget iframe.

    <Tip>
      To use your app as a Telegram Mini-App in the Telegram web client, add `http://web.telegram.org`
      and `https://web.telegram.org` to your allowed domains in the dashboard
      [Settings](https://dashboard.privy.io?page=settings) page.
    </Tip>

    <Warning>
      Telegram login requires developers to create a Telegram bot with a bot secret. This bot secret controls the Telegram bot and is also used as a symmetric key for authentication. Control over this key enables a developer to sign over authentication data, meaning compromise of this key puts your users (and their accounts) at risk.

      **Securing this symmetric key is essential for the security of all of your app’s Telegram logins.**
    </Warning>

    <Info>
      Since you need to set your bot's allowed domain you'll need to use a tunneling tool for local
      development such as [Cloudflare
      tunnels](https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/) or
      [ngrok](https://ngrok.com/).
    </Info>

    Learn more about Telegram authentication [here](/recipes/dashboard/telegram).
  </Accordion>

  <Accordion title="Farcaster login">
    ## Farcaster login

    [**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

    **Privy enables your users to easily log in to your app using their Farcaster account.** This means you can easily integrate Privy with Farcaster to compose experiences with a user's existing social graph or network.

    #### Automatically link connected wallets on when logging in with Farcaster

    Farcaster accounts generally have associated embedded and verified addresses. By toggling this option, upon logging in with Farcaster, Privy will also add the associated wallet addresses as linked external wallets of the authenticated user.

    <Tip>
      Log in with Farcaster enables log in and read access to a user's Farcaster account but does not provide write access to the account. To enable that, follow this guide to enable writing to [Farcaster using signers](/recipes/farcaster/writes).
    </Tip>
  </Accordion>
</AccordionGroup>

{/* Setting up third party authentication */}

### Third-Party auth provider

If you plan to use Privy with a custom authentication provider like Auth0, Stytch, or Firebase, use the **Third-Party auth** page of the dashboard to register the required information from your provider. Otherwise, skip this guide!

<Info>
  **Don't see the Third-Party Auth page in the Dashboard?** Please request access to this feature
  via the [Plugins](https://dashboard.privy.io/apps?page=integrations\&tab=plugins) tab on the
  Integrations page.
</Info>

<AccordionGroup>
  <Accordion title="JWT Verification Details">
    To verify your user's auth status, Privy requires a verification key to ensure the JWTs received by Privy are valid. You must provide **one** of the following:

    * **JWKS endpoint**: If your provider uses [JWKS](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets) to sign JWTs, provide a JWKS endpoint to allow Privy to get your auth provider's JWT public key.

    ```
    {
      "keys": [
        {
          // JWKS
        }
      ]
    }
    ```

    * **Public Verification Key**: If your provider uses a single key to sign JWTs, provide the corresponding public key certificate used for verification.

    For Auth0, you can follow [these instructions](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates) to get these details.
  </Accordion>

  <Accordion title="JWT ID Claim">
    Enter the claim from your user's JWT that contains the user's unique ID. **In most access tokens and identity tokens, this is the [`sub`](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims) claim.**
  </Accordion>

  <Accordion title="JWT `aud` Claim (Optional)">
    `aud` accepts multiple values. If any of the `aud` values in the JWT are included in the set of allowed `aud` values, the JWT will be successfully verified.

    <Accordion title="Why does Privy need this information?">
      When a user logs into your app, your auth provider issues them an **access** and/or an
      **identity** token to represent their auth status. To provision your user's embedded wallet,
      **Privy must validate this token to authenticate your user.** Privy will verify both the token's
      signature and its expiration time
      ([`exp`](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4) claim).
    </Accordion>
  </Accordion>
</AccordionGroup>


# null
Source: https://docs.privy.io/basics/get-started/dashboard/create-new-app



Before using any Privy SDK, you'll need to create a new app in the Privy Dashboard. This will give you an **app ID** and **app secret** that you'll use to authenticate your app with Privy's APIs.

<Tip>
  We recommend creating a new app for each environment (e.g. development, staging, production) to
  keep your API credentials secure.
</Tip>

## Create an app

Login to the [Privy Dashboard](https://dashboard.privy.io) and create a new app if you haven't already.

## Get API credentials

Navigate to the[ Configuration > App settings > Basics ](https://dashboard.privy.io/apps?page=settings\&tab=basics) tab for your app.

Here you'll find your:

* **App ID**: A unique identifier for your application. It is a public value that can be safely exposed.
* **App Secret**: A secret key used to authenticate API requests. Do **not** expose it outside of your backend server.

<Warning>
  Privy does not store your app secret. Lost app secrets cannot be recovered and must be
  re-generated.
</Warning>

## Configure login methods (optional)

If you plan on using Privy for user onboarding, you'll need to configure the login methods you want to use in your app.
All client SDKs require at least one login method to be enabled - follow the steps [here](/basics/get-started/dashboard/configure-login-methods) to set up different options for your users!

## Enable server wallets (optional)

Navigate to the [**Plugins**](https://dashboard.privy.io/apps?page=integrations\&tab=plugins) tab for your app.

Request access to the **Server Wallets** plugin. Once your request has been approved, when viewing your app in the Dashboard, a **Wallet infrastructure** section will appear in the sidebar.


# Overview
Source: https://docs.privy.io/basics/get-started/dashboard/overview



Once you've set up your account, you can use the Dashboard to manage your **apps** and **team**.

Use the [Applications](https://dashboard.privy.io/account) page of the Dashboard to create and manage new apps for your account. Resources within Privy, including wallets, policies, users and more are scoped to individual apps. Use different apps to segregate development environments, userbases, API credentials, and more.

Use the [Team](https://dashboard.privy.io/team) page of the Dashboard to invite other administrators for your account. All administrators for your account can log in to the Privy Dashboard, access API credentials, and manage apps and configurations.


# Choose your platform
Source: https://docs.privy.io/basics/get-started/platforms



export const Solana = () => {
  return <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/solana.png" noZoom width="18" style={{
    display: 'inline',
    margin: '2px'
  }} />;
};

export const Ethereum = () => {
  return <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/ethereum.png" noZoom width="18" style={{
    display: 'inline',
    margin: '2px'
  }} />;
};

Privy builds flexible wallet and key management infrastructure to power better products built on crypto rails. You can choose to integrate with Privy's **REST API** directly, or leverage our platform-specific **SDKs** to securely provision wallets and manage assets.

![images/Platform2.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Platform2.png)

## REST API

The Privy API is a resource-oriented API designed with RESTful principles. You can use the API to create and use wallets on different blockchains, set granular policies and controls, and manage ownership over different resources.

You can make requests to Privy's API from any environment that supports HTTPS requests and securely storing an API secret. Once you've provisioned wallets from Privy's REST API, you can continue to use and manage those wallets from the REST API or additionally integrate Privy's supported SDKs.

<Info>
  Privy's API have extended support for many blockchain ecosystems. Learn more about the distinct
  tiers of support for each blockchain in our [chain support](/wallets/overview/chains) guide.
</Info>

## SDKs

Privy also offers multiple SDKs for various languages and frameworks. These SDKs wrap interacting with the Privy REST API into interfaces and abstraction that are idiomatic to your framework, streamlining your integration.

Below is a list of Privy's supported SDKs and what platforms they support. If your framework is not supported by the SDKs below, you can always integrate Privy's REST API directly or build a slim client SDK for your framework.

| SDK                                                                  | Description                                                                                                                     | Supported environments                                         |
| -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| [NodeJS](https://www.npmjs.com/package/@privy-io/server-auth)        | A server-side Node SDK that supports securely provisioning wallets, configuring policies and ownership, and managing user data. | Server-side JS runtimes, including Node, Deno, Bun, Edge, etc. |
| [React](https://www.npmjs.com/package/@privy-io/react-auth)          | A client-side React SDK with hooks and components for authenticating users and securely provisioning wallets.                   | Web apps built with React.                                     |
| [React Native](https://www.npmjs.com/package/@privy-io/expo)         | A client-side React Native SDK with hooks and components for authenticating users and securely provisioning wallets.            | Mobile apps (iOS, Android) built with Expo or React Native.    |
| [Swift](https://github.com/privy-io/privy-ios)                       | A client-side Swift SDK with methods for authenticating users and securely provisioning wallets.                                | Mobile apps (iOS) built with Swift.                            |
| [Android](https://mvnrepository.com/artifact/io.privy/kmp-di-public) | A client-side Kotlin SDK with methods for authenticating users and securely provisioning wallets.                               | Mobile apps (Android) built with Kotlin.                       |
| [Flutter](https://pub.dev/packages/privy_flutter)                    | A client-side Flutter SDK with methods for authenticating users and securely provisioning wallets.                              | Mobile apps (iOS, Android) built with Flutter.                 |
| [Unity](mailto:sales@privy.io)                                       | A client-side Unity SDK with methods for authenticating users and securely provisioning wallets.                                | Games built with Unity.                                        |

## Feature Matrix

Check out the matrix below to determine which features are supported in each SDK. As a guide:

* <Ethereum /> - indicates the feature is available on EVM chains.
* <Solana /> - indicates the feature is available on Solana.
* <Ethereum /> <Solana /> - indicates the feature is available on both EVM and Solana.

|                                                                                             | React                   | Expo                    | Swift                   | Android                 | Flutter                 | Unity                  |
| :------------------------------------------------------------------------------------------ | :---------------------- | :---------------------- | :---------------------- | :---------------------- | :---------------------- | :--------------------- |
| **Authentication**                                                                          |                         |                         |                         |                         |                         |                        |
| *Email*                                                                                     | ✅                       | ✅                       | ✅                       | ✅                       | ✅                       | ✅                      |
| *SMS*                                                                                       | ✅                       | ✅                       | ✅                       | ✅                       | ✅                       |                        |
| *OAuth (Google, Apple, Twitter, Github, Discord, LinkedIn, TikTok, Spotify, and Instagram)* | ✅                       | ✅                       | Google, Apple, Twitter  | Google, Apple, Twitter  | Google, Apple, Twitter  | Google, Apple, Discord |
| *SIWE (Sign In with Ethereum)*                                                              | ✅                       | ✅                       | ✅                       |                         |                         |                        |
| *SIWS (Sign In with Solana)*                                                                | ✅                       | ✅                       |                         |                         |                         |                        |
| *Farcaster*                                                                                 | ✅                       | ✅                       |                         |                         |                         |                        |
| *Telegram*                                                                                  | ✅                       |                         |                         |                         |                         |                        |
| *Custom Auth*                                                                               | ✅                       | ✅                       | ✅                       | ✅                       | ✅                       |                        |
| *Passkeys*                                                                                  | ✅                       | ✅                       |                         |                         |                         |                        |
| **Farcaster**                                                                               |                         |                         |                         |                         |                         |                        |
| *SIWF*                                                                                      | ✅                       | ✅                       |                         |                         |                         |                        |
| *Farcaster signers*                                                                         | ✅                       |                         |                         |                         |                         |                        |
| **Embedded Wallets**                                                                        |                         |                         |                         |                         |                         |                        |
| *Creating wallets manually*                                                                 | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum />           |
| *Creating wallet automatically*                                                             | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                         |                         |                         |                        |
| *Pregenerating wallets*                                                                     | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                        |
| *Signing messages and transactions*                                                         | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum />           |
| *Broadcasting transactions*                                                                 | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum />            | <Ethereum />            | <Ethereum />            | <Ethereum />           |
| *Native smart wallets*                                                                      | <Ethereum />            | <Ethereum />            |                         |                         |                         |                        |
| *Automatic recovery*                                                                        | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum />           |
| *User controlled recovery*                                                                  | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                         |                         |                         |                        |
| *Transaction MFA*                                                                           | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                         |                         |                         |                        |
| *Key Export*                                                                                | <Ethereum /> <Solana /> |                         |                         |                         |                         |                        |
| *HD wallets*                                                                                | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> | <Ethereum />            | <Ethereum />            | <Ethereum />            | <Ethereum />           |
| *Delegated actions*                                                                         | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                         |                         |                         |                        |
| *Custom EVM (Ethereum) network support*                                                     | <Ethereum />            | <Ethereum />            |                         |                         |                         |                        |
| *Custom SVM (Solana) network support*                                                       | <Solana />              | <Solana />              |                         |                         |                         |                        |
| **Connectors**                                                                              |                         |                         |                         |                         |                         |                        |
| *External wallets*                                                                          | <Ethereum /> <Solana /> |                         |                         |                         |                         |                        |
| *Wagmi*                                                                                     | <Ethereum />            |                         |                         |                         |                         |                        |
| *Viem*                                                                                      | <Ethereum />            | <Ethereum />            |                         |                         |                         |                        |
| *Ethers*                                                                                    | <Ethereum />            | <Ethereum />            |                         |                         |                         |                        |
| *@solana/web3.js*                                                                           | <Solana />              |                         |                         |                         |                         |                        |
| *web3swift*                                                                                 |                         |                         | <Ethereum />            | <Ethereum />            | <Ethereum />            |                        |
| **Funding**                                                                                 |                         |                         |                         |                         |                         |                        |
| *Transfer or bridge from wallet*                                                            | <Ethereum /> <Solana /> |                         |                         |                         |                         |                        |
| *Transfer from exchange*                                                                    | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                         |                         |                         |                        |
| *Pay with card*                                                                             | <Ethereum /> <Solana /> | <Ethereum /> <Solana /> |                         |                         |                         |                        |

<Info>
  **Is there a particular feature that you'd like support for within a certain SDK?** [Please reach
  out!](https://privy.io/slack)
</Info>


# null
Source: https://docs.privy.io/basics/nodeJS/installation



In a backend JS environment, you can use the **`@privy-io/server-auth`** library to authorize requests and manage your application from your server. This library includes helpful utilities around verifying access tokens issued by Privy and interacting with Privy's API to query and import users, create wallets, manage invite lists, and more.

Install the Privy Server SDK using your package manager of choice:

<CodeGroup>
  ```bash npm
  npm install @privy-io/server-auth@latest
  ```

  ```bash pnpm
  pnpm install @privy-io/server-auth@latest
  ```

  ```bash yarn
  yarn add @privy-io/server-auth@latest
  ```
</CodeGroup>


# Quickstart
Source: https://docs.privy.io/basics/nodeJS/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your NodeJS app

## 0. Prerequisites

This guide assumes you have followed the [Server SDK setup guide](/basics/nodeJS/setup) to get a Privy client instance, `privy`. If you have not already set up your Server SDK environment, go through those steps now.

## 1. Creating a wallet

First, we will create a server wallet. You will use this wallet's `id` in future calls to sign messages and send transactions.

<Tabs>
  <Tab title="Ethereum">
    ```tsx
    const {id, address, chainType} = await privy.walletApi.create({chainType: 'ethereum'});
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx
    const {id, address, chainType} = await privy.walletApi.create({chainType: 'solana'});
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/wallets/create/from-my-server) about creating wallets.</Tip>

## 2. Signing a message

Next, we'll sign a plaintext message with the server wallet using the `signMessage` method. Make sure to specify your wallet ID (not address) from creation in the input.

<Tabs>
  <Tab title="Ethereum">
    ```tsx
    const {signature, encoding} = await privy.walletApi.ethereum.signMessage({
      walletId: id,
      message: 'Hello server wallets!'
    });
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx
    // Get the signature and encoding from the response
    const {signature, encoding} = await privy.walletApi.solana.signMessage({
      walletId: 'insert-wallet-id',
      message: 'Hello world'
    });
    ```
  </Tab>
</Tabs>

<Tip>[Learn more](/wallets/using-wallets/ethereum/sign-a-message) about signing messages.</Tip>

## 3. Sending transactions

<Info>
  In order to send a transaction, your wallet must have some funds to pay for gas. You can use a
  testnet [faucet](https://console.optimism.io/faucet) to test transacting on a testnet (e.g. Base
  Sepolia) or send funds to the wallet on the network of your choice.
</Info>

To send a transaction from your wallet, use the `sendTransaction` method. It will populate missing network-related values (gas limit, gas fee values, nonce, type), sign your transaction, broadcast it to the network, and return the transaction hash to you.

In the request, make sure to specify your wallet `id` from your wallet creation above, as well as the `caip2` chain ID and `chainId` values for the network you want to transact on. Also, input your recipient or smart contract address in the `to` field.

<Tabs>
  <Tab title="Ethereum">
    ```tsx
    const data = await privy.walletApi.ethereum.sendTransaction({
      walletId: id,
      caip2: 'eip155:84532',
      transaction: {
        to: '0xyourRecipientAddress',
        value: '0x2386F26FC10000',
        chainId: 84532
      }
    });

    const {hash} = data;
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx
    // Get the transaction hash from the response
    const {hash} = await privy.walletApi.solana.signAndSendTransaction({
      walletId: wallet.id,
      caip2: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
      transaction: yourSolanaTransaction
    });
    ```
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions.
</Tip>

<Tip>
  If you’re interested in more control, you can prepare and broadcast the transaction yourself, and
  simply use `eth_signTransaction` ([EVM](/wallets/using-wallets/ethereum/sign-a-transaction)) and
  `signTransaction` ([Solana](/wallets/using-wallets/solana/sign-a-transaction)) RPCs to sign the
  transaction with a server wallet.
</Tip>

## Next steps & advanced topics

* For an additional layer of security, you can choose to sign your requests with [authorization keys](/controls/authorization-keys/overview).
* To restrict what wallets can do, you can set up [policies](/controls/policies/overview).
* To prevent double sending the same transaction, take a look at our support for [idempotency](/api-reference/idempotency-keys) keys.
* If you want to require multiple parties to sign off before sending a transaction for a wallet, you can accomplish this through the use of [quorum approvals](/controls/quorum-approvals/overview).


# null
Source: https://docs.privy.io/basics/nodeJS/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID and app secret](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

## Getting the `PrivyClient`

Import the **`PrivyClient`** class and create an instance of it, passing the Privy **app ID** and **app secret** as parameters.

Optionally, if you have an [authorization key](/controls/authorization-keys/overview) for a wallet, you can pass that on initialization as well.

```tsx
import {PrivyClient} from '@privy-io/server-auth';
...
const privy = new PrivyClient('insert-your-app-id', 'insert-your-app-secret', {
  walletApi: {
    authorizationPrivateKey: 'insert-your-authorization-private-key-from-the-dashboard'
  }
});
```

This `privy` **`PrivyClient`** is now your entry point to manage Privy from your server. With the `PrivyClient` you can interact with wallets with methods for creating wallets, signing and sending transactions. You can also manage users with methods for getting a user object, verifying an auth token, and importing new users.

## Rate limits

Privy rate limits REST API endpoints that you may call from your server. If you suspect your team will require an increased rate limit, please reach out to support!

<Tip>
  Learn more about optimizing your setup in our [optimizing](/recipes/dashboard/optimizing) guide!
</Tip>


# null
Source: https://docs.privy.io/basics/react-native/advanced/automatic-wallet-creation



If your app uses embedded wallets, you can configure Privy to create wallets **automatically** for your users as part of their **login** flow.

<Tabs>
  <Tab title="Ethereum">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embedded.solana.createOnLogin`** property of your `PrivyProvider`:

    ```tsx
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embedded: {
                ethereum: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>

  <Tab title="Solana">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embedded.solana.createOnLogin`** property of your `PrivyProvider`:

    ```tsx
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embedded: {
                solana: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>
</Tabs>


# Configuring EVM networks
Source: https://docs.privy.io/basics/react-native/advanced/configure-evm-networks



Read below to learn how to configure supported EVM networks for the Expo SDK and how to switch the embedded wallet's current network.

## Configuring networks

**Privy embedded wallets can support *any* EVM-compatible chain**. You can configure EVM networks for Privy via the **`supportedChains`** property of the **`PrivyProvider`** component, per the instructions below.

### Configuring `viem`-supported networks

<Tip>
  If your desired EVM network is supported by the popular [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains) package, continue with the instructions below. A full list of the package's supported networks is available [here](https://github.com/wevm/viem/blob/main/src/chains/index.ts).

  Otherwise, skip to the [**Other Networks**](#other-networks) section.
</Tip>

To configure [**`viem`**](https://viem.sh/docs/chains/introduction#chains)-supported networks for Privy, **first, install the [`viem`](https://viem.sh/docs/installation#installation) package**. This package contains JSON representations of several EVM networks, which will be used to initialize the Privy SDK.

```sh
npm i viem
```

Next, **import your required chains from the [`viem/chains`](https://viem.sh/docs/chains/introduction#chains) package**:

```tsx
// Replace this with any of the networks listed at https://viem.sh/docs/chains/introduction#chains
import {base, baseGoerli, mainnet, goerli, polygon, polygonMumbai} from 'viem/chains';
```

**Lastly, configure the `supportedChains` prop of your `PrivyProvider` with an array including your required networks.**:

```tsx
<PrivyProvider
  appId="your-privy-app-id"
  supportedChains={[base, baseGoerli, mainnet, goerli, polygon, polygonMumbai]}
>
  {/* your app's content */}
</PrivyProvider>
```

### Other Networks

<Tip>
  If your desired EVM network is **not** supported by
  [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains), you can still use Privy with
  it per the steps below!
</Tip>

First, **import `viem` and use the package's [`defineChain`](https://viem.sh/docs/chains/introduction#custom-chains) method to build a JSON representation of your desired network.**

```tsx
import {defineChain} from 'viem';

export const myCustomChain = defineChain({
  id: 123456789, // Replace this with your chain's ID
  name: 'My Custom Chain',
  network: 'my-custom-chain',
  nativeCurrency: {
    decimals: 18, // Replace this with the number of decimals for your chain's native token
    name: 'My Native Currency Name',
    symbol: 'My Native Currency Symbol'
  },
  rpcUrls: {
    default: {
      http: ['https://my-custom-chain-https-rpc'],
      webSocket: ['wss://my-custom-chain-websocket-rpc']
    }
  },
  blockExplorers: {
    default: {name: 'Explorer', url: 'my-custom-chain-block-explorer'}
  }
});
```

At minimum, you must provide the network's name and chain ID, native currency, RPC URLs, and a blockexplorer URL.

Then, **pass the returned object (`myCustomChain` in the example above) to the `supportedChains` array of the `PrivyProvider`,** like above.

## Overriding a chain's RPC provider

**By default, transactions from the embedded wallet will be sent using Privy's default RPC providers.** Please note that Privy's default providers are subject to rate limits; these limits are sufficiently generous for developing your integration and moderate amounts of app usage.

**As your app's usage scales, we recommend that you setup your own RPC providers** (with [Alchemy](https://www.alchemy.com/), [QuickNode](https://www.quicknode.com/), [Blast](https://blastapi.io/), etc.) and configure Privy to use these providers per the instructions below. Setting up your own providers gives you maximum control over RPC throughput and rate limits, and offers you much more visibility into RPC analytics and common errors.

To configure Privy to use a custom RPC provider, first, **import the chain you want to override, and import the helper function `addRpcUrlOverrideToChain` from `@privy-io/chains` to override the RPC provider**

```ts
import {mainnet} from 'viem/chains';

import {addRpcUrlOverrideToChain} from '@privy-io/chains';

const mainnetOverride = addRpcUrlOverrideToChain(mainnet, INSERT_CUSTOM_RPC_URL);
```

Now, you can **add the chain returned by `addRpcUrlOverrideToChain` (e.g. `mainnetOverride`) to the `supportedChains` config option** like before.

## Default Configuration

If neither **`defaultChain`** nor **`supportedChains`** is explicitly set for your app, Privy will automatically default to the following list of EVM-compatible networks:

<Tip>
  **Want to use a chain not listed below?** Configure Privy with any EVM-compatible chain, like
  Berachain, Monad, or Story per the guidance
  [here](/basics/react/advanced/configuring-evm-networks#configuration).
</Tip>

<Expandable title="default networks">
  | Network           | [Chain ID](https://chainlist.org/) | Supported? | Privy RPC |
  | ----------------- | ---------------------------------- | ---------- | --------- |
  | Arbitrum          | 42161                              | ✅          | ✅         |
  | Arbitrum Sepolia  | 421614                             | ✅          | ✅         |
  | Avalanche C-Chain | 43114                              | ✅          |           |
  | Avalanche Fuji    | 43113                              | ✅          |           |
  | Base              | 8453                               | ✅          | ✅         |
  | Base Sepolia      | 84532                              | ✅          | ✅         |
  | Berachain Artio   | 80085                              | ✅          |           |
  | Celo              | 42220                              | ✅          |           |
  | Celo Alfajores    | 44787                              | ✅          |           |
  | Ethereum          | 1                                  | ✅          | ✅         |
  | Ethereum Sepolia  | 11155111                           | ✅          | ✅         |
  | Holesky           | 17000                              | ✅          |           |
  | Holesky Redstone  | 17001                              | ✅          |           |
  | Holesky Garnet    | 17069                              | ✅          |           |
  | Lukso             | 42                                 | ✅          |           |
  | Linea             | 59144                              | ✅          |           |
  | Linea Testnet     | 59140                              | ✅          |           |
  | Optimism          | 10                                 | ✅          | ✅         |
  | Optimism Sepolia  | 11155420                           | ✅          | ✅         |
  | Polygon           | 137                                | ✅          | ✅         |
  | Polygon Amoy      | 80002                              | ✅          | ✅         |
  | Redstone          | 690                                | ✅          |           |
  | Zora              | 7777777                            | ✅          |           |
  | Zora Sepolia      | 999999999                          | ✅          |           |
</Expandable>


# null
Source: https://docs.privy.io/basics/react-native/advanced/configuring-appearance



You can customize the theme and appearance of Privy's default UIs in your app.

## Brand color

Privy's default UIs for Expo support theming by using the **brand color** you have [set in the dashboard](/recipes/dashboard/customization#brand-color), or by setting a value specific to your mobile application by using the `PrivyElements` `config` prop.

If you want to set the value manually, instead of automatically through the dashboard, you should set the `accentColor` config option on the `PrivyElements` component.

```tsx
import {PrivyElements} from '@privy-io/expo/ui';

export default function RootLayout() {
  return (
    <>
      {/* Your app's content */}
      <PrivyElements config={{appearance: {accentColor: '#00AF55'}}} />
    </>
  );
}
```

## Color scheme (light and dark mode)

Privy's default UIs also support adapting the color scheme to both light and dark mode, via the `colorScheme` config option.

You can set a fixed value if that best matches the experience and design of your application, or you can use React Native's own `useColorScheme` hook to get a dynamic value and adapt to your user's settings.

```tsx
import {useColorScheme} from 'react-native';

import {PrivyElements} from '@privy-io/expo/ui';

export default function RootLayout() {
  const colorScheme = useColorScheme();
  return (
    <>
      {/* Your app's content */}
      <PrivyElements config={{appearance: {colorScheme}}} />
    </>
  );
}
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/custom-build-configuration



Certain features may require custom build configurations.

In particular, this guide ensures that your application satisfies the following requirements for integrating:

* uses an [expo development build](https://docs.expo.dev/develop/development-builds/introduction/).
* has a custom [`metro.config.js` file](https://docs.expo.dev/guides/customizing-metro/#customizing) to customize the Metro bundler settings
* enables [package exports for the Metro bundler:](https://reactnative.dev/blog/2023/06/21/package-exports-support#for-app-developers)
* uses the `bundler` setting for [Typescript's `moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution)

To enable package exports for metro, update your `metro.config.js` like so:

```ts
//...other config logic

// Enable package exports for select libraries
...
const resolveRequestWithPackageExports = (context, moduleName, platform) => {
  if (moduleName.startsWith('@privy-io/')) {
    const ctx = {
      ...context,
      unstable_enablePackageExports: true,
    };
    return ctx.resolveRequest(ctx, moduleName, platform);
  }

  return context.resolveRequest(context, moduleName, platform);
};

config.resolver.resolveRequest = resolveRequestWithPackageExports;

...
module.exports = config;
```

Also configure your `tsconfig.json` like so:

```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    // Allows us to use conditional/deep imports on published packages
    "moduleResolution": "Bundler"
  }
}
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/customizing-session-persistence



**By default, the Privy Expo SDK makes use of [`expo-secure-store`](https://docs.expo.dev/versions/latest/sdk/securestore/) package to persist sessions after your app is closed.**

### Custom storage adapters

If you'd rather persist sessions in a different way, you can easily build an adapter and provide it as an optional prop to the **`PrivyProvider`** component:

```tsx
import MyStorageProvider from 'my-storage-provider';

import {PrivyProvider} from '@privy-io/expo';
import type {Storage} from '@privy-io/js-sdk-core';

import AppContent from './AppContent';

const myStorage: Storage = {
  get: (key) => MyStorageProvider.getItem(key),
  put: (key, val) => MyStorageProvider.setItem(key, val),
  del: (key) => MyStorageProvider.deleteItem(key),
  getKeys: () => MyStorageProvider.allKeys()
};

export function App() {
  return (
    <PrivyProvider appId={'my-app-id'} storage={myStorage}>
      <AppContent />
    </PrivyProvider>
  );
}
```

### Customizing the access policy for `expo-secure-store`

The default **`expo-secure-store`** adapter setup requires the device to be unlocked at least once before accessing storage, which allows you to perform background operations, but still require the user to be in the loop after a device restart. Your app can customize the storage adapter, although be aware that this can have unexpected effects on Privy authentication state. Only do so if you are fully aware of the implications the changes you make will have.

Create a [**Custom Storage Adapter**](#custom-storage-adapters) that specifies the desired value for [**`keychainAccessible`**](https://docs.expo.dev/versions/latest/sdk/securestore/#constants) as a [**configuration option**](https://docs.expo.dev/versions/latest/sdk/securestore/#securestoreoptions) for each method.

```tsx
import * as SecureStore from 'expo-secure-store';

import type {Storage} from '@privy-io/js-sdk-core';

// We can require the user to set a passcode on the device to allow accessing storage, so Privy
// state is inaccessible if the user hasn't set or removes a passcode.
export const MyRestrictiveSecureStorageAdapter: Storage = {
  get(key) {
    return SecureStore.getItemAsync(key, {
      keychainAccessible: SecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY
    });
  },
  put(key, val) {
    return SecureStore.setItemAsync(key, val as string, {
      keychainAccessible: SecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY
    });
  },
  del(key) {
    return SecureStore.deleteItemAsync(key, {
      keychainAccessible: SecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY
    });
  },
  getKeys: async () => []
};
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/setup-apple-login



Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) when running on iOS.
Apple is an OAuth2.0 compliant authentication provider, but requires a specific implementation of Apple sign-in within iOS apps.

<Tip>
  Prior to integrating Sign in with Apple, make sure you configure [Apple as a login method in your
  dashboard.](/basics/get-started/dashboard/configure-login-methods) Make sure your app's `Bundle
    ID` rather than the `Service ID`, is configured as the `Client ID` within the **Privy Dashboard**.
</Tip>

### Installing the Apple Authentication module

```sh
npx expo install expo-apple-authentication
```

You can configure `expo-apple-authentication` using its built-in [config plugin](https://docs.expo.dev/versions/latest/sdk/apple-authentication/#configuration-in-app-config) if you use config plugins.

In your `app.json` config file:

* Set the `ios.usesAppleSignIn` property to `true`.
* Add `"expo-apple-authentication"` to the `plugins` array.

```json
{
  "expo": {
    "ios": {
      "usesAppleSignIn": true
    },
    "plugins": ["expo-apple-authentication"]
  }
}
```

## Initializing the login flow

With Privy's Expo SDK, you can use `'apple'` just as any other [OAuth provider](/authentication/user-authentication/login-methods/oauth).

```tsx
import {useLoginWithOAuth} from '@privy-io/expo';

export function LoginScreen() {
  const {login} = useLoginWithOAuth();

  return (
    <View>
      <Button onPress={() => login({provider: 'apple'})}>Login with Apple</Button>
    </View>
  );
}
```

Refer to our [OAuth login](/authentication/user-authentication/login-methods/oauth) guide for more information on login with OAuth providers.

## Using the web based flow instead of the native flow

<Tip>
  Privy will **automatically** fallback to the web-based flow on Android devices, where native Apple
  sign-in isn't supported.
</Tip>

For the best possible user experience, we recommend using the native "Sign in with Apple" flow as described above. However, if you are unable to use the native flow, or prefer not to, you can use the web based flow instead:

```tsx
import {useLoginWithOAuth} from '@privy-io/expo';

export function LoginScreen() {
  const {login} = useLoginWithOAuth();

  return (
    <View style={styles.container}>
      <Button onPress={() => login({provider: 'apple', isLegacyAppleIosBehaviorEnabled: true})}>
        Login with Apple
      </Button>
    </View>
  );
}
```


# null
Source: https://docs.privy.io/basics/react-native/advanced/setup-passkeys



<Tip>
  To see an example application that has the Privy Expo SDK configured with passkeys, check out our
  [Expo starter repo!](https://github.com/privy-io/expo-starter)
</Tip>

## 0. Ensure you have configured a custom build configuration

<Info>
  If you have not already configured a custom build configuration, follow the [custom build
  configuration guide](/basics/react-native/advanced/custom-build-configuration).
</Info>

## 1. Install additional peer dependencies

```sh
npx expo install react-native-passkeys
```

## 2. Update native app settings

<Tabs>
  <Tab title="iOS">
    Passkeys require that you associate a website with your app. To do so, you need to have the associated domain file on your website and the appropriate entitlement in your app.

    #### 1. Apple App Site Association

    * Create a `JSON` file with *at least* the following content

    ```json
    {
      "webcredentials": {
        "apps": ["<teamID>.<bundleID>"]
      }
    }
    ```

    * Make the file accessible on your website at the following path

    ```txt
    https://<your_domain>/.well-known/apple-app-site-association
    ```

    **Make sure to use your `teamID` and `bundleID` in the file hosted on your website.**

    For more information about supporting associated domains [see Apple's documentation](https://developer.apple.com/documentation/xcode/supporting-associated-domains).

    #### 2. App configuration

    Next, update your `app.json` (or `app.config.ts`) to include the `associatedDomains` and `deploymentTarget` like so:

    ```json
    {
      "expo": {
        "ios": {
          "associatedDomains": ["webcredentials:<your_domain>"]
        }
        "plugins": [
          [
            "expo-build-properties",
            {
              "ios": {
                "deploymentTarget": "17.5"
              }
            }
          ]
        ]
      }
    }
    ```

    #### 3. Build

    Lastly, build your app!

    ```sh
    npx expo prebuild -p ios
    npx expo run:ios
    ```
  </Tab>

  <Tab title="Android">
    To enable passkey support for your Android app, associate your app with a website that your app owns.

    #### 1. Digital Asset Links

    * Create a `JSON` file with *at least* the following content

    ```json
    [
      {
        "relation": ["delegate_permission/common.handle_all_urls"],
        "target": {
          "namespace": "android_app",
          "package_name": "<package_name>",
          "sha256_cert_fingerprints": ["<sha256_cert_fingerprint>"]
        }
      }
    ]
    ```

    * Make the file accessible on your website at the following path

    ```txt
    https://<your_domain>/.well-known/assetlinks.json
    ```

    **Make sure to use your `package_name` and `sha256_cert_fingerprint` in the file hosted on your website.**

    For more information on obtaining the `sha256_cert_fingerprint` for your app, see the [signing report documentation](https://developer.android.com/studio/publish/app-signing#signing_report). For more information about generally supporting Digital Asset Links [see Google's documentation](https://developer.android.com/training/sign-in/passkeys#add-support-dal).

    #### 2. Dashboard

    You will also need to add your `sha256_cert_fingerprint` to the allowed Android key hashes list in the `Settings` tab of the Privy dashboard.

    #### 3. App configuration

    Next, update your `app.json` (or `app.config.ts`) to look like:

    ```json
    {
      "expo": {
        "plugins": [
          [
            "expo-build-properties",
            {
              "android": {
                "compileSdkVersion": 34
              }
            }
          ]
        ]
      }
    }
    ```

    #### 4. Build

    Lastly, build your app!

    ```sh
    npx expo prebuild -p android
    npx expo run:android
    ```
  </Tab>
</Tabs>


# Setting up Privy UIs
Source: https://docs.privy.io/basics/react-native/advanced/setup-privyelements



Before integrating Privy's default UIs into your app, you must first ensure the necessary components and fonts are installed.

## Custom Build Configuration

Using Privy UIs requires a custom build configuration for your React Native application. This is necessary to ensure that the Privy SDK can properly interact with the native components and libraries it relies on.

For detailed instructions, see the [Custom Build Configuration](/basics/react-native/advanced/custom-build-configuration) guide.

## Install Peer Dependencies

First, install the necessary peer dependencies:

```bash
npx expo install react-native-svg expo-clipboard react-native-qrcode-styled react-native-safe-area-context viem
```

## Fonts

### Install Font Packages

Install the following packages:

```bash
npx expo install expo-font @expo-google-fonts/inter
```

### Load Fonts

<Tabs>
  <Tab title="Using expo/router">
    Load the necessary fonts in your app's root layout (typically in `app/_layout.tsx`):

    ```tsx
    import {Inter_400Regular, Inter_500Medium, Inter_600SemiBold} from '@expo-google-fonts/inter';
    import {useFonts} from 'expo-font';

    export default function RootLayout() {
      useFonts({
        Inter_400Regular,
        Inter_500Medium,
        Inter_600SemiBold,
      });

      // ...
    }
    ```
  </Tab>

  <Tab title="Without expo/router">
    Load the necessary fonts in your app's root component (typically in `App.tsx`):

    ```tsx
    import {Inter_400Regular, Inter_500Medium, Inter_600SemiBold} from '@expo-google-fonts/inter';
    import {useFonts} from 'expo-font';

    export default function App() {
      useFonts({
        Inter_400Regular,
        Inter_500Medium,
        Inter_600SemiBold,
      });

      // ...
    }
    ```
  </Tab>
</Tabs>

## PrivyElements Component

Privy's default UIs in the React Native SDK are powered by the `PrivyElements` modal component.

<Warning>Only mount `PrivyElements` once in your app.</Warning>

```tsx
import {PrivyElements} from '@privy-io/expo/ui';

export default function RootLayout() {
  return (
    <>
      {/* Your app's content */}
      <PrivyElements />
    </>
  );
}
```


# null
Source: https://docs.privy.io/basics/react-native/installation



## Requirements

* A React Native project using the latest version
* iOS and Android platform support (Web is not supported)

## Installation

### Core Dependencies

Install the Privy React Native SDK and its peer dependencies:

```bash
npx expo install expo-apple-authentication expo-application expo-crypto expo-linking expo-secure-store expo-web-browser react-native-passkeys react-native-webview @privy-io/expo-native-extensions @privy-io/expo
```

### Required Polyfills

Install the necessary polyfills:

```bash
npm i fast-text-encoding react-native-get-random-values @ethersproject/shims
```

<Tip>
  If your app uses the Expo [bare workflow](https://docs.expo.dev/bare/) ("React Native without Expo"), also run:

  ```bash
  npx pod-install
  ```
</Tip>

### Configure Polyfills

<Tabs>
  <Tab title="Using expo/router">
    Create an `entrypoint.js` file and update your `package.json`:

    ```js entrypoint.js
    // Import required polyfills first
    import 'fast-text-encoding';
    import 'react-native-get-random-values';
    import '@ethersproject/shims';
    // Then import the expo router
    import 'expo-router/entry';
    ```

    ```json package.json
    {
      "name": "<your app name>",
      "main": "entrypoint.js"
    }
    ```
  </Tab>

  <Tab title="Without expo/router">
    Import the polyfills at the root of your application:

    ```jsx
    // Import required polyfills first
    import 'fast-text-encoding';
    import 'react-native-get-random-values';
    import '@ethersproject/shims';

    // Other imports
    ...

    // Your app's root component
    export default function App() {
      ...
    }
    ```
  </Tab>
</Tabs>

<Note>
  If you're using the `@solana/web3.js` package, install the buffer dependency:

  ```bash
  npm i buffer
  ```

  And add this code after importing `react-native-get-random-values`:

  ```js
  import 'react-native-get-random-values';
  import {Buffer} from 'buffer';
  global.Buffer = Buffer;
  ```
</Note>


# Quickstart
Source: https://docs.privy.io/basics/react-native/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your React Native app

## 0. Prerequisites

This guide assumes that you have completed the [setup](/basics/react-native/setup) guide.

## 1. Enable a user to log in via email

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

**To authenticate a user via their email address, use the React Native SDK's `useLoginWithEmail` hook.**

```tsx
import {useLoginWithEmail} from '@privy-io/expo';
...
const {sendCode, loginWithCode} = useLoginWithEmail();
```

Ensure that this hook is mounted in a component that is wrapped by the [PrivyProvider](/basics/react-native/setup#initializing-privy).
You can use the returned methods **`sendCode`** and **`loginWithCode`** to authenticate your user per the instructions below.

### Send an OTP

Send a one-time passcode (OTP) to the user's **email** by passing their email address to the **`sendCode`** method returned from `useLoginWithEmail`:

```tsx
import {useLoginWithEmail} from '@privy-io/expo';

export function LoginScreen() {
  const [email, setEmail] = useState('');
  const [codeSent, setCodeSent] = useState(false);

  const {sendCode} = useLoginWithEmail();

  return (
    <View>
      <Text>Login</Text>

      {/* prettier-ignore */}
      <TextInput
        value={email}
        onChangeText={setEmail}
        placeholder="Email"
        inputMode="email"
      />

      {!codeSent ? (
        <Button
          onPress={async () => {
            await sendCode({email});
            setCodeSent(true);
          }}
        >
          Send Code
        </Button>
      ) : (
        {/* prettier-ignore */}
        <Button onPress={() => loginWithCode({code: code, email})}>
          Login
        </Button>
      )}
    </View>
  );
}
```

## 2. Create an embedded wallet for the user

Your app can configure Privy to [**automatically** create wallets](/basics/react-native/advanced/automatic-wallet-creation) for your users as part of their **login** flow. The embedded wallet will be generated and linked to the user object upon authentication.

Alternatively your app can [**manually** create wallets](/wallets/wallets/create/from-my-client) for users when required.

<Info>Privy can provision wallets for your users on both **Ethereum** and **Solana**.</Info>

## 3. Send and sign transactions using the embedded wallet

To request signatures and transactions from a wallet, you must first get an EIP1193 providerfor the wallet.

```ts
// Get an EIP-1193 Provider
const provider = await wallet.getProvider();
```

Once you have the embedded wallet's EIP-1193 provider, you can use the provider's **`request`** method to send JSON-RPC requests that request signatures and transactions from the wallet!

The **`request`** method accepts an object with the fields:

* **`method`** (required): the name of the JSON-RPC method as a string (e.g. **`personal_sign`** or **`eth_sendTransaction`**)
* **`params`** (optional): an array of arguments for the JSON-RPC method specified by **`method`**

<Tabs>
  <Tab title="Example signature">
    ```tsx
    // Get address
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    // Sign message
    const message = 'I hereby vote for foobar';
    const signature = await provider.request({
      method: 'personal_sign',
      params: [message, accounts[0]]
    });
    ```
  </Tab>

  <Tab title="Example transaction">
    ```tsx
    // Get address
    // Get an EIP-1193 Provider
    const provider = await wallet.getProvider();
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    // Send transaction (will be signed and populated)
    const response = await provider.request({
      method: 'eth_sendTransaction',
      params: [
        {
          from: accounts[0],
          to: '0x0000000000000000000000000000000000000000',
          value: '1'
        }
      ]
    });
    ```
  </Tab>
</Tabs>

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions with
  the embedded wallet. Privy enables you to take many actions on the embedded wallet, including
  [sign a message](/wallets/using-wallets/ethereum/sign-a-message), [sign typed
  data](/wallets/using-wallets/ethereum/sign-typed-data), and [sign a
  transaction](/wallets/using-wallets/ethereum/sign-a-transaction).
</Tip>

Congratulations, you have successfully been able to integrate Privy authentication and wallet into your React Native application!


# null
Source: https://docs.privy.io/basics/react-native/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow this guide to configure an app client by
  following this guide [here](/basics/get-started/dashboard/app-clients).
</Warning>

## Initializing Privy

In your project, **import the `PrivyProvider` component and wrap your app with it**.
The `PrivyProvider` must wrap *any* component or page that will use the Privy React Native SDK, and it is generally recommended to render it as close to the root of your application as possible.

<Tabs>
  <Tab title="Using expo/router">
    Wrap your app with the `PrivyProvider` in the `app/_layout.tsx` file.

    ```tsx
    import {PrivyProvider} from '@privy-io/expo';

    import {Slot} from 'expo-router';

    export default function RootLayout() {
      return (
        <PrivyProvider appId="your-privy-app-id" clientId="your-privy-app-client-id">
          <Slot />
        </PrivyProvider>
      );
    }
    ```

    <Accordion title="Protect routes with `AuthBoundary`">
      ### Protect routes with `AuthBoundary`

      Setting up `PrivyProvider` is all you need to use the Privy React Native SDK throughout your app! But if you want to protect certain routes, we recommend you do so by using the `AuthBoundary` component, as follows:

      Start by setting up a [route group](https://docs.expo.dev/router/layouts/#groups), like `(app)/`, under your `app/` directory. Routes placed under this group will be protected by the `AuthBoundary` component, so only authenticated users can access them.

      ```text
      app
      ├── (app)
      │   ├── _layout.tsx
      │   └── index.tsx
      ├── _layout.tsx
      └── sign-in.tsx
      ```

      In the `(app)/_layout.tsx` file, wrap the `Stack` component with the `AuthBoundary` component:

      ```tsx
      import {Stack, Redirect} from 'expo-router';

      import {AuthBoundary} from '@privy-io/expo';

      export default function AppLayout() {
        return (
          <AuthBoundary
            loading={<FullScreenLoader />}
            error={(error) => <ErrorScreen error={error} />}
            unauthenticated={<Redirect href="/sign-in" />}
          >
            <Stack />
          </AuthBoundary>
        );
      }
      ```

      You must provide the following props to `AuthBoundary`:

      * `loading` and `error` are both custom components that you can define to show specific UIs during the loading and error states.
      * On `unauthenticated`, you should redirect the user to the sign in page, as defined above!

      If you want more details, or wish to take a manual approach without using `AuthBoundary`, take a look at [Expo Router's docs on Authentication](https://docs.expo.dev/router/reference/authentication/).
    </Accordion>
  </Tab>

  <Tab title="Without expo/router">
    Wrap your app with the `PrivyProvider` in the `App.tsx` file.

    ```tsx
    import {PrivyProvider} from '@privy-io/expo';

    import {HomeScreen} from './HomeScreen';

    export default function App() {
      return (
        <PrivyProvider appId="your-privy-app-id" clientId="your-privy-app-client-id">
          <HomeScreen />
        </PrivyProvider>
      );
    }
    ```
  </Tab>
</Tabs>

## Configuration

The `PrivyProvider` component accepts the following props:

<ParamField path="appId" type="string" required>
  Your Privy App ID. You can find this in the Privy Dashboard.
</ParamField>

<ParamField path="clientId" type="string" required>
  Your Privy Client ID. You can find this in the Privy Dashboard.
</ParamField>

## Waiting for Privy to be ready

When the `PrivyProvider` is first rendered, the Privy SDK will initialize some state about the current user. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until the `PrivyProvider` has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

To determine whether the Privy SDK has fully initialized, **check the `isReady` Boolean returned by the `usePrivy` hook.** When `isReady` is true, Privy has completed initialization, and your app can consume Privy's state and interfaces.

```tsx
import {usePrivy} from '@privy-io/expo';

function YourComponent() {
  const {isReady} = usePrivy();

  if (!isReady) {
    return <LoadingScreen />;
  }

  // Now it's safe to use other Privy hooks and state
  return <YourAuthenticatedContent />;
}
```

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/basics/react-native/quickstart">
    Learn how to [log users in](/authentication/user-authentication/login-methods/email) and
    [transact with embedded wallets](/wallets/wallets/create/from-my-client)
  </Card>

  <Card title="Example Repo" icon="code" href="https://github.com/privy-io/expo-starter">
    Check out our [Expo starter repo](https://github.com/privy-io/expo-starter) for a complete
    example
  </Card>
</CardGroup>


# null
Source: https://docs.privy.io/basics/react/advanced/automatic-wallet-creation



If your app uses embedded wallets, you can configure Privy to create wallets **automatically** for your users as part of their **login** flow.

<Warning>
  Automatic embedded wallet creation is currently not supported if your app uses Privy's whitelabel
  login interfaces. If this is the case for your app, you must [manually create embedded
  wallets](/wallets/wallets/create/from-my-client) for your users at the desired point in your
  onboarding flow.
</Warning>

<Tabs>
  <Tab title="Ethereum">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embeddedWallets.ethereum.createOnLogin`** property of your `PrivyProvider`:

    ```tsx
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embeddedWallets: {
                ethereum: { 
                    createOnLogin: 'users-without-wallets',
                }, 
            }, 
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>

  <Tab title="Solana">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embeddedWallets.solana.createOnLogin`** property of your `PrivyProvider`:

    ```tsx
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embeddedWallets: {
                solana: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```

    <ParamField path="createOnLogin" type="'all-users' | 'users-without-wallets' | 'off'" default="off">
      Determines when to create a wallet for the user.

      * `'all-users'`: Create a wallet for all users on login.
      * `'users-without-wallets'`: Create a wallet for users who do not have a wallet on login.
      * `'off'`: Do not create a wallet on login.
    </ParamField>
  </Tab>

  <Tab title="Ethereum & Solana">
    To configure Privy to automatically create embedded wallets for your user when they login, **set the `config.embeddedWallets.ethereum.createOnLogin`** and `config.embeddedWallets.solana.createOnLogin` properties of your `PrivyProvider`:

    ```tsx
    <PrivyProvider
        appId="your-privy-app-id"
        config={{
            embeddedWallets: {
                ethereum: {
                    createOnLogin: 'users-without-wallets',
                },
                solana: {
                    createOnLogin: 'users-without-wallets',
                },
            },
        }}
    >
        {children}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>


# Configuring appearance
Source: https://docs.privy.io/basics/react/advanced/configuring-appearance



**Privy's UIs are highly-customizable to seamlessly match the branding and design system of your app.**

Read below to learn how to customize several aspects of Privy, including your app's [name](#app-name), [logo](), [theme](#theme), [login ordering](#order-of-login-methods), [displayed wallet options](#external-wallet-options), and more.

<Tip>
  Looking for sample UIs in Figma? Use Privy's [Figma community
  file](https://www.figma.com/community/file/1370772828942381228/sample-privy-uis?searchSessionId=lw15kidv-kln22bn8s6),
  which contains sample UIs for progressive onboarding, authentication, and embedded wallet
  transaction flows.
</Tip>

## App name

To configure the name of your application, go to the **Privy Dashboard** and select your desired app from the dropdown in the navigation bar.

Then, navigate to the **Customization** page for your app and enter your app's name (as you'd like it to be presented to your users) in the **App name** field.

The **App name** you enter here will be used to identify your application for your users, throughout Privy's UIs in your app and emails and SMSes sent to users with login codes.

## Logo

To configure a logo for your application, go to the **Privy Dashboard** and select your desired app from the dropdown in the navigation bar.

Then, navigate to the **Customization** page for your app and enter a URL for your app's logo in the **Your logo** field. We recommend using an asset with a 2:1 aspect ratio and with a size of 180px x 90px. SVGs are not allowed due to poor compatibility with modern email clients.

The **Logo** you save here will be used in the upfront login modal shown to users within your app, as well as emails sent to your users with their login codes. If you'd like to use a different logo for the upfront login modal versus the login email, you can override the logo shown in the login modal via the **`config.appearance.logo`** property of the **`PrivyProvider`** component, like so:

```tsx {6}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to the logo you set in the Dashboard
      logo: 'https://your.logo.url',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

You can also opt to show no logo in the login modal by passing an empty string (`''`) to **`appearance.logo`**.

## Login screen header text

To configure the header text of the Privy login modal's landing screen, set a custom `string` as the **`config.appearance.landingHeader`** property of the **`PrivyProvider`** component, like so:

```tsx {6}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to 'Log in or sign up'
      landingHeader: 'Your custom header text',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

We recommend using a `string` of length 35 or less. Strings longer than the width of the login modal will be ellipsified.

If you do not set a custom header text, it will default to 'Log in or sign up'.

## Login screen message text

To configure the message text of the Privy login modal's login screen, set a custom `string` as the **`config.appearance.loginMessage`** property of the **`PrivyProvider`** component, like so:

```tsx {6}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to 'Log in or sign up'
      loginMessage: 'Your custom header text',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

We recommend using a `string` of length 100 or less. Strings longer than 100 characters will be truncated.

If you do not set a custom header text, there is no default.

## Theme

To configure a theme for your application, set the **`config.appearance.theme`** property of the **`PrivyProvider`** to `'light'`, `'dark'`, or a custom color as a hexadecimal string. The **`theme`** sets the core foreground and background colors for Privy's UIs in your app.

```tsx {6}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to 'light'
      theme: 'dark',
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

If you set the **`theme`** to `'light'` or `'dark'`, Privy's UIs will use Privy's standard light and dark themes, respectively. You can also set Privy's theme based on the user's system preferences by following this guide.

If you set the **`theme`** to a custom hexadecimal color, the **`theme`** color will be used as the *primary background color* for Privy's UIs. All other colors will be automatically generated by modulating the luminance of the theme color you set. This creates a cohesive palette that matches your app's branding.

<Tip>
  If you set a custom hexadecimal color as your **`theme`**, **we strongly recommend choosing a color that is either light *or* dark (> 80% or \< 20% luminance, as defined by [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV))**. This helps ensure there is sufficient contrast between foreground and background colors in the Privy modal.
</Tip>

If you'd like, you may also override specific colors in Privy's UI to match your brand palette.

## Order of login methods

Privy allows you to enable both web2 (email, phone, and socials) and web3 (external wallet) login methods for your app. You can customize Privy to configure how you want these login methods to appear.

<Tip>
  Though Privy provides careful defaults around ordering of login methods, you can also fully customize the ordering of login methods by using the [`loginMethodsAndOrder` override](#order-of-login-methods).

  This will allow you to fully customize the ordering of your login methods, with any overflow items (after the first four) going to a secondary page.
</Tip>

For many apps, it is preferable to display wallet (or social) logins upfront and have users click to access the rest of the options. If you'd like to default to either web2 or web3 login methods appearing in your login modal, you can do so by setting the **`config.appearance.showWalletLoginFirst`** property of the **`PrivyProvider`** like so:

```tsx {6}
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults to true
      showWalletLoginFirst: true,
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

## CSS Overrides

Beyond the configuration properties above, Privy also enables you to **explicitly override specific colors** in the login modal, to further match your product's design system and color palette. You might use these overrides if you are using a default Privy [`theme`](#theme) ('light' or 'dark') and wish to tweak a certain color, or if you set a custom [`theme`](#theme) and want to use your exact brand colors instead of the automatically-generated ones.

To explicitly override colors in your Privy modal, simply add the corresponding CSS variable for the color to the CSS [`body`](https://developer.mozilla.org/en-US/docs/Web/CSS/:root) of your app, and set it to your custom color. The possible CSS variables are listed below; we encourage you to [use your browser's developer tools](https://developer.chrome.com/docs/devtools/css/) to experiment with different color combinations to find the right one for your app!

```css
body {
  --privy-border-radius-sm: 'your-custom-value';
  --privy-border-radius-md: 'your-custom-value';
  --privy-border-radius-lg: 'your-custom-value';
  --privy-border-radius-full: 'your-custom-value';
  --privy-color-background: 'your-custom-value';
  --privy-color-background-2: 'your-custom-value';
  --privy-color-background-3: 'your-custom-value';
  --privy-color-foreground: 'your-custom-value';
  --privy-color-foreground-2: 'your-custom-value';
  --privy-color-foreground-3: 'your-custom-value';
  --privy-color-foreground-4: 'your-custom-value';
  --privy-color-foreground-accent: 'your-custom-value';
  --privy-color-accent: 'your-custom-value';
  --privy-color-accent-light: 'your-custom-value';
  --privy-color-accent-lightest: 'your-custom-value';
  --privy-color-accent-dark: 'your-custom-value';
  --privy-color-accent-darkest: 'your-custom-value';
  --privy-color-success: 'your-custom-value';
  --privy-color-error: 'your-custom-value';
  --privy-color-error-light: 'your-custom-value';
}
```


# Configuring EVM networks
Source: https://docs.privy.io/basics/react/advanced/configuring-evm-networks



**Privy is compatible with any EVM-compatible chain, and makes it easy to configure networks for your users' wallets.**

You can seamlessly use Privy with Ethereum Mainnet, Base, Polygon, Arbitrum, Monad, Berachain, MegaETH, Mantle, Story, and any chain that supports EVM RPC requests.

Check out a [high-level overview](/basics/react/advanced/configuring-evm-networks#overview) of network configuration with Privy, or jump directly into [concrete instructions](/basics/react/advanced/configuring-evm-networks#configuration)!

<Tip>
  Privy is also compatible with app-specific chains, such as those deployed via a RaaS provider. See
  more [here](/basics/react/advanced/configuring-evm-networks#other-networks).
</Tip>

## Overview

Privy exposes two parameters to configure networks: a single [**default chain**](/basics/react/advanced/configuring-evm-networks#default-chain) and a list of [**supported chains**](/basics/react/advanced/configuring-evm-networks#supported-chains).

If you choose not to use these parameters in your app, you can instead use Privy's [default configuration and supported chains](/basics/react/advanced/configuring-evm-networks#default-configuration).

### Default Chain

The **default chain** should be the primary network that wallets should use in your app.

For **embedded wallets**, when a user logs in or creates a wallet in your app, Privy will initialize the embedded wallet's network to the default chain. Thereafter, the embedded wallet will by default use the **default chain**, unless you manually switch the wallet's network to another [**supported chain**](/basics/react/advanced/configuring-evm-networks#supported-chains).

For **external wallets**, when a user connects their wallet to your app, Privy will prompt the user to switch their network to the default chain, as long as the wallet supports the network. If the user declines to switch their network to the **default chain**, they will still be permitted to connect their wallet.

<Info>
  Not all wallets support all EVM networks. Please note that the following wallets may reject
  connection requests if you specify one of their unsupported networks as a `defaultChain`: -
  **Rainbow Wallet**'s [mobile app](https://rainbow.me/download) does not support testnets, and will
  reject connections if you specify a testnet as a `defaultChain`. - **Trust Wallet**'s
  [SWIFT](https://trustwallet.com/blog/introducing-trust-wallet-swift) (in beta) only supports BNB
  Smart Chain, Polygon, Avalanche C-Chain, Arbitrum, OP Mainnet, Base, and OpBNB. If you specify a
  `defaultChain` that is not one of these networks, the wallet will reject the connection request.
</Info>

### Supported Chains

The **supported chains** list should be a list of networks that wallets are *permitted* to use in your app. This is intended as a guardrail against accidentally taking actions on the wrong network.

For **embedded wallets**, attempting to send a transaction on or switch the wallet to a network *not* in the list of **supported chains** will throw an error.

For **external wallets**, attempting to programmatically switch the wallet to a network *not* in the list of **supported chains** will throw an error.

If a list of **supported chains** is set but no [**default chain**](/basics/react/advanced/configuring-evm-networks#default-chain) is set:

* Embedded wallets will be connected to the first entry of the **supported chains** list by default.
* External wallets will **not** be prompted to a particular default chain when connecting or logging in; they will be permitted to login on whatever chain they are on. If you'd like to prompt users to switch to a particular network, you should explicitly set a **default chain**.

<Info>
  For external wallets (e.g. MetaMask), users may switch their wallet's network *manually*,
  independent of both Privy and your application. There is no way to prevent this behavior; Privy
  will **not** throw an error, and you can only re-prompt the user to switch to a different network.
</Info>

## Configuration

**Privy embedded wallets can support *any* EVM-compatible chain**.

### `viem`-Supported Networks

<Tip>
  If your desired EVM network is supported by the
  [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains) package, continue with the
  instructions below. The package's supported networks are listed
  [here](https://github.com/wevm/viem/blob/main/src/chains/index.ts). Otherwise, skip to the
  [**Other Networks**](/basics/react/advanced/configuring-evm-networks#other-networks) section.
</Tip>

To configure [**`viem`**](https://viem.sh/docs/chains/introduction#chains)-supported networks for Privy, **first, install the [`viem`](https://viem.sh/docs/installation#installation) package**. This package contains JSON representations of several EVM networks, which will be used to initialize the Privy SDK.

```sh
npm i viem
```

Next, **import your default chain and/or supported chains from the [`viem/chains`](https://viem.sh/docs/chains/introduction#chains) package**:

```tsx
// Replace this with any of the networks listed at https://github.com/wevm/viem/blob/main/src/chains/index.ts
import {base, berachain, polygon, arbitrum, story, mantle} from 'viem/chains';
```

**Lastly, configure your `PrivyProvider` with these additional network(s).** In particular, the **`config`** property of the **`PrivyProvider`** contains the optional parameters:

* **`defaultChain`** field, where you should pass a *single* chain object for your desired default chain
* **`supportedChains`** field, where you should pass a *list* of chain objects for your desired supported chains

```tsx {6,8}
<PrivyProvider
    appId='your-privy-app-id'
    config={{
        ...theRestOfYourConfig,
        // Replace this with your desired default chain
        defaultChain: base
        // Replace this with a list of your desired supported chains
        supportedChains: [base, berachain, polygon, arbitrum, story, mantle]
    }}
>
    {/* your app's content */}
</PrivyProvider>
```

The **`PrivyProvider`** will throw an error if:

* an empty array (`[]`) is passed into **`supportedChains`**
* a chain is passed into **`defaultChain`** that is *not* also included in **`supportedChains`** array

**That's it! You've successfully configured networks for external and embedded wallets in your app.** 🎉

### Other Networks

<Tip>
  If your desired EVM network is **not** supported by
  [**`viem/chains`**](https://viem.sh/docs/chains/introduction#chains), you can still use Privy with
  it per the steps below!
</Tip>

First, **import `viem` and use the package's [`defineChain`](https://viem.sh/docs/chains/introduction#custom-chains) method to build a JSON representation of your desired network.**

```tsx
import {defineChain} from 'viem';

export const myCustomChain = defineChain({
  id: 123456789, // Replace this with your chain's ID
  name: 'My Custom Chain',
  network: 'my-custom-chain',
  nativeCurrency: {
    decimals: 18, // Replace this with the number of decimals for your chain's native token
    name: 'My Native Currency Name',
    symbol: 'My Native Currency Symbol'
  },
  rpcUrls: {
    default: {
      http: ['https://my-custom-chain-https-rpc'],
      webSocket: ['wss://my-custom-chain-websocket-rpc']
    }
  },
  blockExplorers: {
    default: {name: 'Explorer', url: 'my-custom-chain-block-explorer'}
  }
});
```

At minimum, you must provide the network's name and chain ID, native currency, RPC URLs, and a blockexplorer URL.

Then, **pass the returned object (`myCustomChain` in the example above) to the `defaultChain` and `supportedChains` properties of the `PrivyProvider`.**

## Overriding a chain's RPC provider

**By default, transactions from the embedded wallet will be sent using Privy's default RPC providers.** Please note that Privy's default providers are subject to rate limits; these limits are sufficiently generous for developing your integration and moderate amounts of app usage.

**As your app's usage scales, we recommend that you setup your own RPC providers** (with [Alchemy](https://www.alchemy.com/), [QuickNode](https://www.quicknode.com/), [Blast](https://blastapi.io/), etc.) and configure Privy to use these providers per the instructions below. Setting up your own providers gives you maximum control over RPC throughput and rate limits, and offers you much more visibility into RPC analytics and common errors.

To configure Privy to use a custom RPC provider, first, **import the chain you want to override, and import the helper function `addRpcUrlOverrideToChain` from `@privy-io/chains` to override the RPC provider**

```ts
import {mainnet} from 'viem/chains';

import {addRpcUrlOverrideToChain} from '@privy-io/chains';

const mainnetOverride = addRpcUrlOverrideToChain(mainnet, INSERT_CUSTOM_RPC_URL);
```

Now, you can **add the chain returned by `addRpcUrlOverrideToChain` (e.g. `mainnetOverride`) to the `supportedChains` config option** like before.

## Default Configuration

If neither **`defaultChain`** nor **`supportedChains`** is explicitly set for your app, Privy will automatically default to the following list of EVM-compatible networks:

<Tip>
  **Want to use a chain not listed below?** Configure Privy with any EVM-compatible chain, like
  Berachain, Monad, or Story per the guidance
  [here](/basics/react/advanced/configuring-evm-networks#configuration).
</Tip>

<Expandable title="default networks">
  | Network           | [Chain ID](https://chainlist.org/) | Supported? | Privy RPC |
  | ----------------- | ---------------------------------- | ---------- | --------- |
  | Arbitrum          | 42161                              | ✅          | ✅         |
  | Arbitrum Sepolia  | 421614                             | ✅          | ✅         |
  | Avalanche C-Chain | 43114                              | ✅          |           |
  | Avalanche Fuji    | 43113                              | ✅          |           |
  | Base              | 8453                               | ✅          | ✅         |
  | Base Sepolia      | 84532                              | ✅          | ✅         |
  | Berachain Artio   | 80085                              | ✅          |           |
  | Celo              | 42220                              | ✅          |           |
  | Celo Alfajores    | 44787                              | ✅          |           |
  | Ethereum          | 1                                  | ✅          | ✅         |
  | Ethereum Sepolia  | 11155111                           | ✅          | ✅         |
  | Holesky           | 17000                              | ✅          |           |
  | Holesky Redstone  | 17001                              | ✅          |           |
  | Holesky Garnet    | 17069                              | ✅          |           |
  | Lukso             | 42                                 | ✅          |           |
  | Linea             | 59144                              | ✅          |           |
  | Linea Testnet     | 59140                              | ✅          |           |
  | Optimism          | 10                                 | ✅          | ✅         |
  | Optimism Sepolia  | 11155420                           | ✅          | ✅         |
  | Polygon           | 137                                | ✅          | ✅         |
  | Polygon Amoy      | 80002                              | ✅          | ✅         |
  | Redstone          | 690                                | ✅          |           |
  | Zora              | 7777777                            | ✅          |           |
  | Zora Sepolia      | 999999999                          | ✅          |           |
</Expandable>

* External wallets will **not** be prompted to switch networks when connecting to your app.
* Embedded wallets will initialize on **Ethereum mainnet** or the network used in the user's previous session on that device.

For both external and embedded wallets, you can switch a wallet to any of the following networks that are available from Privy out-of-the-box. As a reminder, **you can always [configure Privy with additional EVM networks](/basics/react/advanced/configuring-evm-networks#configuration).**

<Info>
  Security best practices [suggest maintaining a strict Content Security
  Policy](/security/implementation-guide/content-security-policy). In order to help with this, some
  chains are served by Privy out-of-the-box at `*.rpc.privy.systems`. For all other chains, Privy
  will pull from the Viem default RPC URL in its respective [chain
  definition](https://github.com/wevm/viem/tree/main/src/chains/definitions) if no override is
  specified.
</Info>


# Configuring Solana networks
Source: https://docs.privy.io/basics/react/advanced/configuring-solana-networks



Privy supports [Solana clusters](https://solana.com/docs/core/clusters) such as Mainnet Beta, Devnet, and Testnet.

To configure the Solana clusters to use in your application and custom RPC URLs for it, pass an array of clusters to the `config.solanaClusters` prop of the `PrivyProvider`:

```tsx
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    ...theRestOfYourConfig,
    // Replace this with your required clusters and custom RPC URLs
    solanaClusters: [{name: 'mainnet-beta', rpcUrl: 'https://api.mainnet-beta.solana.com'}]
  }}
>
  {/* your app's content */}
</PrivyProvider>
```

Each cluster in the array should be an object with the following fields:

| Field    | Type                                      | Description                                                                                                                                |
| -------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`   | `'mainnet-beta' \| 'devnet' \| 'testnet'` | Name of the Solana cluster.                                                                                                                |
| `rpcUrl` | `string`                                  | Custom RPC URL for the cluster. We strongly recommend using a custom RPC URL in production to avoid rate limiting on public RPC endpoints. |

# Custom Solana Virtual Machine (SVM) networks

In addition to supporting transactions on Solana mainnet, devnet, and testnet, Privy also supports sending transactions on any blockchain that implements the [Solana Virtual Machine (SVM)](https://squads.so/blog/solana-svm-sealevel-virtual-machine).

You can send a transaction on a custom SVM by initializing the `Connection` instance for your transaction with the RPC URL for the SVM, like so:

```tsx
// Initialize connection instance with custom SVM RPC URL
let connection = new Connection('insert-custom-SVM-rpc-url');

// Build out the transaction object for your desired program
// https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
let transaction = new Transaction();

// Send transaction on custom SVM
console.log(await wallet.sendTransaction!(transaction, connection));
```


# Migrating to 2.0
Source: https://docs.privy.io/basics/react/advanced/migrating-to-2.0



This guide will help you migrate your Privy React SDK from v1.x.x to v2.0.0.

To install the latest version, install the package from the `latest` tag:

```bash
npm i @privy-io/react-auth@latest
```

## New features and improvements 🎉

* Removed ethers v5 dependency, allowing developers to more easily use ethers v6
* Added support for submitting transactions without waiting for confirmation
* Added UIs for Ethereum signTransaction

For the full set of changes check out our [changelog](/changelogs/react-auth).

## Breaking changes

### Authentication

* Guaranteed that `user.wallet` is the first linked wallet on the user object. To maintain state of the latest connected wallet, interact with the wallets array directly.

* Removed the `forkSession` method. This feature was experimental and has been removed.

* Removed the `PrivyProvider`'s deprecated `onSuccess` prop - use the `onSuccess` callback registered via the `useLogin` hook instead.

### Embedded wallets

* Apps using [custom auth providers](/authentication/user-authentication/jwt-based-auth) must now explicitly configure wallet UIs in the dashboard, or use the updated `showWalletUIs` option.

* Removed the `PrivyProvider`'s deprecated `createPrivyWalletOnLogin` prop. Use `config.embeddedWallets.createOnLogin` instead.

```tsx
<PrivyProvider
  createPrivyWalletOnLogin={true} // Remove
  config={{
    embeddedWallets: {createOnLogin: 'users-without-wallets'} // Add
  }}
>
  ...
</PrivyProvider>
```

* Removed the deprecated `additionalChains` and `rpcConfig` props from `PrivyProvider` config, please configure these via the `supportedChains`

```tsx
<PrivyProvider
  config={{
    additionalChains: [], // Remove
    rpcConfig: {}, // Remove
    supportedChains: [] // Add
  }}
>
  ...
</PrivyProvider>
```

* Removed the deprecated `noPromptOnSignature` configuration option. Configure wallet UIs in the dashboard, or use the updated `showWalletUIs` option.

```tsx
<PrivyProvider
  config={{
    embeddedWallets: {
      noPromptOnSignature: true, // Remove
      showWalletUIs: false // Add
    }
  }}
>
  ...
</PrivyProvider>
```

#### EVM

* Removed the deprecated `getEthersProvider` and `getWeb3jsProvider` from the `ConnectedWallet` class. Use `getEthereumProvider` instead.

```ts
const provider = await wallet.getEthersProvider(); // Remove
const privyProvider = await wallet.getEthereumProvider(); // Add
const provider = new ethers.providers.Web3Provider(privyProvider); // Add

const provider = await wallet.getWeb3jsProvider(); // Remove
const privyProvider = await wallet.getEthereumProvider(); // Add
const provider = new Web3(privyProvider); // Add
```

* Ethereum `sendTransaction` method now returns a `Promise<{hash: string}>` instead of a `Promise<TransactionReceipt>`. To get the full details of the submitted transaction, use a library like [viem](https://viem.sh/docs/actions/public/getTransactionReceipt).

```tsx
const receipt = await sendTransaction({...}); // Remove
const {hash} = await sendTransaction({...}); // Add
const receipt = await publicClient.waitForTransactionReceipt({hash}); // Add
```

* Removed the experimental `waitForTransactionConfirmation` config option as it is the default behavior.

```tsx
<PrivyProvider
  config={{
    embeddedWallets: {
      waitForTransactionConfirmation: false // Remove
    }
  }}
>
  ...
</PrivyProvider>
```

* Updated `signMessage`, `signTypedData`, `sendTransaction`, and `signTransaction` methods:

<Tabs>
  <Tab title="signMessage">
    ```tsx
    const {signMessage} = usePrivy();
    // `uiOptions` and `address` are optional
    const signature = await signMessage(message, uiOptions, address); // Remove
    // the first argument should be formatted `{message: string}`
    const {signature} = await signMessage({message}, {uiOptions, address}); // Add
    ```
  </Tab>

  <Tab title="signTypedData">
    ```tsx
    const {signTypedData} = usePrivy();
    // `uiOptions` and `address` are optional
    const signature = await signTypedData(typedData, uiOptions, address); // Remove
    const {signature} = await signTypedData(typedData, {uiOptions, address}); // Add
    ```
  </Tab>

  <Tab title="sendTransaction">
    ```tsx
    const {sendTransaction} = usePrivy();
    // `uiOptions`, `fundWalletConfig`, and `address` are optional
    const receipt = await sendTransaction(transaction, uiOptions, fundWalletConfig, address); // Remove
    const {hash} = await sendTransaction(transaction, {uiOptions, fundWalletConfig, address}); // Add
    ```
  </Tab>

  <Tab title="signTransaction">
    ```tsx
    const {signTransaction} = usePrivy();
    // `uiOptions`, and `address` are optional
    const signature = await signTransaction(transaction, uiOptions, fundWalletConfig, address); // Remove
    const {signature} = await signTransaction(transaction, {uiOptions, address}); // Add
    ```
  </Tab>
</Tabs>

#### Smart Wallets

* Updated `signMessage`, `signTypedData`, and `sendTransaction` methods of the smart wallet client:

<Tabs>
  <Tab title="signMessage">
    ```tsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';

    const {client} = useSmartWallets();
    // `uiOptions` and `address` are optional
    const signature = await client.signMessage({message}, uiOptions, address); // Remove
    const signature = await client.signMessage({message}, {uiOptions, address}); // Add
    ```
  </Tab>

  <Tab title="signTypedData">
    ```tsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';

    const {client} = useSmartWallets();
    // `uiOptions` and `address` are optional
    const signature = await client.signTypedData(typedData, uiOptions, address); // Remove
    const signature = await client.signTypedData(typedData, {uiOptions, address}); // Add
    ```
  </Tab>

  <Tab title="sendTransaction">
    ```tsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';

    const {client} = useSmartWallets();
    // `uiOptions`, `fundWalletConfig`, and `address` are optional
    const hash = await client.sendTransaction(transaction, uiOptions, fundWalletConfig, address); // Remove
    const hash = await client.sendTransaction(transaction, {uiOptions, fundWalletConfig, address}); // Add
    ```
  </Tab>
</Tabs>

#### Solana

* Migrated `useSendSolanaTransaction` from `@privy-io/react-auth` to `useSendTransaction` from `@privy-io/react-auth/solana` (Solana-specific export path)

```tsx
import {useSendSolanaTransaction} from '@privy-io/react-auth'; // Remove
import {useSendTransaction} from '@privy-io/react-auth/solana'; // Add

...

const {sendSolanaTransaction} = useSendSolanaTransaction(); // Remove
const {sendTransaction} = useSendTransaction(); // Add
```

* Removed `sendSolanaTransaction` from `usePrivy` in favor of exporting `sendTransaction` from `useSendTransaction` from `@privy-io/react-auth/solana`

```tsx
import {usePrivy} from '@privy-io/react-auth'; // Remove
import {useSendTransaction} from '@privy-io/react-auth/solana'; // Add

...

const {sendSolanaTransaction} = usePrivy(); // Remove
const {sendTransaction} = useSendTransaction(); // Add
```

* Removed `delegateWalletAction` from `useSolanaWallets`. Use `delegateWallet` from `useDelegatedActions` instead.

```tsx
import {useSolanaWallets} from '@privy-io/react-auth/solana'; // Remove
import {useDelegatedActions} from '@privy-io/react-auth'; // Add

...

const {delegateWalletAction} = useSolanaWallets(); // Remove
delegateWalletAction(); // Remove

const {delegateWallet} = useDelegatedActions(); // Add
await delegateWallet({  // Add
  address: '<wallet to delegate>', // Add
  chainType: 'solana', // Add
}); // Add
```

* Removed rpcUrl from `fundWallet` from `useSolanaWallets`. Set rpcUrl in `config.solanaClusters` prop of the `PrivyProvider` instead

```tsx
import {useSolanaWallets} from '@privy-io/react-auth/solana';

const {fundWallet} = useSolanaWallets();
fundWallet({
  address: '<wallet to fund>',
  cluster: {name: 'mainnet-beta', rpcUrl: 'https://api.mainnet-beta.solana.com'}, // Remove
  cluster: {name: 'mainnet-beta'} // Add
});

<PrivyProvider
  appId="your-privy-app-id"
  config={{
    ...theRestOfYourConfig,
    // Replace this with your required clusters and custom RPC URLs
    solanaClusters: [{name: 'mainnet-beta', rpcUrl: 'https://api.mainnet-beta.solana.com'}] // Add
  }}
>
  {/* your app's content */}
</PrivyProvider>;
```

### Connectors

* Removed the `setActiveWallet` method - use the `wallets` array directly to interact with wallets.

### Callbacks

* Updated all non-error [callbacks](/authentication/user-authentication/login-methods/email) to use named arguments instead of positional arguments.

```tsx
const {login} = useLogin({
  onComplete: (user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount) => { // Remove
  onComplete: ({user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount}) => { // Add

    console.log(user, isNewUser, wasAlreadyAuthenticated, loginMethod, linkedAccount);
    // Any logic you'd like to execute if the user is/becomes authenticated while this
    // component is mounted
  },
  ...
  onError: (error) => { // onError will continue to stay as a singular error argument
    console.log(error)
  }})

...
 const {reauthorize} = useOAuthTokens({
  onOAuthTokenGrant: (tokens: OAuthTokens, {user}: {user: User}) => {  // Remove
  onOAuthTokenGrant: ({tokens, user}) => {  // Add
    const oAuthToken = tokens.accessToken

  ...
  }})
```


# null
Source: https://docs.privy.io/basics/react/installation



## Requirements

* React 18 or higher
* TypeScript 5 or higher

## Installation

Install the Privy React SDK using your package manager of choice:

<CodeGroup>
  ```bash npm
  npm install @privy-io/react-auth@latest
  ```

  ```bash pnpm
  pnpm install @privy-io/react-auth@latest
  ```

  ```bash yarn
  yarn add @privy-io/react-auth@latest
  ```
</CodeGroup>

<Note>
  If your app uses `yarn`, you must either manually also install `@solana/web3.js` and `@solana/spl-token` or add them to webpack's `externals` config if your app does not use Solana:

  ```js
  // webpack.config.js
  module.exports = {
    //...
    externals: {
      ['@solana/web3.js']: 'commonjs @solana/web3.js',
      ['@solana/spl-token']: 'commonjs @solana/spl-token'
    }
  };

  // next.config.js
  module.exports = {
    webpack: (config) => {
      // ...
      config.externals['@solana/web3.js'] = 'commonjs @solana/web3.js';
      config.externals['@solana/spl-token'] = 'commonjs @solana/spl-token';
      return config;
    }
  };
  ```
</Note>


# Quickstart
Source: https://docs.privy.io/basics/react/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your React app

## 0. Prerequisites

This guide assumes that you have completed the [Setup](/basics/react/setup) guide.

## 1. Enable a user to log in via email

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

**To authenticate a user via their email address, use the React SDK's `useLoginWithEmail` hook.**

```tsx
import {useLoginWithEmail} from '@privy-io/react-auth';
...
const {sendCode, loginWithCode} = useLoginWithEmail();
```

Ensure that this hook is mounted in a component that is wrapped by the [PrivyProvider](/basics/react/setup#initializing-privy).
You can use the returned methods **`sendCode`** and **`loginWithCode`** to authenticate your user per the instructions below.

### Send an OTP

Send a one-time passcode (OTP) to the user's **email** by passing their email address to the **`sendCode`** method returned from `useLoginWithEmail`:

```tsx
import {useState} from 'react';
import {useLoginWithEmail} from '@privy-io/react-auth';

export default function LoginWithEmail() {
  const [email, setEmail] = useState('');
  const [code, setCode] = useState('');
  const {sendCode, loginWithCode} = useLoginWithEmail();

  return (
    <div>
      <input onChange={(e) => setEmail(e.currentTarget.value)} value={email} />
      <button onClick={() => sendCode({email})}>Send Code</button>
      <input onChange={(e) => setCode(e.currentTarget.value)} value={code} />
      <button onClick={() => loginWithCode({code})}>Login</button>
    </div>
  );
}
```

## 2. Create an embedded wallet for the user

Your app can configure Privy to [**automatically** create wallets](/basics/react/advanced/automatic-wallet-creation) for your users as part of their **login** flow. The embedded wallet will be generated and linked to the user object upon authentication.

Alternatively your app can [**manually** create wallets](/wallets/wallets/create/from-my-client) for users when required.

<Info>Privy can provision wallets for your users on both **Ethereum** and **Solana**.</Info>

## 3. Send a transaction with the embedded wallet

With the users' embedded wallet, your application can now prompt the user to sign and send transactions.

```tsx
import {useSendTransaction} from '@privy/react-auth';
export default function SendTransactionButton() {
  const {sendTransaction} = useSendTransaction();
  const onSendTransaction = async () => {
    sendTransaction({
      to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
      value: 100000
    });
  };

  return <button onClick={onSendTransaction}>Send Transaction</button>;
}
```

<Tip>
  [Learn more](/wallets/using-wallets/ethereum/send-a-transaction) about sending transactions with
  the embedded wallet. Privy enables you to take many actions on the embedded wallet, including
  [sign a message](/wallets/using-wallets/ethereum/sign-a-message), [sign typed
  data](/wallets/using-wallets/ethereum/sign-typed-data), and [sign a
  transaction](/wallets/using-wallets/ethereum/sign-a-transaction).
</Tip>

Congratulations, you have successfully been able to integrate Privy authentication and wallet into your React application!


# null
Source: https://docs.privy.io/basics/react/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

<Tip>
  Deploying your app across multiple domains or environments? Learn how to use [app
  clients](/basics/get-started/dashboard/app-clients) to customize Privy's behavior for different
  environments.
</Tip>

## Initializing Privy

In your project, **import the `PrivyProvider` component and wrap your app with it**.
The `PrivyProvider` must wrap *any* component or page that will use the Privy React SDK, and it is generally recommended to render it as close to the root of your application as possible.

<Tip>
  If you're new to React and using contexts, check out
  [these](https://react.dev/learn/thinking-in-react)
  [resources](https://react.dev/learn/passing-data-deeply-with-context)!
</Tip>

<CodeGroup>
  ```tsx NextJS
  'use client';

  import {PrivyProvider} from '@privy-io/react-auth';

  export default function Providers({children}: {children: React.ReactNode}) {
    return (
      <PrivyProvider
        appId="your-privy-app-id"
        clientId="your-app-client-id"
        config={{
          // Create embedded wallets for users who don't have a wallet
          embeddedWallets: {
            createOnLogin: 'users-without-wallets'
          }
        }}
      >
        {children}
      </PrivyProvider>
    );
  }
  ```

  ```tsx Create React App
  import React from 'react';
  import ReactDOM from 'react-dom/client';

  import './index.css';

  import {PrivyProvider} from '@privy-io/react-auth';

  import App from './App';

  const root = ReactDOM.createRoot(document.getElementById('root'));

  root.render(
    <React.StrictMode>
      <PrivyProvider
        appId="your-privy-app-id"
        clientId="your-app-client-id"
        config={{
          // Create embedded wallets for users who don't have a wallet
          embeddedWallets: {
            createOnLogin: 'users-without-wallets'
          }
        }}
      >
        <App />
      </PrivyProvider>
    </React.StrictMode>
  );
  ```
</CodeGroup>

## Configuration

The `PrivyProvider` component accepts the following props:

<ParamField path="appId" type="string" required>
  Your Privy App ID. You can find this in the Privy Dashboard.
</ParamField>

<ParamField path="clientId" type="string">
  (Optional) A client ID to be used for this app client. Learn more about app clients
  [here](/basics/get-started/dashboard/app-clients).
</ParamField>

<ParamField path="config" type="Object">
  Configuration options for the Privy SDK.
</ParamField>

<Info>
  For more information on the `config` object, look under **React > Advanced** for guides like
  [customizing appearance](/basics/react/advanced/configuring-appearance) for our UI components and
  [configuring networks](/basics/react/advanced/configuring-evm-networks).
</Info>

## Waiting for Privy to be ready

When the `PrivyProvider` is first rendered on your page, the Privy SDK will initialize some state about the current user. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until the `PrivyProvider` has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

To determine whether the Privy SDK has fully initialized on your page, **check the `ready` Boolean returned by the `usePrivy` hook.** When `ready` is true, Privy has completed initialization, and your app can consume Privy's state and interfaces.

```tsx
import {usePrivy} from '@privy-io/react-auth';

function YourComponent() {
  const {ready} = usePrivy();

  if (!ready) {
    return <div>Loading...</div>;
  }

  // Now it's safe to use other Privy hooks and state
  return <div>Privy is ready!</div>;
}
```

<Info>
  **Using wallets?** Use the [ready](/wallets/wallets/get-a-wallet/get-connected-wallet) indicator
  from the `useWallets` hook to wait for wallets to complete loading.
</Info>

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/basics/react/quickstart">
    Learn how to log users in and transact with embedded wallets
  </Card>

  <Card title="NextJS starter repo" icon="code" href="https://github.com/privy-io/create-next-app">
    Check out the NextJS app starter repo for a complete example integration
  </Card>

  <Card title="React starter repo" icon="code" href="https://github.com/privy-io/create-react-app">
    Check out the React app starter repo for a complete example integration
  </Card>

  <Card title="Whitelabel starter repo" icon="code" href="https://github.com/privy-io/whitelabel-starter">
    Check out the whitelabel starter for a complete whitelabel example integration
  </Card>
</CardGroup>


# Quickstart
Source: https://docs.privy.io/basics/rest-api/quickstart

Creating a wallet and sending a transaction with Privy's REST API

## 0. Prerequisites

API credentials are required for this guide. If you have not already gone through the [API setup guide](/basics/rest-api/setup), go through those steps now.

## 1. Create a wallet

Let's create a simple Ethereum wallet:

<CodeGroup>
  ```bash cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "chain_type": "ethereum"
  }'
  ```
</CodeGroup>

<Note>
  [Authorization signatures](/api-reference/authorization-signatures) are an optional security
  improvement that requires all requests to be authorized by you.
</Note>

The response will include the wallet ID and public address:

```json
{
  "id": "jf4mev19seymsqulciv8on0c",
  "address": "0x7Ef5363308127128969618240eDcB9F8f61e90F6",
  "chain_type": "ethereum",
  "policy_ids": [],
  "created_at": 1741362961254
}
```

## 2. Sign a message

Now let's sign a message with our new wallet:

<CodeGroup>
  ```bash cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "personal_sign",
    "params": {
      "message": "Hello from Privy!",
      "encoding": "utf-8"
    }
  }'
  ```
</CodeGroup>

The response will contain the signed message:

```json
{
  "method": "personal_sign",
  "data": {
    "signature": "0x292d67e9c5178447f1c5344b3122997dfba8f00e43102d0b746301e9b4afbbf67d952bf870878d92b8eb066da205840458c0a5fb3f53253dbe1adf9c143678311c",
    "encoding": "hex"
  }
}
```

## 3. Send a transaction

Finally, let's send a transaction on Ethereum's testnet, [Sepolia](https://sepolia.etherscan.io/):

<CodeGroup>
  ```bash cURL
  curl --request POST \
    --url https://api.privy.io/v1/wallets/{wallet_id}/rpc \
    --header 'Authorization: Basic <encoded-value>' \
    --header 'Content-Type: application/json' \
    --header 'privy-app-id: <privy-app-id>' \
    --data '{
    "method": "eth_sendTransaction",
    "caip2": "eip155:11155111",
    "chain_type": "ethereum",
    "params": {
      "transaction": {
        "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
        "value": 1000000000000000
      }
    }
  }'
  ```
</CodeGroup>

<Warning>
  You will need to fund your wallet with Sepolia ETH for this step. Use a [Sepolia
  faucet](https://cloud.google.com/application/web3/faucet/ethereum/sepolia) and send it to the
  public address.
</Warning>

The response will contain the transaction hash and a Privy transaction ID:

```json
{
  "method": "eth_sendTransaction",
  "data": {
    "hash": "0x7c91ba85d67ef92cc15f3e9c8d8c5788e982cf83fabe9bfcc66a747aa0bd3701",
    "caip2": "eip155:11155111",
    "transaction_id": "d2obiyxnblv7jzp73b8scqa8"
  }
}
```

## Next steps

Now that you've created a wallet and made your first transaction, you can explore:

1. Creating [policies](/controls/policies/overview) to control wallet spending and contract interaction
2. Setting up [webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks) for real-time transaction notifications
3. Using [idempotency keys](/api-reference/idempotency-keys) to prevent duplicate transactions
4. Setting up [quorum authorizations](/controls/quorum-approvals/overview#using-quorum-approvals) for sensitive wallets


# Setup
Source: https://docs.privy.io/basics/rest-api/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) from the Privy Dashboard.

## Base URL

All requests to the Privy API must be made to the following base URL:

```
https://api.privy.io
```

HTTPS is required for all requests. HTTP requests will be rejected.

## Authentication

All API endpoints require authentication using Basic Auth and a Privy App ID header. Include the following headers with every request:

<ParamField header="Authorization" type="string" example="Basic ouihv9248hosd9020oihj0v10d=" required>
  Basic Auth header with your app ID as the username and your app secret as the password.
</ParamField>

<ParamField header="privy-app-id" type="string" example="cla06f34x0001mh08l8nsr496" required>
  Your Privy app ID as a string.
</ParamField>

Requests missing either of these headers will be rejected by Privy's middleware.

<Info>
  Your Privy app ID and app secret can be found in the [**App settings** >
  **Basics**](https://dashboard.privy.io/apps?page=settings\&tab=basics) tab for your app.
</Info>

## Examples

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    fetch('https://api.privy.io/v1/wallets', {
      method: 'GET',
      headers: {
        'Authorization': `Basic ${btoa('insert-your-app-id' + ':' + 'insert-your-app-secret')}`,
        'privy-app-id': 'insert-your-app-id',
        'Content-Type': 'application/json'
      }
    })
    .then(response => response.json())
    .then(data => console.log(data));
    ```
  </Tab>

  <Tab title="cURL">
    ```bash
    curl -X GET "https://api.privy.io/v1/wallets" \
      --user "insert-your-app-id:insert-your-app-secret" \
      -H "privy-app-id: insert-your-app-id" \
      -H "Content-Type: application/json"
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import requests
    import base64

    app_id = "insert-your-app-id"
    app_secret = "insert-your-app-secret"

    auth_string = f"{app_id}:{app_secret}"
    encoded_auth = base64.b64encode(auth_string.encode()).decode()

    headers = {
        "Authorization": f"Basic {encoded_auth}",
        "privy-app-id": app_id,
        "Content-Type": "application/json"
    }

    response = requests.get("https://api.privy.io/v1/wallets", headers=headers)
    data = response.json()
    ```
  </Tab>
</Tabs>


# Migrating to 2.0
Source: https://docs.privy.io/basics/swift/advanced/migrating-to-2.0



If your app previously used Privy's Swift `1.Y.Z` SDK, follow the migration guide below to upgrade to `2.0`. The migration guide is split into logical sections that outline related breaking changes.

## Initialization

### 1. App client ID required at initialization

Previously, apps were only required to pass in an `appId` when initializing the Privy SDK. Now, `appClientId` is required too. You can retrieve more information on how to retrieve your appClientId [here](/basics/get-started/dashboard/app-clients).

```swift Initializing the Privy SDK
let config = PrivyConfig(appId: "<your-app-id>") // Remove
let config = PrivyConfig(appId: "<your-app-id>", appClientId: "<client-id>") // Add
let privy: Privy = PrivySdk.initialize(config: config)
```

### 2. PrivySdk.initialize can only be called once

It's important to use a single instance of Privy across the lifetime of your application. Calling PrivySdk.initialize multiple times will result in a fatal error.

### 3. privy.awaitReady()

When the Privy SDK is first initialized, the user's authentication state will be set to `notReady` until Privy finishes initialization. We've added an async `privy.awaitReady()` function that allows you to await initialization completion. During this time, we suggest you show a loading state to your user.

<Info>
  Calling PrivySDK functions before calling `privy.awaitReady()` might result in unexpected
  functionality.
</Info>

Here's an example with some pseudocode:

```swift
Task {
  // Show loading UI
  uiState = .loading

  // Await ready
  await privy.awaitReady()

  if let case let .authenticated(privyUser) = privy.authState {
    // user is authenticated - show authenticated screen
  } else {
    // user not authenticated - show login screen
  }
}
```

## Authentication

### AuthState

The `AuthState` represents the authentication state of your user.

```swift
public enum AuthState {
    /// Auth state has not been determined yet. Call `privy.awaitReady` to ensure auth state is set.
    case notReady

    /// The user is unauthenticated
    case unauthenticated

    /// The user is authenticated, and can be accessed via the associated value
    case authenticated(PrivyUser)
}
```

#### Accessing AuthState

The current auth state can be accessed any time via `privy.authState`.

#### Subscribing to AuthState updates

Auth state updates are exposed via `privy.authStatePublisher`, which utilizes Combine's AnyPublisher.

```swift
func subscribeToAuthStateUpdates() {
    privy.authStatePublisher
        .receive(on: RunLoop.main)
        .sink { authState in
            print("Latest auth state: \(authState)")
        }
        .store(in: &subscriptions)
}
```

### The PrivyUser

After authenticating a user via any login method, you will receive the `PrivyUser` object. The `PrivyUser` represents an authenticated user. All user specific actions, such as creating a wallet or retrieving the user's access token, are accessed via the `PrivyUser`.

You may retrieve the `PrivyUser` anytime by calling `privy.user`. If this value is non-null, there is an authenticated user. If the value is null, there is no authenticated user.

The `PrivyUser` can also be retrieved via the associated type of the "authenticated" auth state:

```swift
if case .authenticated(let privyUser) = privy.authState {
  // user is authenticated
}
```

Use the `PrivyUser` object to:

* Get the user's ID
* Get the user's identity token
* Get the user's access token
* Get the user's linked accounts
* Get the user's embedded Ethereum wallets
* Get the user's embedded Solana wallets
* Create an embedded Ethereum wallet
* Create an embedded Solana wallet
* Refresh the user
* Log the user out

### Miscellaneous

#### Errors

We've significantly enhanced our error handling. When an SDK function throws an error, it will be a `PrivyError`, which contains an `errorCode` and a `localizedDescription`.

#### AuthSession

The `AuthSession` is no longer exposed. Values previously available in AuthSession are now available through different methods:

* `PrivyUser`: can be accessed via `privy.user` as described above.
* `accessToken`: can be accessed via `privy.user.getAccessToken()`. This method will return the user's access token, refreshing the session if needed.

#### Session Refresh

To refresh / update a `PrivyUser`, you'd previously call `privy.refreshSession`. Now, trigger the refresh via the `PrivyUser`, specifically, `privyUser.refresh`.

#### Logout

To logout an authenticate user, call `privyUser.logout()` instead of `privy.logout()`. Once calling logout, the `PrivyUser` instance is no longer valid.

#### Linked Accounts

* `LinkedAccount` and its associated types are no longer `Codable`, `Hashable`, `Identifiable` or `Equatable`.
* `LinkedAccount.embeddedWallet` is now split into chain specific values - `LinkedAccount.embeddedEthereumWallet` and `LinkedAccount.embeddedSolanaWallet`
* The `chainId` property on the embedded wallet linked accounts is removed.

#### Other type changes

* `firstVerifiedAt`, `latestVerifiedAt`, and `createdAt` fields now have type `Date` instead of `TimeInterval` or `Int`
* `verifiedAt` fields now replaced with `firstVerifiedAt` and `latestVerifiedAt`
* `LoginMethod` is no longer `Equatable`

### Login with SMS

* The `OtpFlowState` enum is no longer exposed. You should manually handle state management based on function results. For example, if `LoginWithSms.loginWithCode` throws an error, you can catch the error and update your UI accordingly.
* `LoginWithSms.sendCode` now throws an error if sending code is unsuccessful, instead of returning false
* `LoginWithSms.loginWithCode` now returns `PrivyUser`
* `LoginWithSms.loginWithCode` now requires phone number to be passed in as a parameter (previously was optional)

### Login with email

* The `OtpFlowState` enum is no longer exposed. You should manually handle state management based on function results. For example, if `LoginWithEmail.loginWithCode` throws an error, you can catch the error and update your UI accordingly.
* `LoginWithEmail.sendCode` now throws an error if sending code is unsuccessful, instead of returning false
* `LoginWithEmail.linkWithCode` no longer returns anything, and throws an error if linking fails
* `LoginWithEmail.loginWithCode` now returns `PrivyUser`
* `LoginWithEmail.loginWithCode` now requires email to be passed in (no longer optional)

### Login with custom auth

* `LoginWithCustomAccessToken.loginWithCustomAccessToken` now returns `PrivyUser`
* When initializing the PrivySDK, you should now pass the `TokenProvider` through the `PrivyLoginWithCustomAuthConfig` field in the `PrivyConfig` object. This allows Privy to access your user's access token at initialization while attempting to restore the Privy user's session.

### Login with SIWE

* `SiweFlowState` enum is no longer exposed. You should manually handle state management based on function results. For example, if `LoginWithSiwe.loginWithSiwe` throws an error, you can catch the error and update your UI accordingly.
* `LoginWithSiwe.loginWithSiwe` now returns `PrivyUser`
* `LoginWithSiwe.loginWithSiwe` now requires message and params to be passed in (no longer optional)
* `LoginWithSiwe.linkWithSiwe` no long returns anything, and throws an error if linking fails
* `LoginWithSiwe.linkWithSiwe` now requires message and params to be passed in (no longer optional)

### Login with OAuth

* LoginWithOAuth.login now returns `PrivyUser`

## Embedded wallets

### Overview

Previously, all embedded wallet APIs were accessible directly from the `privy.embeddedWallet` object, which is no longer available.

All embedded wallet APIs are now available via the `PrivyUser` instead. This is because all embedded wallet actions require an authenticated user, so adding the methods inside the authenticated `PrivyUser` was the most logical.

As an example, when creating an Ethereum wallet:

```swift
try await privy.embeddedWallet.createWallet(chainType: .ethereum) // Remove
try await privy.user.createEthereumWallet() // Add
```

### Connecting the wallet

In SDK 1.Y.Z, you had to ensure wallets were connected prior to accessing them by calling `privy.connectWallet()`. This method is now removed as **we handle connected state internally!** You may access the user's embedded wallets at anytime, without ensuring "wallet connected" state.

Because you no longer need to manage wallet state, `EmbeddedWalletState` has been removed.

### Ethereum vs Solana

Now, all embedded wallet APIs are chain specific and available via the `PrivyUser`.

#### Creating a wallet

Ethereum:

```swift
try await privy.embeddedWallet.createWallet(chainType: .ethereum) // Remove
let ethereumWallet = try await privy.user.createEthereumWallet() // Add
```

Solana:

```swift
try await privy.embeddedWallet.createWallet(chainType: .solana) // Remove
let solanaWallet = try await privy.user.createSolanaWallet() // Add
```

#### Retrieving a wallet

Ethereum:

```swift
// Ensure wallets are connected // Remove
guard case .connected(let wallets) = privy.embeddedWallet.embeddedWalletState else { // Remove
    print("Wallet not connected") // Remove
    return // Remove
} // Remove

// Grab first ethereum wallet from connected wallets // Remove
guard let wallet = wallets.first, wallet.chainType == .ethereum else { // Remove
    print("No Ethereum wallets available") // Remove
    return // Remove
} // Remove

// Directly grab ethereum wallets, without worrying about connected state // Add
let ethereumWallets: [EmbeddedEthereumWallet] = privy.user.embeddedEthereumWallets // Add
```

Solana:

```swift
// Ensure wallets are connected // Remove
guard case .connected(let wallets) = privy.embeddedWallet.embeddedWalletState else { // Remove
    print("Wallet not connected") // Remove
    return // Remove
} // Remove

// Grab first ethereum wallet from connected wallets // Remove
guard let wallet = wallets.first, wallet.chainType == .solana else { // Remove
    print("No Solana wallets available") // Remove
    return // Remove
} // Remove

// Directly grab ethereum wallets, without worrying about connected state // Add
let solanaWallets: [EmbeddedSolanaWallet] = privy.user.embeddedSolanaWallets // Add
```

#### Using a wallet / rpc providers

Instead of grabbing the wallet's provider via `try privy.embeddedWallet.getEthereumProvider(for: wallet.address)`, the provider is now available directly on the wallet instance. For example:

Ethereum:

```swift
// Create or retrieve the embedded Ethereum wallet
let ethereumWallet: EmbeddedEthereumWallet = privy.user.createEthereumWallet()

try await ethereumWallet.provider.request(
    // Note: RpcRequest was renamed to EthereumRpcRequest
    EthereumRpcRequest(...)
)
```

Solana:

```swift
// Create or retrieve the embedded Ethereum wallet
let solanaWallet: EmbeddedSolanaWallet = privy.user.createSolanaWallet()

try await solanaWallet.provider.signMessage(...)
```

#### Changing the EVM chain

When utilizing the `EmbeddedEthereumWalletProvider`, you may specify the EVM Chain by calling `provider.switchChain`. This was previously named `provider.configure`.


# null
Source: https://docs.privy.io/basics/swift/installation



## Requirements

* iOS 16 or higher

## Installation

Install the Privy Swift SDK via the Swift Package Manager:

1. In Xcode, navigate to File > Add Package Dependencies
2. In the "Search or Enter Package URL" search box enter:
   ```
   https://github.com/privy-io/privy-ios
   ```
3. Select the appropriate version and click Add Package


# Quickstart
Source: https://docs.privy.io/basics/swift/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Swift app.

## Prerequisites

This guide assumes that you have completed the [setup](/basics/swift/setup) guide.

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via SMS.

This is a two step process:

1. Send an OTP to the user provided phone number.
2. Verify the OTP sent to the user.

<Note>
  Please be sure to configure SMS as a login method on the [**Privy Developer
  Dashboard**](https://dashboard.privy.io) under User Management > Authentication.
</Note>

#### 1. Send an OTP to the user's phone number via SMS

After collecting and validating your users phone number, send an OTP by calling the **`sendCode`** method.
Note: you must provide the phone number in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).

```swift
do {
    let phoneNumber = "+14155552671"
    try await privy.sms.sendCode(to: phoneNumber)
    // OTP sent successfully - prompt user for OTP
} catch {
    // OTP could fail if the network request fails
    print("Error sending code: \(error))
}
```

If the OTP is sent successfully, `sendCode` will not throw an error.
If the provided phone number is invalid, or sending the OTP fails, **`sendCode`** will throw an error.

#### 2. Authenticate with OTP

The user will then receive an SMS with a 6-digit OTP. Prompt for this OTP within your application, then authenticate the user with the `loginWithCode` method. Pass the following parameters to this method:

<ParamField name="code" type="String">
  OTP code inputted by the user in your app.
</ParamField>

<ParamField name="phoneNumber" type="String">
  The user's phone number.
</ParamField>

```swift
do {
    let phoneNumber = "+14155552671"
    let inputtedOtp = "123456"
    let privyUser = try await privy.sms.loginWithCode(inputtedOtp, sentTo: phoneNumber)
    print("Logged in with sms! User: \(privyUser.id)")
} catch {
    print("Error logging user in: \(error)")
}
```

If the OTP/phone number combination is valid, Privy will successfully authenticate your user and `loginWithCode` will return the `PrivyUser`.
If the provided OTP/phone number combination is invalid, `loginWithCode` will throw an error that speicfies the error reason.

## The embedded wallet

Privy's embedded wallets are compatible with the Ethereum and Solana blockchains.

<Tabs>
  <Tab title="Ethereum">
    ### Creating the embedded wallet

    To create an EVM embedded wallet for your user, call `PrivyUser.createEthereumWallet`.

    ```swift
    public protocol PrivyUser {
        // Other privy user methods

        func createEthereumWallet(allowAdditional: Bool) async throws -> EmbeddedEthereumWallet
    }
    ```

    <ParamField name="allowAdditional" type="Bool" optional default="false">
      Ethereum embedded wallets are [hierarchical deterministic (HD)
      wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets),
      and a user's seed entropy can support multiple separate embedded wallets. If a user already has a
      wallet and you'd like to create additional HD wallets for them, pass in `true` for the
      `allowAdditional` parameter.
    </ParamField>

    If a wallet is successfully created for the user, the newly created EmbeddedEthereumWallet is returned.

    The method will throw an error if

    * The user is not authenticated
    * If a user already has 9 or more wallets
    * If the network call to create the wallet fails
    * If a user already has an embedded wallet and allowAdditional is not set to true.

    #### Example

    ```swift
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            let ethereumWallet = try await user.createEthereumWallet()
            print("Created wallet with address: \(ethereumWallet.address)")
        } catch {
            print("Error creating embedded wallet: \(error.localizedDescription)")
        }
    }
    ```

    ### Using the embedded wallet

    To enable your app to request signatures and transactions from the embedded wallet, Privy Ethereum embedded wallets expose a provider *inspired by* the [**EIP-1193 provider**](https://eips.ethereum.org/EIPS/eip-1193) standard. This allows you request signatures and transactions from the wallet via a familiar [**JSON-RPC API**](https://ethereum.org/en/developers/docs/apis/json-rpc/) (e.g. [`personal_sign`](https://docs.metamask.io/wallet/reference/personal_sign/)).

    Once you have an instance of an `EmbeddedEthereumWallet`, you can make RPC requests by using the `provider: EmbeddedEthereumWalletProvider` hook and using its `request` method. For example, `wallet.provider.request(request: rpcRequest)`.

    ```swift
    public protocol EmbeddedEthereumWallet: EmbeddedWalletBehavior {
        var provider: EmbeddedEthereumWalletProvider { get }
    }
    ```

    As a parameter to this method, to this method, pass an `EthereumRpcRequest` object that contains:

    * **method**: the name of the JSON-RPC method for the wallet to execute (e.g. `personal_sign`)
    * **params**: an array of parameters required by your specified method

    By default, embedded wallets are connected to the Ethereum mainnet. To send a transaction on a different network, simply set the wallet's chainId in the transaction request.

    #### Example

    ```swift
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            // Retrieve list of user's embedded Ethereum wallets
            let ethereumWallets = user.embeddedEthereumWallets

            // Grab the desired wallet. Here, we retrieve the first wallet
            if let wallet = ethereumWallets.first {
                let data = EthereumRpcRequest(method: "personal_sign", params: ["A message to sign", wallet.address])
                let signature = try await wallet.provider.request(data)
                print("Result signature: \(signature)")
            }
        } catch {
            print("personal_sign error: \(error.localizedDescription)")
        }
    }
    ```
  </Tab>

  <Tab title="Solana">
    ### Creating the embedded wallet

    To create a Solana embedded wallet for your user, call `PrivyUser.createSolanaWallet`.

    If a wallet is successfully created for the user, the newly created EmbeddedSolanaWallet is returned.

    The method will throw an error if

    * The user is not authenticated
    * If a user already has a Solana wallet
    * If the network call to create the wallet fails

    #### Example

    ```swift
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            let solanaWallet = try await user.createSolanaWallet()
            print("Created wallet with address: \(solanaWallet.address)")
        } catch {
            print("Error creating embedded wallet: \(error)")
        }
    }
    ```

    ### Using the embedded wallet

    Privy supports requesting signatures on messages and transactions from a user's Solana embedded wallet using the `signMessage` RPC. To request a signature, get the Solana embedded wallet provider and call the `signMessage` method on it with a base-64 encoded message to sign. If the signature is computed successfully, `signMessage` will return it as a base64-encoded string.

    ```swift
    public protocol EmbeddedSolanaWalletProvider {
        /// Request a signature on a Base64 encoded message or transaction
        /// - Parameters:
        ///     - message: Base64 encoded message or transaction
        ///
        /// - Returns: The Base64 encoded computed signature
        ///
        /// - Throws: an error if signing the message is unsuccessful
        func signMessage(message: String) async throws -> String
    }
    ```

    #### Example

    ```swift
    if let user = privy.user {
        // If user not null, user is authenticated
        do {
            // Retrieve list of user's embedded Solana wallets
            let solanaWallets = user.embeddedSolanaWallets

            // Grab the desired wallet. Here, we retrieve the first wallet
            if let wallet = solanaWallets.first {
                // Base 64 encoded: "Hello! I am the base64 encoded message to be signed."
                let message = "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg=="
                let signature = try await solanaProvider.signMessage(message: message)
                print("Result signature: \(signature)")
            }
        } catch {
            print("Error creating embedded wallet: \(error.localizedDescription)")
        }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/swift/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow this guide to configure an app client by
  following this guide [here](/basics/get-started/dashboard/app-clients).
</Warning>

## Initializing Privy

First, import the **Privy SDK** at the top of the file:

```swift
import PrivySDK
```

Initialize a **Privy** instance with a **`PrivyConfig`** object:

```swift
let config = PrivyConfig(
    appId: "YOUR_APP_ID",
    appClientId: "YOUR_APP_CLIENT_ID",
    loggingConfig: .init(
        logLevel: .verbose
    )
)

let privy: Privy = PrivySdk.initialize(config: config)
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField body="appId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField body="appClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<ParamField body="loggingConfig" type="PrivyLoggingConfig" optional>
  (Optional) Your preferred log level and logging method. If no log level is specified, it will
  default to `PrivyLogLevel.NONE`.
</ParamField>

<ParamField body="customAuthConfig" type="LoginWithCustomAuthConfig" optional>
  (Optional) Only use this if you plan to use custom authentication. Find more information
  [here](/authentication/user-authentication/jwt-based-auth).
</ParamField>

<Tip>
  Be sure to maintain a single instance of Privy across the lifetime of your application.
  Initializing multiple instances of Privy will result in unexpected errors.
</Tip>

## Waiting for Privy to be ready

When the Privy SDK is initialized, the user's authentication state will be set to `NotReady` until Privy finishes initialization. This might include checking if the user has a wallet connected, refreshing expired auth tokens, fetching up-to-date user data, and more.

**It's important to wait until Privy has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

For your convenience, we've added an async `awaitReady()` function that you can use to wait for Privy to finish initializing:

```swift
private func awaitPrivySDKReady() {
    Task {
        // Show loading UI

        // Await privy ready
        await privy.awaitReady()

        print("Privy SDK is ready!")

        // Check user auth state
        if case .authenticated(let privyUser) = privy.authState {
            // User is authenticated
        } else {
            // User is not authenticated
        }
    }
}
```


# Analytics CORS Errors
Source: https://docs.privy.io/basics/troubleshooting/analytics-cors



You may occasionally see CORS errors in your browser console that look like this:

```
Access to fetch at 'https://auth.privy.io/api/v1/analytics_events' from origin has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

These CORS errors are related to background analytics requests and **do not impact your application's functionality**. They are benign errors that can safely be ignored.

The Privy SDK sends anonymous usage analytics in the background, and these requests occasionally trigger CORS warnings in your browser's developer console. While they appear as errors, they do not affect your application's performance or user experience.

<Info>
  Still have questions? Reach out to our [support team](https://privy.io/slack) - we're here to
  help!
</Info>


# Multiple dialogs
Source: https://docs.privy.io/basics/troubleshooting/multiple-dialogs



The Privy modal is an [HTML `<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog) element that will appear in the foreground of your app when opened.

If your app makes use of dialog components (most commonly, for modals and pop-ups), you may encounter issues with the Privy dialog interfering with those from your app.

When using other non-Privy dialog elements within your app, we generally recommend:

* **Avoid UIs that involve a modal overlaying another modal.** This can be a confusing and visually jarring experience for users, especially since users can only interact with a single modal at a time.
* **Use the [`Dialog`](https://headlessui.com/react/dialog) component from [`headless-ui`](https://headlessui.com)**, as it has the best compatibility with UI components and HTML elements from third-party libraries like Privy.

## Radix UI dialogs

If your app uses the [**`Dialog`**](https://www.radix-ui.com/primitives/docs/components/dialog) component from [**Radix UI**](https://www.radix-ui.com), we suggest making the following modifications to the default [**`Dialog`**](https://www.radix-ui.com/primitives/docs/components/dialog) component:

1. Prevent the default behavior of the Radix dialog closing when the user clicks outside of it, via the [**`onPointerDownOutside`**](https://www.radix-ui.com/primitives/docs/components/dialog#content) prop of the [**`Dialog.Content`**](https://www.radix-ui.com/primitives/docs/components/dialog#content) component.
2. Prevent the default behavior of the Radix dialog always trapping the browser's focus (even if other dialogs are opened), by wrapping your[ **`Dialog.Content`**](https://www.radix-ui.com/primitives/docs/components/dialog#content) with the **`FocusScope`** component from the [**`@radix-ui/react-focus-scope`**](https://www.npmjs.com/package/@radix-ui/react-focus-scope) library. In this **`FocusScope`** component, you should set the prop **`trapped`** to `false`. See this [GitHub discussion](https://github.com/radix-ui/primitives/issues/2544) for more info!

Altogether, the modifications to a [**`Dialog`**](https://www.radix-ui.com/primitives/docs/components/dialog) component might look as follows:

```tsx

import * as Dialog from '@radix-ui/react-dialog';
import {FocusScope} from '@radix-ui/react-focus-scope';

<Dialog.Root>
  ...
  <Dialog.Portal>
    <Dialog.Overlay />
    {/* This wrapper prevents the Radix dialog from stealing focus away from other dialogs in the page. */}
    <FocusScope trapped={false}>
        {/* The `onPointerDownOutside` handler prevents Radix from closing the dialog when the user clicks outside. */}
      <Dialog.Content
        onPointerDownOutside={(e) => e.preventDefault()}
      />
        ...
      </Dialog.Content>
    </FocusScope>
  </Dialog.Portal>
<Dialog.Root>
```


# Common framework errors
Source: https://docs.privy.io/basics/troubleshooting/react-frameworks



If you're running into build errors with your framework, check out the following troubleshooting steps:

<Tabs>
  <Tab title="Gatsby">
    If you're using a framework like [Gatsby](https://www.gatsbyjs.com/) and are running into build errors, check out some common errors below, and how to resolve them.

    ## iframe not initialized

    If you encounter an error like the one below:

    ```
    iframe not initialized
    ```

    There is likely an issue with how you are rendering the **`PrivyProvider`** component within your app.

    Namely, **if you are using Gatsby's [`wrapRootElement`](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapRootElement) to wrap your app with the `PrivyProvider`, you should use [`wrapPageElement`](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement) instead**, like below:

    ```tsx gatsby-browser.tsx
    import React from 'react';

    import {PrivyProvider} from '@privy-io/react-auth';

    export const wrapPageElement = ({element}) => {
      return <PrivyProvider appId={'insert-your-app-id'}>{element}</PrivyProvider>;
    };
    ```

    Though Gatsby typically recommends using [**`wrapRootElement`**](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapRootElement) for React Contexts, the **`PrivyProvider`** component contains UI (HTML) elements as well, including a dialog (the Privy modal) and an iframe (the Privy iframe, used for embedded wallets). Given these UI elements, [**`wrapPageElement`**](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement) must be used instead of **`wrapRootElement`**.

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) – we're here to help!
    </Info>
  </Tab>

  <Tab title="NextJS">
    If you're using a framework like [NextJS](https://nextjs.org/) and are running into build errors, check out some common errors below, and how to resolve them.

    ## App router

    If you are using the new [app router](https://nextjs.org/docs/app), you may encounter issues when attempting to wrap your app with the **`PrivyProvider`**. If so, follow the instructions below to set up your app with Privy:

    #### 1. Create a wrapper component for the **`PrivyProvider`**

    Since the **`PrivyProvider`** is a third-party React Context, it can only be used client-side, with the [**`'use client';`**](https://react.dev/reference/react/use-client) directive. Check out [these docs from NextJS](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#using-context-providers) for more information.

    First, create a new component file and add [**`'use client';`**](https://react.dev/reference/react/use-client) as the first line. Then, within this same file, create a custom component (e.g. **`Providers`**) that accepts React [**`children`**](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) as props, and renders these [**`children`**](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children), wrapped by the **`PrivyProvider`**:

    ```tsx
    // components/providers.tsx
    'use client';

    import {PrivyProvider} from '@privy-io/react-auth';

    export default function Providers({children}: {children: React.ReactNode}) {
      return <PrivyProvider appId="insert-your-privy-app-id">{children}</PrivyProvider>;
    }
    ```

    This wrapper component ensures that the **`PrivyProvider`** is only ever rendered client-side, as required by NextJS.

    #### 2. Wrap your app with the providers component in your **`RootLayout`**

    Next, in your app's [Root Layout](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required), wrap the layout's [**`children`**](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) with your providers component, like so:

    ```tsx
    import Providers from '../components/providers';

    export default function RootLayout({children}: {children: React.ReactNode}) {
      return (
        <html lang="en">
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      );
    }
    ```

    Within your [**`RootLayout`**](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required), make sure you are using the wrapper component you created in step (1), *not* the raw **`PrivyProvider`** exported by the SDK.

    **That's it!** You can check out a complete example of Privy integrated into a NextJS app using the App Router [here](https://github.com/privy-io/create-next-app/tree/app-router).

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) – we're here to help!
    </Info>
  </Tab>

  <Tab title="Create React App">
    If you're using a framework like [Create React App](https://create-react-app.dev/) and are running into build errors, check out some common errors and how to resolve them.

    ## Missing Polyfills (Webpack 5)

    Since Create React App uses [Webpack 5](https://webpack.js.org/blog/2020-10-10-webpack-5-release/), you may encounter errors like the one below:

    ```
    BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.
    This is no longer the case. Verify if you need this module and configure a polyfill for it.
    ```

    This is because many standard web3 libraries, such as [`ethers.js`](https://docs.ethers.io/v5/), have dependencies that need to be polyfilled into your build environment. Webpack 5 no longer automatically handles these polyfills, which triggers this error.

    You can work past these issues by explicitly adding in these dependencies and overriding some configurations, as outlined below:

    #### 1. Install dependencies

    Run the following command in your project to install the necessary dependencies:

    ```sh
    npm i --save-dev react-app-rewired assert buffer process stream-browserify url
    ```

    #### 2. Configure your project with `react-app-rewired`

    In your `package.json`, in your start, build, and test scripts, update `react-scripts` to `react-app-rewired`. The "scripts" object should look like the following:

    ```json package.json
    {
        ...,
        "scripts": {
            "start": "react-app-rewired start",
            "build": "react-app-rewired build",
            "test": "react-app-rewired test",
            "eject": "react-scripts eject"
        },
        ...
    }

    ```

    This allows you to bypass the default webpack configurations from `create-react-app`.

    #### 3. Add `config-overrides.js` to your project

    Lastly, at the root of your project, create a file called `config-overrides.js` and paste in the following:

    ```js config-overrides.js
    const webpack = require('webpack');
    module.exports = function override(config) {
      config.resolve.fallback = {
        assert: require.resolve('assert'),
        buffer: require.resolve('buffer'),
        'process/browser': require.resolve('process/browser'),
        stream: require.resolve('stream-browserify'),
        url: require.resolve('url'),
        http: false,
        https: false,
        os: false
      };
      config.plugins.push(
        new webpack.ProvidePlugin({
          process: 'process/browser',
          Buffer: ['buffer', 'Buffer']
        })
      );
      config.ignoreWarnings = [/Failed to parse source map/];
      return config;
    };
    ```

    This tells your browser where to look for the dependencies that you've now added.

    **That's it!**

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) – we're here to help!
    </Info>
  </Tab>

  <Tab title="Vite">
    If you're using a framework like [Vite](https://vitejs.dev/) and are running into build errors, check out some common errors below, and how to resolve them.

    ## `process` is not defined

    If you encounter an error like the one below:

    ```
    Uncaught (in promise) ReferenceError: process is not defined at ../../../node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
    ```

    This is due to an issue in one of Privy's necessary dependencies, the [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk). You can read more about the issue [here](https://github.com/coinbase/coinbase-wallet-sdk/issues/967).

    **To resolve the issue, we recommend using the [`vite-plugin-node-polyfills`](https://www.npmjs.com/package/vite-plugin-node-polyfills) package, which will polyfill the `process` dependency that Coinbase requires.**

    #### 1. Install **`vite-plugin-node-polyfills`**

    First, install [**`vite-plugin-node-polyfills`**](https://www.npmjs.com/package/vite-plugin-node-polyfills) as a dev dependency:

    ```sh
    npm i --save-dev vite-plugin-node-polyfills
    ```

    #### 2. Update your **`vite.config.ts`**

    Then, update your [**`vite.config.ts`**](https://vitejs.dev/config/) file to include the following to use the plugin:

    ```ts
    import {defineConfig} from 'vite';
    import {nodePolyfills} from 'vite-plugin-node-polyfills';

    // https://vitejs.dev/config/
    export default defineConfig({
      plugins: [nodePolyfills()]
    });
    ```

    **That's it!**

    <Info>
      Still have questions? Reach out to our [support team](https://privy.io/slack) - we're here to help!
    </Info>
  </Tab>
</Tabs>


# Styles
Source: https://docs.privy.io/basics/troubleshooting/styles



If you're running into issues with the styles of Privy's UIs in your app, check out some common errors below, and how to resolve them.

### Corrupted styles with Sentry

If your application uses [**Sentry**](https://sentry.io/welcome/) for monitoring, and you are seeing corrupted styles in Privy's UIs, it may be due to a bug with certain versions of Sentry's JavaScript libraries (e.g. [**`@sentry/react`**](https://www.npmjs.com/package/@sentry/react) and [**`@sentry/nextjs`**](https://www.npmjs.com/package/@sentry/nextjs)). **See this [GitHub issue](https://github.com/getsentry/sentry-javascript/issues/9170#issuecomment-1761391585) for more information.**

To resolve this issue, try upgrading your **`@sentry/*`** package to a **version higher than `7.74.0`**.


# Embedded wallets
Source: https://docs.privy.io/basics/troubleshooting/troubleshooting-embedded-wallets



**If you're running into issues with creating and using embedded wallets in your app, check out some common errors below, and how to resolve them.**

## Embedded wallets created on `localhost`, but not on deployment

If you are able to successfully create embedded wallets for your users on **`localhost`**, but not in a deployed environment, **double-check that the protocol for your deployment URL is `https://` (secure), and *not* `http://`**. Privy embedded wallets use the browser's native [WebCrypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API), which is only available in secure contexts like **`https://`**.

**In kind, you *must* use a secure context (`https://`) for your deployment.** Embedded wallets will *not* be created or work in insecure contexts like **`http://`**, except **`localhost`**, which is a special case and treated by the browser as a secure context.

## Access to the Base RPC URL has been blocked by CORS

If you're using embedded wallets on Base or Base Goerli, and see the following error:

```
Access to fetch at 'https://base-mainnet.blastapi.io/insert-api-key' from origin 'insert-your-origin' has been blocked by CORS policy...
```

**This likely indicates that your IP address has been rate limited by the Blast RPC URL for making too many requests within a short time window.**

Though this may appear to be a CORS violation, the initial error sent by Blast should indicate this rate limit (with a 429 status code). Successive errors due to the rate limit may not include the required CORS headers, which is why the overall error message appears as a CORS violation.

**If you are seeing this issue, please try again shortly.** If it still does not resolve, please [reach out](https://privy.io/slack) and we can help debug!


# Using LLMs
Source: https://docs.privy.io/basics/troubleshooting/using-llms



Privy's docs are LLM-friendly to help developers integrate with Privy faster.

## Use the Privy docs llms-full.txt file

You can provide your code editor with a `llms-full.txt` file to use Privy's docs as a context for your code. The following steps show how to do this for [Cursor](https://www.cursor.com/).

1. Navigate to **Cursor Settings** > **Features** > **Docs**

2. Select "Add new doc" and paste the following URL:

   ```
   https://docs.privy.io/llms-full.txt
   ```

3. Use `@docs -> Privy` to reference Privy's docs in your code.


# null
Source: https://docs.privy.io/basics/unity/installation



## Supported Platforms

* ✅ MacOS / iOS
* ✅ Android
* ✅ WebGL
* ❌ Windows
* ❌ Linux

## Installation

Privy's Unity SDK is distributed as a `.unitypackage` file, and is not yet available in Unity's package manager. To import the SDK:

1. Request access from [`sales@privy.io`](mailto:sales@privy.io)
2. Download the `.unitypackage` file
3. Open your project in the Unity editor
4. Select Assets → Import Package → Custom Package:

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/unity-setup/installing-unity-package.png" />
</Frame>

5. Confirm the import of the custom package. A window will pop up listing all the assets included in the package; click **Import** to add all the assets to your project.

<Note>
  Privy's Unity package includes dependencies such as `Newtonsoft.Json` and `unity-webview`. If your
  project already includes these packages, the Unity Editor should automatically detect them and
  uncheck them by default. However, if this doesn't happen, you should manually deselect these
  packages during the import process to avoid potential duplicate instances, which could lead to
  errors.
</Note>

## Using the Privy Namespace

All Privy classes in Unity live in the `Privy` namespace. At the top of each file that uses Privy, you must add the `using Privy` directive:

```csharp
using Privy;
```

## WebGL Setup

Privy's Unity SDK leverages an iframe to [secure the key material]() for a user's embedded wallet. Given the use of an iframe, we recommend testing builds with Privy's Unity SDK in the **browser**, or on a **non-WebGL platform** in the Unity editor.

<Tip>
  Watch this [demo](https://www.loom.com/share/0bac8322368c44059dff51e2dfc548e8) of setting up the
  Privy SDK in a Unity Project!
</Tip>

To configure settings for your WebGL build to work with Privy, go to your **Project Settings** in the Unity editor. Next, select **Player** and navigate to **WebGL**. Set the following values:

* In **Resolution and Presentation**, select `unity-webview`, or `unity-webview-2020` as the template if you are using a Unity editor version newer than 2020.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/unity-setup/webview-template.png" alt="" />
</Frame>

* In **Other Settings/Optimization**, **managed stripping level** to **minimal**

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/unity-setup/webview-stripping-settings.png" alt="" />
</Frame>

<Note>
  The following versions of the Unity editor are not supported, due to [this
  bug](https://issuetracker.unity3d.com/issues/webgl-cross-origin-embedder-policy-require-corp-http-header-is-included-when-multithreading-is-off):
  `2022.3.20f1`, `2022.3.40f1`, `2023.2.12f1`, `6000.0.0b11`.
</Note>


# Quickstart
Source: https://docs.privy.io/basics/unity/quickstart

Learn how to authenticate users, create embedded wallets, and send transactions in your Unity app

## Prerequisites

This guide assumes that you have completed the [setup](/basics/unity/setup) guide.

## Authenticate your user

<Tip>
  This quickstart guide will demonstrate how to authenticate a user with a one time password as an
  example, but Privy supports many authentication methods. Explore our [Authentication
  docs](/authentication/overview) to learn about other methods such as socials, passkeys, and
  external wallets to authenticate users in your app.
</Tip>

Privy offers a variety of authentication mechanisms. The example below showcases authenticating a user via email.

This is a two step process:

1. Send an OTP to the user provided email address.
2. Verify the OTP sent to the user.

### 1. Send an OTP to the user's email address

After collecting and validating your users email, send an OTP by calling the **`SendCode`** method.

```csharp
bool success = await PrivyManager.Instance.Email.SendCode(email);

if (success)
{
	// Prompt user to enter the OTP they received at their email address through your UI
}
else
{
  // There was an error sending an OTP to your user's email
}
```

### 2. Authenticate with OTP

The user will then receive an email with a 6-digit OTP. Prompt the user for this OTP within your application, then authenticate the user with the **`loginWithCode`** method. As a parameter to this method, pass an object with the following fields:

<ParamField name="email" type="String">
  The user's email address.
</ParamField>

<ParamField name="code" type="String">
  OTP code inputted by the user in your app.
</ParamField>

```csharp
try
{
    // User will be authenticated if this call is successful
    await PrivyManager.Instance.Email.LoginWithCode(email, code);
}
catch
{
    // If "LoginWithCode" throws an exception, user login was unsuccessful.
    Debug.Log("Error logging user in.");
}
```

This method will throw an error if:

* the incorrect OTP code is inputted
* the network call to authenticate the user fails

## The embedded wallet

<Tabs>
  <Tab title="Ethereum">
    ### Create an embedded wallet

    Privy's embedded wallets are currently only compatible with the Ethereum blockchains.

    To create an embedded wallet for your user, call the `CreateWallet` method on the `PrivyUser`.

    ```csharp
    try {
        PrivyUser privyUser = PrivyManager.Instance.User;

        if (privyUser != null) {
            IEmbeddedEthereumWallet wallet = await PrivyManager.Instance.User.CreateWallet();
            Debug.Log("New wallet created with address: " + wallet.address);
        }
    } catch {
        Debug.Log("Error creating embedded wallet.");
    }
    ```

    This method will throw an error if:

    * the user is not authenticated
    * the user already has an embedded wallet
    * wallet creation fails on the user's device

    To use embedded wallets, Privy implements an `RpcProvider` on the `EmbeddedWallet` class of the Unity SDK. This is an EIP1193 provider is responsible for managing RPC requests to a user's embedded wallet.

    Currently, Privy's `RpcProvider` only supports the `personal_sign` and `eth_signTypedData_v4` RPCs. We are actively adding support for other methods.

    #### 1. Get the user's wallet

    To make an RPC request to a user's wallet, first get the user's embedded wallet like so:

    ```csharp
    // Ensure user is authenticated / non null

    PrivyUser privyUser = PrivyManager.Instance.User;

    if ( privyUser != null ) {
    	// Grab the embedded wallet from the embedded wallet list
    	// For demonstration purposes we're just grabbing the first one.
    	IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallet[0];

    	//Ensure the Wallet is not null
    	if ( embeddedWallet != null ) {
    		//wallet operations
    	}
    }

    ```

    #### 2. Construct your RPC request

    Next, construct the RPC request using the `RpcRequest` class from Privy. The class follows the interface below:

    ```csharp
    public class RpcRequest
    {
        public string Method { get; set; }
        public string[] Params { get; set; }

    }
    ```

    As an example, you can construct a new RPC request like so.

    ```csharp
    var rpcRequest = new RpcRequest
    {
        Method = "personal_sign", //a supported method
        Params = new string[] { "A message to sign", embeddedWallet.Address } //an array of strings, with the message + address
    };
    ```

    #### 3. Execute the RPC request

    Now, simply pass the `rpcRequest` you constructed to the `RpcProvider`'s `Request` method to execute the request:

    ```csharp
    try {
    	//Now that the response has been constructed, we try to execute the request
    	RpcResponse personalSignResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

    	//If response is successful, we can parse out the data
    	Debug.Log(personalSignResponse.Data)
    } catch (PrivyException.EmbeddedWalletException ex){
    		//If the request method fails, we catch it here
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
    		//If there's some other error, unrelated to the request, catch this here
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    This will return an `RpcResponse`, which implements the interface below:

    ```csharp
    public class RpcResponse
    {
        public string Method { get; set; }
        public string Data { get; set; }

    }
    ```

    #### Handling errors

    The provider's `Request` method may error if:

    * the user is not authenticated
    * the user's wallet does not exist or has not loaded on their device
    * there is an issue with the RPC request that was sent to the wallet

    These errors can be caught through a generic exception, or Privy's custom `AuthenticationException` or `EmbeddedWalletException`:

    ```csharp
    catch (PrivyException.AuthenticationException ex)
    {
        Debug.LogError($"Error signing message, Type:{ex.Error}, Message:{ex.Message}");
    }
    catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch {
    	  Debug.LogError("Error signing message");
    }

    ```

    ### Full example

    As a complete example, you can send an RPC request to a wallet and handle corresponding errors like so:

    ```csharp
    try {
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];

        var rpcRequest = new RpcRequest
        {
            Method = "personal_sign",
            Params = new string[] { "A message to sign", embeddedWallet.Address }  // Use the 'new' keyword here
        };

        RpcResponse personalSignResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

        Debug.Log(personalSignResponse.Data);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/basics/unity/setup



## Prerequisites

Before you begin, make sure you have [set up your Privy app and obtained your app ID](/basics/get-started/dashboard/create-new-app) and [client ID](/basics/get-started/dashboard/app-clients) from the Privy Dashboard.

<Warning>
  A properly set up app client is required for mobile apps and other non-web platforms to allow your
  app to interact with the Privy API. Please follow this guide to configure an app client by
  following this guide [here](/basics/get-started/dashboard/app-clients).
</Warning>

## Initializing Privy

Initialize Privy as early as possible in your game's lifecycle by calling `PrivyManager.Initialize(PrivyConfig config)`:

```csharp
var config = new PrivyConfig{
    AppId = "YOUR_APP_ID",
    ClientId = "YOUR_CLIENT_ID"
};

PrivyManager.Initialize(config);
```

## Configuration

The configuration fields for the PrivyConfig are:

<ParamField name="AppId" type="String" required>
  Your Privy application ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Basics
</ParamField>

<ParamField name="ClientId" type="String" required>
  Your app client ID, which can be obtained from the [**Privy Developer
  Dashboard**](https://dashboard.privy.io), under App Settings > Clients
</ParamField>

<Tip>
  Be sure to initialize Privy only once at the start of your game. Initializing multiple instances
  of Privy will result in unexpected errors.
</Tip>

## Waiting for Privy to be ready

When the Privy SDK first initializes, the user's `AuthState` will be set to `NotReady` until Privy finishes initialization. This might include refreshing a user's access token, fetching the updated user object, loading the embedded wallet iframe, and more.

**It's important to wait until Privy has finished initializing *before* you consume Privy's state and interfaces**, to ensure that the state you consume is accurate and not stale.

To determine whether the Privy SDK has fully initialized, you can use the `AwaitReady()` function:

```csharp
// Show loading screen

// Initialize Privy

// Await Privy ready
await PrivyManager.AwaitReady();

// Privy is ready, show loaded screen
```

You can also check whether Privy is ready at any time by calling:

```csharp
bool isReady = PrivyManager.Instance.IsReady;
```


# null
Source: https://docs.privy.io/controls/authorization-keys/creating-authorization-keys



You can create an authorization key in the Dashboard or locally. During resource creation, specify the public key as the `owner`.

Keys are required to sign all requests to update a resource. Furthermore, a wallet's owner is required to sign all requests to take actions with the wallet (`POST /v1/wallets/<wallet_id>/rpc`).

<Tabs>
  <Tab title="Dashboard">
    To create a new authorization key in the Dashboard, visit the [**Authorization keys**](https://dashboard.privy.io/apps?page=authorization-keys) page for your app.

    Click the **New key** button and copy and save the generated **Private key**. Privy does not save this key and cannot help you recover it later. You can also set a human-readable **Key name**.

    In this process, Privy generates a keypair for your app directly on your device, and shows you the private key.

    * The private key (e.g. the key you copy) is generated on your device, and is only ever known to your app. Neither Privy nor the secure enclave ever sees the private key, and cannot sign payloads with it.
    * The public key is registered with the secure enclave that secures your wallets, and is used to verify signatures produced by your app.

    <Warning>
      **Privy does not store the private key and cannot help you retrieve it.**
    </Warning>
  </Tab>

  <Tab title="Locally">
    Authorization keys are [P-256](https://neuromancer.sk/std/nist/P-256) public-private keypairs. **Make sure to save the private key, as Privy does not store this and cannot help you recover it.**

    You can create a keypair with the following command:

    ```sh
    openssl ecparam -name prime256v1 -genkey -noout -out private.pem && \
    openssl ec -in private.pem -pubout -out public.pem
    ```

    Once you have generated your keypair, you can specify the public key in the `owner` field during resource creation or by updating the resource. You do not need to register it with Privy beforehand.
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/controls/authorization-keys/overview



Authorization keys provide an additional layer of security for actions taken by your app's wallets. These cryptographic keys help ensure that only actions explicitly authorized by your server are executed on user wallets.

## Overview

When you specify an `owner` of a resource, all requests to update that resource **must be signed** with this key. Requests to take actions with a wallet **must also be signed by the wallet's owner**. This security measure verifies that each request comes from your authorized backend systems and helps prevent unauthorized operations.

<Frame>![Authorization keys](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/authkeys.png)</Frame>

## Security implications

* **With authorization keys**: All wallet actions require a valid signature from your server in addition to your app secret, ensuring that only your application can initiate actions.
* **Without authorization keys**: Privy will only require your app secret for wallet actions, which provides less security for production environments.

<Info>
  While authorization keys are optional, we strongly recommend enabling them for all production
  applications to ensure maximum security for your users' assets.
</Info>

## When to use authorization keys

Authorization keys are particularly important when:

* Your app performs delegated actions on behalf of users.
* You're handling financial transactions or sensitive operations.
* You want to prevent potential abuse from unauthorized parties.
* Your application is in production with real users and assets.

## How to set up authorization keys

[Create authorization keys](/controls/authorization-keys/creating-authorization-keys) locally or via the Dashboard and configure this key as the `owner` of your resource (e.g. a wallet or policy). See our [SDK integration guide](/basics/nodeJS/setup) or [REST API documentation](/api-reference/authorization-signatures) for detailed implementation instructions for signing requests.


# Client-managed
Source: https://docs.privy.io/controls/authorization-keys/user-authorization-keys/client-managed



<Info>
  User authorization keys enable users to fully control self-custodial wallets. All Privy
  client-side SDKs enable **fully user self-custodial wallets by default**.
</Info>

Privy client-side SDKs enable fully user self-custodial wallets by default via fully-managed **authorization keys**.

Client-side user authorization keys are time-bound authorization keys available via Privy client SDKs, and issued on the user's device. These authorization keys are **managed internally** by Privy client SDKs and are used to authenticate with Privy's wallet API. User authorization keys are only accessible when the user is authenticated.

If you are using Privy via a client-side SDK, user authorization keys are **entirely invisible**—you do not have to manually interact with authorization keys in order to create or transact with wallets.

Learn more about the [User authorization key API architecture here](/security/authentication/authenticated-signers).

### Signing using client-managed user authorization keys

<Info>
  Interacting directly with user authorization keys is an **advanced setting**.

  This interface is currently in development and will be available in an upcoming release.
</Info>

For some **advanced integrations**, your app may need to interact with your users' authorization keys directly. For example, if your app requires 2-of-2 quorum approvals from both the user's authorization key and a service-controlled key, then you may need to collect a user signature first.

Privy client SDKs enable you to sign with your user's authorization key directly. Typically, this interface is used to sign user-authorized requests, which are then sent to the Privy wallet API.
Include the resulting authorization signature as a request header when [making requests to the wallet API](/controls/authorization-keys/overview).

## Usage

<Tabs>
  <Tab title="React">
    To sign with your user's authorization key directly, use the **`useUserAuthorizationKey`** hook. This hook exposes an interface to access the public key of the user's authorization key and to request signatures using the authorization key.

    ```tsx
    const { authorizationKey } = useUserAuthorizationKey();

    // This is the public key associated with the user's authorization key.
    authorizationKey.publicKey;

    // Sign a wallet API request using the user's authorization key.
    // This generates a P-256 cryptographic signature over the input.
    const authorizationSignature = await authorizationKey.request({
      method: 'sign',
      params: walletRequestBody,
    });
    ```
  </Tab>
</Tabs>


# Directly managed
Source: https://docs.privy.io/controls/authorization-keys/user-authorization-keys/directly-managed



<Info>
  Directly managing user authorization keys via the API is an advanced setting. We recommend using
  Privy's SDKs, which internally manage user authorization keys if applicable.
</Info>

**Self-custodial** Privy wallets are those owned by an authorization key that the user controls. These user-controlled authorization keys are typically managed internally by Privy client SDKs.

For some **advanced integrations**, your app may need to interact with your users' authorization keys directly, outside of a managed client SDK context. This is done via the **User authorization key API**.

This API issues time-bound authorization keys that enable access to user wallets and can be called from either your app's frontend or backend. You can learn more about the [user authorization key API architecture here](/security/authentication/authenticated-signers).

## Creating a user-associated wallet

Send a `POST` request to the [create user](/api-reference/signers/create) endpoint to create a user and associated wallet.

<Info>
  If applicable, first register your JWT verification public key or JWKS.json endpoint via the Privy
  Dashboard.
</Info>

## Transacting with a wallet

To transact with a wallet, you will make a request to the user authorization key API to obtain a time-bound authorization key, which you will use to sign requests to the wallet API.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/api-signer.png" alt="Server-side user authorization keys" />
</Frame>

### Retrieving a time-bound authorization key

To request a time-bound authorization key, send a `POST` request to the [authenticate](/api-reference/signers/authenticate) endpoint with a valid user JWT.

### Initiating a transaction

To transact with a wallet, use the user's time-bound authorization key to [authorize](/controls/authorization-keys/overview) requests to the user's wallet via the wallet API [`RPC` endpoint](/api-reference/wallets/ethereum/eth-send-transaction).


# Overview
Source: https://docs.privy.io/controls/authorization-keys/user-authorization-keys/overview



<Info>
  Authorization keys enable users to fully control self-custodial wallets within a **trusted
  execution environment (TEE)**. They are not applicable for on-device wallets.
</Info>

<Note>
  Interacting directly with user authorization keys is an **advanced setting**.

  If you are using Privy via a client-side SDK, user authorization keys are **entirely invisible**—you do not have to manually interact with authorization keys in order to create or transact with wallets.
</Note>

**Self-custodial** Privy wallets are those owned by an authorization key that the user controls. For example, you can configure fully user self-custodial wallets by:

* Authenticating a user with the **User authorization key API** to issue an authorization key
* Directly adding the user's **passkey** as the authorization key

**User authorization keys** are authorization keys that users control directly via an authentication method. Privy infrastructure manages issuing time-bound authorization keys to users via the **User authorization key API**. This configuration results in cryptographically-enforced user custody of wallets.

Learn more about the [User authorization key API architecture here](/security/authentication/authenticated-signers).

<Tip>All Privy client-side SDKs enable **fully user self-custodial wallets by default**.</Tip>

## Authentication methods

Privy integrates directly with any OIDC or JWT-based authentication system and also offers [dozens of login methods natively](/authentication/overview#user-authentication), including email, SMS, social login, passkeys, and more. The User authorization key API ensures that if a user is logged in, they **always** have access to their wallet.


# Policies & controls
Source: https://docs.privy.io/controls/overview



Privy's wallet system offers powerful yet flexible control options that determine who can access and use wallets. These controls serve as the foundation for wallet security while ensuring a seamless user experience.

## Security without compromise

Privy wallets are designed with security at their core. Our approach uses a combination of key splitting (Shamir's secret sharing) and private key reconstitution in secure execution environments to ensure that only authorized parties can access their wallets. Wallets remain fully non-custodial and users ultimately have full control over their assets.

## Flexible owner configurations

Whether you want users to have complete control of their wallets or your application needs to manage certain aspects, Privy's control model can be configured to match your exact requirements. This enables setups like:

* **User self-custody**: Give users full control over their wallets.
* **Session signers**: Users can allow apps to take certain actions on their behalf.
* **Application-managed wallets**: Maintain certain controls at the service level.
* **Shared control**: Require a quorum of parties are required to approve certain actions.

## Robust policies

Policies are rules that govern what actions can be taken with a wallet. Think of them as guardrails that ensure wallets are only used for intended purposes.

* **Transaction limits**: Set maximum amounts that can be transferred.
* **Approved destinations**: Specify recipients where funds can be sent.
* **Contract interactions**: Control which smart contracts can be used.
* **Action parameters**: Define what specific operations are permitted.

Policies help protect users and applications by preventing unauthorized or unintended actions, making them essential for features like payment subscriptions, trading limits, or scheduled transactions.

![images/Policies.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Policies.png)

## Enhanced security options

Privy supports additional security measures for sensitive wallet operations include:

* Multi-factor authentication using TOTP, passkeys, and SMS
* Biometric verification
* Hardware security key support
* And more

## Getting started

To learn more about implementing specific controls and policies for your application, explore our detailed documentation on [wallet policies and controls](/security/wallet-infrastructure/policy-and-controls).


# null
Source: https://docs.privy.io/controls/policies/create-a-policy



You can create a policy using the Privy Dashboard, the NodeJS SDK, or the REST API.

Policies optionally have owners, which represent the signatures required to modify the policy after creation, see [setting authorization signatures](/api-reference/authorization-signatures).

<Tip>
  We highly recommend specifying owners for your policies to further restrict the parties that can
  modify them. Without an owner, the policies can be updated by your app secret alone.
</Tip>

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`createPolicy`** method to create a new policy.

    ```tsx
    const policy = await privy.walletApi.createPolicy({
      name: 'Allow list certain smart contracts',
      version: '1.0',
      chainType: 'ethereum',
      rules: [
        {
          name: 'Allow list USDC',
          method: 'eth_sendTransaction',
          action: 'ALLOW',
          conditions: [
            {
              fieldSource: 'ethereum_transaction',
              field: 'to',
              operator: 'eq',
              value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            }
          ]
        }
      ],
      ownerId: 'fmfdj6yqly31huorjqzq38zc'
    });
    ```
  </Tab>

  <Tab title="REST API">
    To create a new policy, make a `POST` request to:

    ```sh
    https://api.privy.io/v1/policies
    ```

    <Tip>
      In the request headers, make sure to include Privy's [required authentication
      headers](/basics/rest-api/setup#authentication) and [headers that may be required for your app's
      wallet API setup](/basics/rest-api/quickstart#2-sign-a-message).
    </Tip>

    ## **Body**

    In the request body, include the following:

    <ParamField path="version" type="'1.0'">
      Version of the policy. Currently, 1.0 is the only version.
    </ParamField>

    <ParamField path="name" type="string">
      Name to assign to policy.
    </ParamField>

    <ParamField path="chain_type" type="'ethereum'">
      Chain type for wallets that the policy will be applied to.
    </ParamField>

    <ParamField path="rules" type="Rule">
      A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rule`s](/controls/policies/overview#rules).
    </ParamField>

    <ParamField type="{public_key: string} | null" path="owner">
      The P-256 public key of the owner of the policy. If you provide this, do not specify an owner\_id
      as it will be generated automatically.
    </ParamField>

    <ParamField type="string | null" path="owner_id">
      The key quorum ID of the owner of the policy. If you provide this, do not specify an owner.
    </ParamField>

    Once you have successfully created a policy, you can assign that policy to server wallets at [creation](/wallets/wallets/create/from-my-server).

    <Info>
      Currently, the policy engine supports the `eth_signTransaction` and `eth_sendTransaction` RPC
      methods and the `ethereum_transaction` field source. We are actively expanding support
      [here](/controls/policies/overview#rules).
    </Info>

    ## **Response**

    If the policy is created successfully, the response will include the request body as well as an additional unique `id` field for the policy.

    <ResponseField name="id" type="string">
      Unique ID for the policy.
    </ResponseField>

    <ResponseField name="version" type="'1.0'">
      Version of the policy. Currently, 1.0 is the only version.
    </ResponseField>

    <ResponseField name="name" type="string">
      Name to assign to policy.
    </ResponseField>

    <ResponseField name="chain_type" type="'ethereum'">
      Chain type for wallets that the policy will be applied to.
    </ResponseField>

    <ResponseField name="rules" type="Rule[]">
      A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rule`s](/controls/policies/overview#rules).
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the policy, whose signature is required to modify the policy.
    </ResponseField>

    ## Example

    As an example, a sample request to create a new `eth_sendTransaction` policy might look like the following:

    ```bash
    $ curl --request POST https://api.privy.io/v1/policies \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "version": "1.0",
        "name": "Allow list certain smart contracts",
        "chain_type": "ethereum",
        "rules": [{
          "name": "Allow list USDC",
          "method": "eth_sendTransaction",
          "conditions": [
              {
                  "field_source": "ethereum_transaction",
                  "field": "to",
                  "operator": "eq",
                  "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
              }
          ],
          "action": "ALLOW"
        }],
        "owner": {
          "public_key": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/ckqE2CItVIG1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/C9yjhboIuoPD3g=="
        }
    }'
    ```

    A successful response will look like the following:

    ```json
    {
      "id": "fmfdj6yqly31huorjqzq38zc",
      "name": "Allow list certain smart contracts",
      "version": "1.0",
      "chain_type": "ethereum",
      "rules": [
        {
          "name": "Allow list USDC",
          "method": "eth_sendTransaction",
          "conditions": [
            {
              "field_source": "ethereum_transaction",
              "field": "to",
              "operator": "eq",
              "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
            }
          ],
          "action": "ALLOW"
        }
      ],
      "owner_id": "fmfdj6yqly31huorjqzq38zc"
    }
    ```
  </Tab>
</Tabs>


# Ethereum examples
Source: https://docs.privy.io/controls/policies/example-policies/ethereum



## Allow list a specific smart contract

```ts
{
    version: '1.0',
    name: 'Allowlisted contracts',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Allow list the USDC address',
            method: 'eth_sendTransaction',
            action: 'ALLOW'
            conditions: [
                {
                    field_source: 'ethereum_transaction',
                    field: 'to',
                    operator: 'eq',
                    value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
                },
            ]
        },
        {
            name: 'Allow list for Base specifically',
            method: 'eth_signTypedData_v4',
            action: 'ALLOW'
            conditions: [
                {
                    field_source: 'ethereum_typed_data_domain',
                    field: 'chainId',
                    operator: 'eq',
                    value: '8453'
                }
            ]
        }
    ],
}
```

## Configure a max transfer value of ETH

```ts
{
    version: '1.0',
    name: 'Native token transfer maximums',
    chain_type: 'ethereum',
    rules: [{
        name: 'Restrict ETH transfers to a maximum value',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'value',
                operator: 'lte',
                value: '0x2386F26FC10000',
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Configure a max transfer value of an ERC20 token

```ts
{
    version: '1.0',
    name: 'ERC20 maximums'
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Restrict USDC transfers on Base to be less than or equal to some value',
            method: 'eth_sendTransaction',
            conditions: [
                {
                    field_source: 'ethereum_transaction',
                    field: 'to',
                    operator: 'eq',
                    value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
                },
                {
                    field_source: 'ethereum_calldata',
                    // 'transfer' must match the function name, 'amount' must match an input name.
                    field: 'transfer.amount',
                    abi: [{
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "recipient",
                                "type": "address"
                            },
                            {
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            }
                        ],
                        "name": "transfer",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "",
                                "type": "bool"
                            }
                        ],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }],
                    operator: 'lte',
                    value: '0x2386F26FC10000',
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Specify chain',
            method: 'eth_signTypedData_v4',
            conditions: [{
                field_source: 'ethereum_typed_data_domain',
                field: 'chainId',
                operator: 'eq',
                value: '8453'
            }],
        }
    ]
}
```

## Denylist recipients of a transaction

```ts
{
    version: '1.0',
    name: 'Deny listed addresses',
    chain_type: 'ethereum',
    rules: [{
        name: 'Deny interactions with the USDC contract',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'to',
                operator: 'eq',
                value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            },
        ],
        action: 'DENY'
    }]
}
```

## Enforce policies across multiple RPC methods

```ts
{
    version: '1.0',
    name: 'Example policy with multiple RPC methods',
    chain_type: 'ethereum',
    rules: [{
        name: 'Deny interactions with the USDC contract',
        method: 'eth_sendTransaction',
        conditions: [
            {
                field_source: 'ethereum_transaction',
                field: 'to',
                operator: 'eq',
                value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            },
        ],
        action: 'DENY'
    }, {
        name: 'Only allow certain messages to be signed',
        method: 'personal_sign',
        conditions: [
            {
                field_source: 'ethereum_message',
                field: 'value',
                operator: 'eq',
                value: 'Hello world'
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Allow all requests for a given RPC method

```ts
{
    version: '1.0',
    name: 'Example policy to allow all personal_sign requests',
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow all EIP191 messages to be signed',
        method: 'ethereum_message',
        conditions: [{
            field_source: 'ethereum_message',
            field: 'value',
            operator: 'eq',
            value: '*' // Allow all
        }],
        action: 'ALLOW'
    }]
}
```

## Restrict typed data domains to a specific chain ID and verifying contract

```ts
{
    version: '1.0',
    name: 'Example policy to allow a specific signing domain',
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow specific domain to sign messages',
        method: 'eth_signTypedData_v4',
        conditions: [
            {
                field_source: 'ethereum_typed_data_domain',
                field: 'chainId',
                operator: 'eq',
                value: '8453'
            },
            {
                field_source: 'ethereum_typed_data_domain',
                field: 'verifyingContract',
                operator: 'eq',
                value: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
            }
        ],
        action: 'ALLOW'
    }],
}
```

## Restrict parameters of a typed data message

```ts
{
    version: '1.0',
    name: 'Allow ERC20 Permits for known owners, max value',
    chain_type: 'ethereum',
    rules: [{
        name: 'Allow specific owner addresses and a max value',
        method: 'eth_signTypedData_v4',
        conditions: [
            {
                field_source: 'ethereum_typed_data_message',
                typed_data: {
                    types: {
                        Person: [
                            {name: 'name', type: 'string'},
                            {name: 'wallet', type: 'address'},
                        ],
                        Permit: [
                            {name: 'owner', type: 'Person'},
                            {name: 'spender', type: 'Person'},
                            {name: 'value', type: 'uint256'},
                            {name: 'deadline', type: 'uint256'},
                            {name: 'v', type: 'uint8'},
                            {name: 'r', type: 'bytes32'},
                            {name: 's', type: 'bytes32'},
                        ],
                    },
                    primary_type: 'Permit',
                },
                field: 'owner.wallet', // dot-separated path to primitive 'address' type that 'value' will be compared against.
                operator: 'in',
                value: ['0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', '0x123589fCD6eDb6E08f4c7C32D4f71b54bdA02911'],
            },
            {
                field_source: 'ethereum_typed_data_message',
                typed_data: {
                    types: {
                        Person: [
                            {name: 'name', type: 'string'},
                            {name: 'wallet', type: 'address'},
                        ],
                        Permit: [
                            {name: 'owner', type: 'Person'},
                            {name: 'spender', type: 'Person'},
                            {name: 'value', type: 'uint256'},
                            {name: 'deadline', type: 'uint256'},
                            {name: 'v', type: 'uint8'},
                            {name: 'r', type: 'bytes32'},
                            {name: 's', type: 'bytes32'},
                        ],
                    },
                    primary_type: 'Permit',
                },
                field: 'value',
                operator: 'lte',
                value: '0x2386F26FC10000',
            },
        ],
        action: 'ALLOW'
    }],
}
```

## Prevent private key exports while allowing other actions

```ts
{
    version: '1.0',
    name: 'Prevent private key exports',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Block private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'DENY'
        },
        {
            name: 'Allow all other actions',
            method: '*',
            conditions: [],
            action: 'ALLOW'
        }
    ]
}
```

## Only permit private key exports

```ts
{
    version: '1.0',
    name: 'Only allow private key exports',
    chain_type: 'ethereum',
    rules: [
        {
            name: 'Allow private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'ALLOW'
        },
        {
            name: 'Block all other actions',
            method: '*',
            conditions: [],
            action: 'DENY'
        }
    ]
}
```

## Anti patterns

### Avoid adding rules that may override other rules

```ts
{
    version: '1.0',
    name: 'Restrict the maximum value of ETH transfers',
    chain_type: 'ethereum',
    rules: [
        {
            // This rule restricts the value of ETH transfers.
            name: 'Restrict ETH transfers to 1',
            method: 'eth_sendTransaction',
            conditions: [
                {
                    field_source: 'ethereum_transaction',
                    field: 'value',
                    operator: 'lte',
                    value: '1'
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Restrict ETH transfers to 5',
            method: 'eth_sendTransaction',
            conditions: [
                // This rule will override the previous rule by allowing a 5 ETH transfer.
                {
                    field_source: 'ethereum_transaction',
                    field: 'value',
                    operator: 'lte',
                    value: '5'
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```


# Solana examples
Source: https://docs.privy.io/controls/policies/example-policies/solana



## Allowlist specific Solana Programs

```ts
{
    version: '1.0',
    name: 'Allowlisted programs'
    chain_type: 'solana',
    rules: [{
        name: 'Allowlist the Compute Budget Program and System Program',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used only to allowlist Solana Programs.
                field_source: 'solana_program_instruction',
                field: 'programId',
                operator: 'in',
                value: ['ComputeBudget111111111111111111111111111111', '11111111111111111111111111111111']
            }
        ],
        action: 'ALLOW'
    }]
}
```

## Allow a SOL Transfer instruction with a max value

```ts
{
    version: '1.0',
    name: 'SOL transfer maximums'
    chain_type: 'solana',
    rules: [{
        name: 'Restrict SOL transfers to a maximum value',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.lamports',
                operator: 'lte',
                value: '1000000000' // 1 SOL
            },
        ],
        action: 'ALLOW'
    }]
}
```

### Allow a SOL Transfer instruction with a max value to allowlisted recipients

```ts
{
    version: '1.0',
    name: 'Restrict SOL transfers to a specific recipient'
    chain_type: 'solana',
    rules: [{
        name: 'Restrict SOL transfers to a maximum value to a specific recipient',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This condition restricts the value of all SOL transfers to <= 1 SOL.
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.lamports',
                operator: 'lte',
                value: '1000000000' // 1 SOL
            },
            {
                // This additional condition restricts Transfer recipients to a list of allowed addresses.
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.to',
                operator: 'in',
                value: ['4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA', '4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA']
            }
        ],
        action: 'ALLOW'
    }]
}
```

### Allow a Solana Transaction that has a Create and Transfer instruction, while limiting Transfers to 1 SOL

```ts
{
    version: '1.0',
    name: 'SOL transfer maximums'
    chain_type: 'solana',
    rules: [
        {
            // This rule restricts the value of all SOL transfer instructions to <= 1 SOL.
            name: 'Restrict SOL transfers to a maximum value',
            method: 'signAndSendTransaction',
            conditions: [{
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.lamports',
                operator: 'lte',
                value: '1000000000' // 1 SOL
            }],
            action: 'ALLOW'
        },
        {
            // This rule allows the Create instruction to be present in the transaction.
            name: 'Allow the Create instruction',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    // This field_source is used for all System Program instructions.
                    field_source: 'solana_system_program_instruction',
                    field: 'instructionName',
                    operator: 'eq',
                    value: 'Create'
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```

## Allow a TransferChecked instruction with a max value of a USDC token

```ts
{
    version: '1.0',
    name: 'Restrict USDC transfers to a maximum value',
    chain_type: 'solana',
    rules: [{
        name: 'Restrict transfers to be less than or equal to 5 USDC',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used for all Token Program instructions.
                field_source: 'solana_token_program_instruction',
                field: 'TransferChecked.mint',
                operator: 'eq',
                // This is the USDC mint address on the Solana mainnet.
                value: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
            },
            {
                // This field_source is used for all Token Program instructions.
                field_source: 'solana_token_program_instruction',
                field: 'TransferChecked.amount',
                operator: 'lte',
                value: '5000000' // 5 USDC assuming 6 decimals
            },
        ],
        action: 'ALLOW'
    }]
}
```

## Denylist recipients of a transaction

```ts
{
    version: '1.0',
    name: 'Denylist recipients of SOL transfer',
    chain_type: 'solana',
    rules: [{
        name: 'Deny SOL transfers to a list of addresses',
        method: 'signAndSendTransaction',
        conditions: [
            {
                // This field_source is used for all System Program instructions.
                field_source: 'solana_system_program_instruction',
                field: 'Transfer.to',
                operator: 'in',
                value: ['4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA', '4tFqt2qzaNsnZqcpjPiyqYw9LdRzxaZdX2ewPncYEWLA']
            },
        ],
        action: 'DENY'
    }]
}
```

## Allowlist some System Program instructions and some Token Program instructions

```ts
{
    version: '1.0',
    name: 'Allowlist all System Program instructions and some Token Program instructions',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allowlist System Program instructions',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    // This field_source is used for all System Program instructions.
                    field_source: 'solana_system_program_instruction',
                    field: 'instructionName',
                    operator: 'in',
                    value: ['Create', 'Transfer']
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Allowlist Token Program instructions',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    // This field_source is used for all Token Program instructions.
                    field_source: 'solana_token_program_instruction',
                    field: 'instructionName',
                    operator: 'in',
                    value: ['TransferChecked', 'CloseAccount']
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```

## Allowlist some Solana Programs and restrict SOL transfers

```ts
{
    version: '1.0',
    name: 'Allowlist some Solana Programs and restrict SOL transfers',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allowlist Programs',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    field_source: 'solana_program_instruction',
                    field: 'programId',
                    operator: 'in',
                    value: [
                        'ComputeBudget111111111111111111111111111111', // Compute Budget Program
                        'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4' // Jupiter v6 Swap Program
                    ]
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Restrict SOL transfers',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    field_source: 'solana_system_program_instruction',
                    field: 'Transfer.lamports',
                    operator: 'lte',
                    value: '1000000000' // 1 SOL
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```

## Prevent private key exports while allowing other actions

```ts
{
    version: '1.0',
    name: 'Prevent private key exports',
    chain_type: 'solana',
    rules: [
        {
            name: 'Block private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'DENY'
        },
        {
            name: 'Allow all other actions',
            method: '*',
            conditions: [],
            action: 'ALLOW'
        }
    ]
}
```

## Only permit private key exports

```ts
{
    version: '1.0',
    name: 'Only allow private key exports',
    chain_type: 'solana',
    rules: [
        {
            name: 'Allow private key exports',
            method: 'exportPrivateKey',
            conditions: [],
            action: 'ALLOW'
        },
        {
            name: 'Block all other actions',
            method: '*',
            conditions: [],
            action: 'DENY'
        }
    ]
}
```

## Anti patterns

### Avoid adding rules that may override other rules

```ts
{
    version: '1.0',
    name: 'Allowlist the System Program Transfer instruction and restrict SOL transfers',
    chain_type: 'solana',
    rules: [
        {
            // This rule restricts the value of all SOL transfers.
            name: 'Restrict SOL transfers',
            method: 'signAndSendTransaction',
            conditions: [
                {
                    field_source: 'solana_system_program_instruction',
                    field: 'Transfer.lamports',
                    operator: 'lte',
                    value: '1000000000' // 1 SOL
                }
            ],
            action: 'ALLOW'
        },
        {
            name: 'Allowlist System Program Transfer instruction',
            method: 'signAndSendTransaction',
            conditions: [
                // This rule will override the previous rule by allowing all Transfer instructions via the System Program.
                {
                    field_source: 'solana_system_program_instruction',
                    field: 'instructionName',
                    operator: 'eq',
                    value: 'Transfer'
                }
            ],
            action: 'ALLOW'
        }
    ]
}
```


# null
Source: https://docs.privy.io/controls/policies/get-a-policy



<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`getPolicy`** method to get a policy by its ID.

    ```tsx
    const policy = await privy.getPolicy({
      id: 'fmfdj6yqly31huorjqzq38zc'
    });
    ```
  </Tab>

  <Tab title="REST API">
    To get a policy by its ID, make a `GET` request to:

    ```bash
    https://api.privy.io/v1/policies/<policy_id>
    ```

    Replacing `<policy_id>` with the ID of your desired policy.

    ## Example

    A sample request to fetch a policy with ID `fmfdj6yqly31huorjqzq38zc` looks like:

    ```bash
    curl --request GET https://api.privy.io/v1/policies/fmfdj6yqly31huorjqzq38zc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ## Response

    A successful response will look like the following:

    ```json
    {
      "id": "fmfdj6yqly31huorjqzq38zc",
      "name": "Allow list certain smart contracts",
      "version": "1.0",
      "chain_type": "ethereum",
      "rules": [
        {
          "name": "Allow list USDC",
          "method": "eth_sendTransaction",
          "conditions": [
            {
              "field_source": "ethereum_transaction",
              "field": "to",
              "operator": "eq",
              "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
            }
          ],
          "action": "ALLOW"
        }
      ],
      "owner_id": "fmfdj6yqly31huorjqzq38zc"
    }
    ```

    <Expandable title="child attributes">
      <ResponseField path="id" type="string">
        Unique ID for the policy.
      </ResponseField>

      {' '}

      <ResponseField path="version" type="'1.0'">
        Version of the policy. Currently, 1.0 is the only version.
      </ResponseField>

      {' '}

      <ResponseField path="name" type="string">
        Name of the policy.
      </ResponseField>

      {' '}

      <ResponseField path="chain_type" type="'ethereum'">
        Chain type for wallets that the policy is applied to.
      </ResponseField>

      <ResponseField path="rules" type="Rule">
        List of `Rule` objects describing what rules are applied to each RPC method (e.g.
        `'eth_sendTransaction'`) that the wallet can take. [Learn more about
        `MethodRule`s](/controls/policies/overview#rules).
      </ResponseField>
    </Expandable>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/controls/policies/overview



Privy's **policy engine** allows your application to restrict the actions that can be taken with server wallets.

Policies enable you to configure:

* Transfer limits
* Allow lists and deny lists of transfer recipients
* Allow lists and deny lists of smart contracts and programs
* Constraints around calldata that can be passed to smart contracts

This ensures that server wallets can only ever be used to take actions your application intends to take.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/policy-splash.png" alt="Managing policies in the Privy Dashboard" />

# Concepts

Policies are defined by three core primitives: **policies**, **rules**, and **conditions**. At a high-level:

* **Policies** are a list of rules that define the total set of actions that are allowed or denied for a server wallet.
* **Rules** are a set of conditions, such that if a request satisfies all of the conditions in a rule, the policy engine executes the action (`ALLOW` or `DENY`) prescribed by the rule.
* **Conditions** are boolean statements that the policy engine can evaluate RPC requests against.

You can create and manage policies through the [Privy Dashboard](https://dashboard.privy.io), `nodeJS` [SDK](./create-a-policy), or via the [REST API](./create-a-policy).

## Policies

A **policy** is composed from a **list of rules for each RPC method that a wallet can execute** that define what actions are allowed or denied for the wallet. `DENY` actions take precedence over `ALLOW` actions. If no rules resolve, the policy will default to `DENY`.

Policy objects have the following properties:

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="version" type="'1.0'">
    Version of the policy. Currently, 1.0 is the only version.
  </ResponseField>

  <ResponseField name="name" type="string">
    Name to assign to policy.
  </ResponseField>

  <ResponseField name="chain_type" type="'ethereum' | 'solana'">
    Chain type for wallets that the policy will be applied to.
  </ResponseField>

  <ResponseField name="rules" type="Rule[]">
    A list of `Rule` objects describing what rules to apply to each RPC method (e.g.
    `'eth_sendTransaction'`) that the wallet can take.
  </ResponseField>
</Expandable>

### Policy evaluation

When your application makes an RPC request on a wallet that has a policy, the policy engine evaluates the `rules` that are associated with the requested RPC method.

For instance, if your application makes an `'eth_signTransaction'` request, the policy engine will only evalaute rules associated with the `'eth_signTransaction'` method in the policy.

The rules are evaluated as follows:

1. If **any** rule evaluates to a `DENY` action, the policy engine will `DENY` the request.
2. If **any** rule evaluates to an `ALLOW` action, and **no** rules evaluate to `DENY`, then the policy engine will `ALLOW` the request.

If the request does not satisfy *any* of the rules for the policy, the policy engine defaults to `DENY` the request.

This also applies to Solana transactions such that every Instruction in a Solana transaction is evaluated against the rules of the policy. Every instruction must evaluate to an `ALLOW` action for the transaction to be allowed.

<Info>
  If your application makes a request to a server wallet with RPC method `X`, and the policy's
  `rules` contains no entry with a `method` corresponding to `X`, the engine will deny the request
  by default. If you'd like the policy engine to instead allow requests for RPC method `X` by
  default, we recommend setting up an "Allow all" `Rule` for that RPC method [like
  so](/controls/policies/example-policies/ethereum#allow-all-requests-for-a-given-rpc-method).
</Info>

## Rules

The nested `Rule` object within the policy's `rules` array. A **rule** is composed of an set of boolean **conditions** and an **action** (`ALLOW` or `DENY`) that is taken if an RPC request satisfies all of the conditions in the rule.
Rule objects have the following fields:

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="name" type="string">
    Name to assign to the rule.
  </ResponseField>

  <ResponseField name="method" type="'personal_sign' | 'eth_signTypedData_v4' | 'eth_signTransaction' | 'eth_sendTransaction' | 'signTransaction' | 'signAndSendTransaction' | '*'">
    RPC method to apply the `conditions` to. Must correspond to the `chain_type` of the parent policy.
  </ResponseField>

  <ResponseField name="conditions" type="Condition[]">
    A set of boolean conditions that define the action the rule allows or denies.
  </ResponseField>

  <ResponseField name="action" type="'ALLOW' | 'DENY'">
    Whether the rule should allow or deny a wallet request if it satisfies all of the rule's
    `conditions`.
  </ResponseField>
</Expandable>

Each rule corresponds to an individual action that should be allowed or denied by a server wallet. For example, you might configure rules for a policy to:

* `ALLOW` transfers of the native token to a set of allowlisted recipient addresses
* `DENY` interactions with specific Ethereum smart contracts or Solana programs

## Conditions

A **condition** is a boolean statement about a wallet request. When evaluating a wallet request against a rule, the policy engine checks whether the wallet request satisfies each of the boolean conditions in the rule. If all of the conditions are satisfied, the engine executes the action associated with the rule.

Conditions allow you to define specific action types that should be allowed or denied for a server wallet.

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="field_source" type="'ethereum_transaction' | 'ethereum_calldata' | 'ethereum_typed_data_domain' | 'ethereum_typed_data_message' | 'solana_program_instruction' | 'solana_system_program_instruction' | 'solana_token_program_instruction'">
    Data source from which to derive the `field` for the condition.
  </ResponseField>

  <ResponseField name="field" type="string">
    The attribute to evaluate for a wallet request. As an example, the field for the recipient of an
    EVM transaction is `'to'`.
  </ResponseField>

  <ResponseField name="abi" type="JSON">
    Contract ABI to decode Ethereum calldata against. Should only be set for `'ethereum_calldata'`
    policies. Must strictly be formatted as JSON.
  </ResponseField>

  <ResponseField name="operator" type="'eq' | 'neq' | 'lt' | 'lte' | 'gt' | 'gte' | 'in'">
    Boolean operator used to compare a `field` with a `value`
  </ResponseField>

  <ResponseField name="value" type="string | number | string[]">
    Static value to compare a `field` to.
  </ResponseField>
</Expandable>

Conditions for certain sources may have additional parameters. For instance, `ethereum_calldata` conditions also require an `abi` parameter used to decode the calldata, and `ethereum_typed_data_message` conditions require a `typed_data` parameter to define the schema for the typed data message.

### Field

**Fields** are attributes of a wallet request that can be parsed or interpreted from the wallet request. Examples of fields include the `to` parameter of an EVM transaction, the `fee_payer` parameter of a Solana transaction, or an `spl_transfer_recipient` field that is populated when the policy engine interprets a transaction.

Fields are derived from **field sources**, which surface data from the wallet request. Possible field sources are listed below.

| Field source                          | Description                                                                                                                                                                                                             | Example fields                                                                                        |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `'ethereum_transaction'`              | The verbatim Ethereum transaction object in an `eth_signTransaction` or `eth_sendTransaction` request.                                                                                                                  | `to`, `chain_id`, `value`.                                                                            |
| `'ethereum_calldata'`                 | The decoded calldata in a smart contract interaction as the smart contract method's parameters. Note that that `'ethereum_calldata'` conditions must contain an `abi` parameter with the JSON ABI of the smart contract | `function_name`, `_to`, `_value` (for a ERC20 interaction)                                            |
| `'ethereum_typed_data_domain'`        | Attributes from the signing domain that will verify the signature.                                                                                                                                                      | `chainId`, `verifyingContract`                                                                        |
| `'ethereum_typed_data_message'`       | `types` and `primary_type` attributes of the TypedData JSON object defined in [EIP-712](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc).                                        | dot-separated path to value in `message` object, i.e. `to.wallet`                                     |
| `'solana_program_instruction'`        | Solana program instruction from a `signTransaction` or `signAndSendTransaction` request.                                                                                                                                | `programId`                                                                                           |
| `'solana_system_program_instruction'` | Fields relevant to the Solana System Program and its Transfer instruction.                                                                                                                                              | `instructionName`, `Transfer.to`, `Transfer.from`, `Transfer.lamports`                                |
| `'solana_token_program_instruction'`  | Fields relevant to the SPL Token Program and its Transfer instruction.                                                                                                                                                  | `instructionName`, `Transfer.source`, `Transfer.destination`, `Transfer.authority`, `Transfer.amount` |

### Operator

**Operators** are boolean operators used to compare fields and values. Operators include `eq`, `neq`, `lt`, `lte`, `gt`, `gte`, `in`.

### Values

A condition compares a field using its boolean operator to a static **value**. As an example, if a condition determines whether an Ethereum transaction has specific recipient address `X`, the value for the condition is `X`.


# null
Source: https://docs.privy.io/controls/policies/update-a-policy



You can update a policy using the Privy Dashboard, the NodeJS SDK, or the REST API.

If a policy has an owner, the owner's signature is required to modify the policy, see [setting authorization signatures](/api-reference/authorization-signatures).

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`updatePolicy`** method to update an existing policy.

    ```tsx
    const policy = await privy.updatePolicy({
      id: 'fmfdj6yqly31huorjqzq38zc',
      name: 'Transactions must be <= 5ETH',
      rules: [
        {
          name: 'Transactions must be <= 5ETH',
          method: 'eth_sendTransaction',
          action: 'ALLOW',
          conditions: [
            {
              fieldSource: 'ethereum_transaction',
              field: 'value',
              operator: 'lte',
              value: '0x2386F26FC10000'
            }
          ]
        }
      ]
    });
    ```
  </Tab>

  <Tab title="REST API">
    To update an existing policy, make a `PATCH` request to:

    ```sh
    https://api.privy.io/v1/policies/<policy_id>
    ```

    Replacing `<policy_id>` with the ID of your desired policy.

    <Tip>
      In the request headers, make sure to include Privy's [required authentication
      headers](/basics/rest-api/setup#authentication) and [headers that may be required for your app's
      wallet API setup](/basics/rest-api/quickstart#2-sign-a-message).
    </Tip>

    ## **Body**

    In the request body, include the following fields:

    <ParamField path="name" type="string">
      (Optional) New name to assign to policy.
    </ParamField>

    <ParamField path="rules" type="Rule">
      (Optional) New list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `Rule`s](./overview.mdx#policies).
    </ParamField>

    Any fields not included in the `PATCH` request body will remain unchanged from the original policy.

    ## **Response**

    If the policy is updated successfully, the response will include the full updated policy object.

    <ResponseField name="id" type="string">
      Unique ID for the policy.
    </ResponseField>

    <ResponseField name="version" type="'1.0'">
      Version of the policy. Currently, 1.0 is the only version.
    </ResponseField>

    <ResponseField name="name" type="string">
      Updated name of the policy.
    </ResponseField>

    <ResponseField name="chain_type" type="'ethereum'">
      Chain type for wallets that the policy will be applied to.
    </ResponseField>

    <ResponseField name="rules" type="Rule">
      Updated list of `Rule` objects describing what rules to apply to each RPC method (e.g.
      `'eth_sendTransaction'`) that the wallet can take. [Learn more about
      `MethodRule`s](/controls/policies/overview#rules).
    </ResponseField>

    ## Example

    As an example, a sample request to update the `rules` of a policy with ID `fmfdj6yqly31huorjqzq38zc` might look like the following:

    ```bash
    $ curl --request PATCH https://api.privy.io/v1/policies/fmfdj6yqly31huorjqzq38zc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "rules": [{
          "name": "Allow list USDT",
          "method": "eth_sendTransaction",
          "conditions": [
              {
                  "field_source": "ethereum_transaction",
                  "field": "to",
                  "operator": "eq",
                  "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
              }
          ],
          "action": "ALLOW"
        }]
    }'
    ```

    A successful response will look like the following:

    ```json
    {
      "id": "fmfdj6yqly31huorjqzq38zc",
      "name": "Allow list certain smart contracts",
      "version": "1.0",
      "chain_type": "ethereum",
      "rules": [
        {
          "name": "Allow list USDT",
          "method": "eth_sendTransaction",
          "conditions": [
            {
              "field_source": "ethereum_transaction",
              "field": "to",
              "operator": "eq",
              "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7"
            }
          ],
          "action": "ALLOW"
        }
      ],
      "owner_id": "fmfdj6yqly31huorjqzq38zc"
    }
    ```
  </Tab>
</Tabs>


# Creating key quorums
Source: https://docs.privy.io/controls/quorum-approvals/creating-key-quorums



## Generate a keypair

To use quorum approvals, you must first generate a P-256 keypair, then register them with Privy alongside an authorization threshold. You can create a keypair with the following command:

```sh
openssl ecparam -name prime256v1 -genkey -noout -out private.pem && \
openssl ec -in private.pem -pubout -out public.pem
```

## Register the public key

After you have generated your keypairs, register them with Privy via the Dashboard or REST API, and make sure to save the `id` for future use.

<Tabs>
  <Tab title="REST API">
    Register the public key of the keypair with Privy by making a `POST` request to:

    ```sh
    https://api.privy.io/v1/key_quorums
    ```

    ### **Body**

    In the request body, include the following:

    <ParamField path="public_keys" type="string[]" required>
      A list of PEM or DER formatted P-256 public keys to register. Make sure to include the PEM header and footer and to
      properly escape any newlines.
    </ParamField>

    <ParamField path="authorization_threshold" type="number">
      The minimum number of signatures required to authorize an action. If left unset, the default is all keys.
    </ParamField>

    <ParamField path="display_name" type="string">
      Human readable display name to attach to the key.
    </ParamField>

    ### **Response**

    If the request is successful, Privy will return the following in the response:

    <ResponseField name="id" type="string">
      Unique ID for the key quorum, used to assign the `owner_id` to a resource.
    </ResponseField>

    <ResponseField name="authorization_keys" type="{public_key: string, display_name: string | null}[]">
      The list of public keys and their display names.
    </ResponseField>

    <ParamField path="authorization_threshold" type="number | null">
      The minimum number of signatures required to authorize an action. If left unset, the default is all keys.
    </ParamField>

    <ResponseField name="display_name" type="string">
      Human readable display name to attach to the key.
    </ResponseField>

    ### **Example**

    As an example, a request to register a 2 of 2 key quorum might look like the following:

    ```bash
    $ curl --request POST https://api.privy.io/v1/key_quorums \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    -d '{
        "display_name": "Sample key",
        "public_keys": [
            "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/ckqE2CItVIG\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/C9yjhboIuoPD3g==\n-----END PUBLIC KEY-----",
            "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErzZtQr/bMIh3Y8f9ZqseB9i/AfjQ\nhu+agbNqXcJy/TfoNqvc/Y3Mh7gIZ8ZLXQEykycx4mYSpqrxp1lBKqsZDQ==\n-----END PUBLIC KEY-----"
        ],
        "authorization_threshold": 2
    }'
    ```
  </Tab>

  <Tab title="Dashboard">
    Visit the [**Authorization keys**](https://dashboard.privy.io/apps?page=authorization-keys) page of your dashboard, click **New key**, and select **Register key quorum instead**.

    Specify the public keys and an authorization threshold.
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/controls/quorum-approvals/overview

Securing wallet actions with multi-signature quorum approvals

**Privy enables your app to require quorum approvals on wallet actions**, so that signatures from `m-of-n` approver keys are required in order to update a resource or use a wallet.

At a high-level, using quorum approvals involves three steps:

1. Generate your P-256 keypairs.

2. Register your keypairs with Privy, specifying an authorization threshold.

3. When making a request to update a resource or take actions with a wallet, sign the request with the required number of authorization keys based on the wallet's quorum approval configuration.

4. Send the request to Privy's API, including the necessary [authorization signatures](/api-reference/authorization-signatures) via the `'privy-authorization-signature'` header.

<Info>
  Quorum approvals provide enterprise-grade security for high-value wallets and critical operations.
</Info>


# Using key quorums
Source: https://docs.privy.io/controls/quorum-approvals/using-key-quorums



You can specify the key quorum ID as the [`owner_id`](/api-reference/wallets/create#body-owner-id) when creating a wallet or policy, which **will require the quorum to sign for updates to the resource or actions taken with the resource**.

## Taking actions with wallets

Signatures from the wallet's owner are also required to take actions on a wallet. You can grant permissions to additional keys or quorums by specifying them as [`additional_signers`](/api-reference/wallets/create#body-additional-signers) on the wallet.

## Collecting required signatures

To make requests with a wallet with quorum approvals, you'll need to:

1. Prepare the request payload that you want to make.
2. Generate authorization signatures with the required number of authorization keys to satisfy the authorization threshold.
3. Send the signatures along with the request payload to the Privy API via the `privy-authorization-signature` header, with the signatures separated by commas.

See [Generating signatures](/api-reference/authorization-signatures#generating-signatures) for examples.

<Warning>
  Each authorization signature must be created with the exact same request payload to be valid.
</Warning>

<Tip>
  For distributed approvals, consider implementing a central coordinator service that collects
  signatures from each authorizer before submitting the request to Privy.
</Tip>

## Submitting multi-signature requests

Once you've collected the required signatures, combine them in a comma-separated list and include them in the `privy-authorization-signature` header:

<CodeGroup>
  ```bash REST API
  curl --request POST https://api.privy.io/v1/wallets/y5ofctvacjiv53u4hmnqi0e5/rpc \
  -u "<your-privy-app-id>:<your-privy-app-secret>" \
  -H "privy-app-id: <your-privy-app-id>" \
  -H "privy-authorization-signature: <sig1>,<sig2>" \
  -H 'Content-Type: application/json' \
  -d '{
    "caip2": "eip155:1",
    "method": "eth_sendTransaction",
    "params": {
      "transaction": {
        "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        "value": "0x2386f26fc10000",
        "data": "0x"
      }
    }
  }'
  ```
</CodeGroup>

Privy validates that:

1. The required number of signatures are provided.
2. All signatures are valid for the request payload.
3. All signatures come from authorization keys for the wallet.

If any validation fails, the request is rejected.

## Securing your authorization flow

For production systems using quorum approvals, consider these best practices:

1. Store authorization keys in secure environments.
2. Maintain comprehensive logs of authorization requests and signatures.
3. For wallets with quorum approvals, always make sure authorization keys are managed by different entities.

<Note>
  Combine key quorums with [policies](/controls/policies/overview) for even stronger security
  guarantees.
</Note>


# Custom account abstraction implementation
Source: https://docs.privy.io/recipes/account-abstraction/custom-implementation



<Tip>
  Privy now allows you to natively use smart wallet for a better developer experience. Check out the
  docs [here](/wallets/using-wallets/evm-smart-wallets/overview).
</Tip>

<Tabs>
  <Tab title="ZeroDev">
    ## Account abstraction with ZeroDev

    [ZeroDev](https://zerodev.app/) is a toolkit for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart wallets for your users, using the user's EOA as the smart wallet's signer. This allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) features into your app.

    **You can easily integrate ZeroDev alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with gas sponsorship, batched transactions, and more!**

    Read below to learn how to configure your app to create smart wallets for *all* your users!

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. ZeroDev's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from ZeroDev). The smart wallet (ZeroDev) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    <details>
      <summary><b>How much does deploying a smart wallet for a user cost?</b></summary>

      The transaction to deploy a ZeroDev smart wallet requires approximately 258522 in gas. At time of writing, this corresponds to:

      * 0.0168 ETH (28 USD) on **Ethereum Mainnet**
      * 0.04 POL (0.024 USD) on **Polygon**
      * 0.00005 ETH (0.08 USD) on **Arbitrum**

      The exact deployment cost you see will vary depending on the current gas price.

      **Importantly, ZeroDev deploys smart wallets lazily, ensuring that you do not pay deployment costs for functionally unused wallets.**

      When you first initialize a ZeroDev smart wallet for a user, ZeroDev does not yet deploy the wallet, but instead *predicts* the smart wallet's address (via the [`CREATE2`](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2) opcode). This allows you to associate a smart wallet with your user, without any upfront deployment costs.

      ZeroDev only *deploys* the smart wallet to the predicted address when the user sends their first transaction with the smart wallet. This ensures that you only ever pay deployment costs for wallets that are actually used to transact on-chain.
    </details>

    ### 1. Install the required dependencies from Privy and ZeroDev

    In your app's repository, install the required dependencies from Privy and ZeroDev, as well as the [`permissionless`](https://www.npmjs.com/package/permissionless), and [`viem`](https://www.npmjs.com/package/viem) libraries:

    ```sh
    npm i @privy-io/react-auth @zerodev/sdk @zerodev/ecdsa-validator permissionless viem
    ```

    ### 2. Sign up for a ZeroDev account and get your project ID

    Visit the [**ZeroDev dashboard**](https://dashboard.zerodev.app/) and sign up for a new account if you do not have one already. Set up a new project for your required chain(s) and retrieve your ZeroDev **project ID**, as well as your **paymaster and bundler URLs** for the project.

    Within this Dashboard, you can also configure [settings for gas sponsorship and other ZeroDev features](https://docs.zerodev.app/sdk/getting-started/tutorial)!

    ### 2. Configure your app's Privy settings

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with a basic Privy integration.

    Next, set **Add confirmation modals** to "off" in your app's \[**Embedded wallets**] {/* TODO: add link */} page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [user operations](https://www.alchemy.com/overviews/user-operations)s they sign.

    Lastly, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
            }
            ...insertTheRestOfYourPrivyProviderConfig
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 3. Create a smart account for your user

    You'll now create a smart account for your user, using the Privy embedded wallet (an EOA) as the signer.

    To do so, when the user logs in, first find the user's embedded wallet from Privy's **`useWallets`** hook, and get its [EIP1193 provider](/wallets/using-wallets/ethereum/web3-integrations). You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx
    import {useWallets} from '@privy-io/react-auth';
    import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
    import {createWalletClient, custom} from 'viem';
    ...
    // Find the embedded wallet and get its EIP1193 provider
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    const provider = await embeddedWallet.getEthereumProvider();
    ```

    Next, pass the returned EIP1193 `provider` to the [`providerToSmartAccountSigner`](https://docs.pimlico.io/permissionless/reference/utils/providerToSmartAccountSigner) method from `permissionless` to create a [`SmartAccountSigner`](https://docs.pimlico.io/permissionless/how-to/signers#signers-for-permissionlessjs). This signer corresponds to the user's embedded wallet and authorizes actions for the user's smart account.

    ```tsx
    import { providerToSmartAccountSigner } from 'permissionless';
    ...
    // Use the EIP1193 `provider` from Privy to create a `SmartAccountSigner`
    const smartAccountSigner = await providerToSmartAccountSigner(provider);
    ```

    Finally, using the `smartAccountSigner` from above, initialize a Kernel (ZeroDev) smart account for the user like so:

    ```tsx
    import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
    import {createPublicClient, http} from 'viem';
    import {ENTRYPOINT_ADDRESS_V07} from 'permissionless';
    import {createZeroDevPaymasterClient, createKernelAccount, createKernelAccountClient} from "@zerodev/sdk";
    import {signerToEcdsaValidator} from "@zerodev/ecdsa-validator";

    ...

    // Initialize a viem public client on your app's desired network
    const publicClient = createPublicClient({
      transport: http(sepolia.rpcUrls.default.http[0]),
    })

    // Create a ZeroDev ECDSA validator from the `smartAccountSigner` from above and your `publicClient`
    const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
      signer: smartAccountSigner,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
    })

    // Create a Kernel account from the ECDSA validator
    const account = await createKernelAccount(publicClient, {
      plugins: {
        sudo: ecdsaValidator,
      },
       entryPoint: ENTRYPOINT_ADDRESS_V07,
    });

    // Create a Kernel account client to send user operations from the smart account
    const kernelClient = createKernelAccountClient({
        account,
        chain: sepolia,
        entryPoint: ENTRYPOINT_ADDRESS_V07,
        bundlerTransport: http('insert-your-bundler-RPC-from-the-dashboard'),
        middleware: {
          sponsorUserOperation: async ({ userOperation }) => {
            const zerodevPaymaster = createZeroDevPaymasterClient({
              chain: sepolia,
              entryPoint: ENTRYPOINT_ADDRESS_V07,
              transport: http('insert-your-paymaster-RPC-to-the-dashboard'),
            })
            return zerodevPaymaster.sponsorUserOperation({
              userOperation,
              entryPoint: ENTRYPOINT_ADDRESS_V07,
            })
          }
        }
      })
    ```

    The `kernelClient` is a drop-in replacement for a `viem` [Wallet Client](https://viem.sh/docs/clients/wallet.html), and requests to the smart account can be made using [`viem`'s API](https://docs.zerodev.app/sdk/core-api/send-transactions).

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx
      /**
       * This example assumes your app is wrapped with the `PrivyProvider` and
       * is configured to create embedded wallets for users upon login. Aside from
       * the imports, all of the code in this snippet must be used within a React component
       * or context.
       */
      import {useWallets} from '@privy-io/react-auth';
      import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
      import {createPublicClient, http} from 'viem';
      import {providerToSmartAccountSigner, ENTRYPOINT_ADDRESS_V07} from "permissionless";
      import {createZeroDevPaymasterClient, createKernelAccountClient} from "@zerodev/sdk";
      import {signerToEcdsaValidator} from "@zerodev/ecdsa-validator";

      ...

      // Find the embedded wallet and get its EIP1193 provider
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
      const provider = await embeddedWallet.getEthereumProvider();

      // Use the EIP1193 `provider` from Privy to create a `SmartAccountSigner`
      const smartAccountSigner = await providerToSmartAccountSigner(provider);

      // Initialize a viem public client on your app's desired network
      const publicClient = createPublicClient({
        transport: http(sepolia.rpcUrls.default.http[0]),
      })

      // Create a ZeroDev ECDSA validator from the `smartAccountSigner` from above and your `publicClient`
      const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
        signer: smartAccountSigner,
        entryPoint: ENTRYPOINT_ADDRESS_V07,
      })

      // Create a Kernel account from the ECDSA validator
      const account = await createKernelAccount(publicClient, {
        plugins: {
          sudo: ecdsaValidator,
        },
         entryPoint: ENTRYPOINT_ADDRESS_V07,
      });

      // Create a Kernel client to send user operations from the smart account
      const kernelClient = createKernelAccountClient({
          account,
          chain: sepolia,
          entryPoint: ENTRYPOINT_ADDRESS_V07,
          bundlerTransport: http('insert-your-bundler-RPC-from-the-dashboard'),
          middleware: {
            // See https://docs.zerodev.app/sdk/core-api/sponsor-gas
            sponsorUserOperation: async ({ userOperation }) => {
              const zerodevPaymaster = createZeroDevPaymasterClient({
                chain: sepolia,
                entryPoint: ENTRYPOINT_ADDRESS_V07,
                transport: http('insert-your-paymaster-RPC-from-the-dashboard'),
              })
              return zerodevPaymaster.sponsorUserOperation({
                userOperation,
                entryPoint: ENTRYPOINT_ADDRESS_V07,
              })
            }
          }
        })
      ```

      Note: if your app uses React, we suggest that you store the user's `kernelClient` in a [React context](https://react.dev/learn/passing-data-deeply-with-context) that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ### 4. Send user operations (transactions) from the smart account

    Now that your users have Kernel (ZeroDev) smart accounts, they can now send [**UserOperations**](https://eips.ethereum.org/EIPS/eip-4337) from their smart account. This is the AA analog to sending a transaction.

    **To send a user operation from a user's smart account, use the Kernel client's [`sendTransaction`](https://docs.zerodev.app/sdk/core-api/send-transactions#sending-transactions-1) method.**

    ```tsx
    const txHash = await kernelClient.sendTransaction({
      to: 'TO_ADDRESS',
      value: VALUE, // default to 0
      data: '0xDATA' // default to 0x
    });
    ```

    This is a drop-in replacement for viem's [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html) method, and will automatically apply any smart account configurations (e.g. gas sponsorship) you configure in the `middleware` before sending the transaction.

    **That's it! You've configured your app to create smart wallets for all of your users, and can seamlessly add in AA features like gas sponsorship, batched transactions, and more.** 🎉
  </Tab>

  <Tab title="Safe">
    ## Account Abstraction with Safe

    [Safe Smart Accounts](https://safe.global/) is a product by [Safe](https://safe.global/wallet) for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart accounts for your users, using the user's EOA as the smart account's signer. The product builds off of the smart contract infrastructure powering the widely-used [Safe wallet](https://safe.global/wallet) and allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) and other Safe features into your app.

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. Safe's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from Safe). The smart wallet (Safe) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    **To create Safe smart accounts for your users, simply follow our Pimlico integration guide.** Safe does not operate its own paymaster and bundler infrastructure, and developers generally compose the Safe smart account with paymasters or bundlers from Pimlico.

    **When integrating Safe alongside Pimlico, the only change from the default Pimlico setup is to replace the [`signerToSimpleSmartAccount`](https://docs.pimlico.io/permissionless/reference/accounts/signerToSimpleSmartAccount) method with [`signerToSafeSmartAccount`](https://docs.pimlico.io/permissionless/reference/accounts/signerToSafeSmartAccount).** This modifies the setup to deploy a Safe smart account for the user instead of a simple smart account.

    For example, when initializing the smart account from a `viem` wallet client for the user's Privy embedded wallet, you should update your code as follows:

    ```tsx
    import {
      createSmartAccountClient,
      walletClientToCustomSigner,
      ENTRYPOINT_ADDRESS_V07
    } from 'permissionless';
    import {signerToSimpleSmartAccount} from 'permissionless/accounts'; // Remove
    import {signerToSafeSmartAccount} from 'permissionless/accounts'; // Add

    import {createPimlicoPaymasterClient} from 'permissionless/clients/pimlico';
    import {createPublicClient, http} from 'viem';

    // The `privyClient` is simply a viem Wallet Client for the user's embedded wallet
    const customSigner = walletClientToCustomSigner(privyClient);

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your app
      transport: http()
    });

    // Initialize the smart account for the user
    // Remove
    const simpleSmartAccount = await signerToSimpleSmartAccount(publicClient, {
      entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
      signer: customSigner,
      factoryAddress: '0x9406Cc6185a346906296840746125a0E44976454'
    });

    // Add
    const safeSmartAccount = await signerToSafeSmartAccount(publicClient, {
      signer: customSigner,
      safeVersion: '1.4.1',
      entryPoint: ENTRYPOINT_ADDRESS_V07
    });

    // Create the Paymaster for gas sponsorship using the API key from your Pimlico dashboard
    const pimlicoPaymaster = createPimlicoPaymasterClient({
      transport: http('https://api.pimlico.io/v2/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY')
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: simpleSmartAccount, // Remove
      account: safeSmartAccount, // Add
      chain: sepolia, // Replace this with the chain for your app
      transport: http('https://api.pimlico.io/v1/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY'),
      sponsorUserOperation: pimlicoPaymaster.sponsorUserOperation // If your app uses a paymaster for gas sponsorship
    });
    ```

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this guide](./address.md) for more.
    </Tip>
  </Tab>

  <Tab title="Pimlico">
    ## Account Abstraction with permissionless.js and Pimlico

    [**`permissionless.js`**](https://www.npmjs.com/package/permissionless) is a modular and extensible TypeScript library originally created by [**Pimlico**](https://pimlico.io) for deploying and managing ERC-4337 smart accounts. You can use this library for all major smart account implementations, including [Safe](https://docs.pimlico.io/permissionless/how-to/accounts/use-safe-account), [Kernel](https://docs.pimlico.io/permissionless/how-to/accounts/use-kernel-account), [Biconomy](https://www.biconomy.io/), [SimpleAccount](https://docs.pimlico.io/permissionless/how-to/accounts/use-simple-account), and more.

    **You can easily integrate [`permissionless.js`](https://www.npmjs.com/package/permissionless) alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with gas sponsorship, batched transactions, and more.**

    Just follow the steps below!

    <Tip>
      Want to see an end-to-end integration of Privy with `permissionless.js`? Check out [**our example
      app**](https://github.com/privy-io/permissionless-example)!
    </Tip>

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. Smart wallets are contract accounts. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from permissionless). The smart wallet holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    ### 1. Install Privy and `permissionless.js`

    In your project, install the necessary dependencies from Privy, Pimlico, and [`viem`](https://viem.sh/):

    ```bash
    npm i @privy-io/react-auth permissionless viem
    ```

    ### 2. Sign up for a Pimlico account and create an API key.

    To send transactions from smart accounts, you will need access to a [**bundler**](https://www.alchemy.com/overviews/what-is-a-bundler). We also recommend using [**paymaster**](https://www.alchemy.com/overviews/what-is-a-paymaster) to sponsor your user's transactions.

    To get a **bundler** and **paymaster** for your application, [**sign up for a Pimlico account**](https://dashboard.pimlico.io/) and copy down your API key for the rest of this guide!

    ### 3. Configure your app's `PrivyProvider`

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

    Next, set **Add confirmation modals** to "off" in your app's **Embedded wallets** page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [`UserOperation`](https://www.alchemy.com/overviews/user-operations)s they sign.

    Then, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            /* Replace this with your desired login methods */
            loginMethods: ['email', 'wallet'],
            /* Replace this with your desired appearance configuration */
            appearance: {
                theme: 'light',
                accentColor: '#676FFF',
                logo: 'your-logo-url'
            }
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
                showWalletUIs: false
            }
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 4. Create a smart account for your user

    You'll now create a smart account for your user, using the Privy embedded wallet (an EOA) as the signer.

    To do so, when the user logs in, **find the user's embedded wallet from Privy's `useWallets` hook, and create a viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) for it**. You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx
    import {useWallets} from '@privy-io/react-auth';
    import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
    import {createWalletClient, custom} from 'viem';

    ...

    // Find the embedded wallet and get its EIP1193 provider
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    const eip1193provider = await embeddedWallet.getEthereumProvider();

    // Create a viem WalletClient from the embedded wallet's EIP1193 provider
    // This will be used as the signer for the user's smart account
    const privyClient = createWalletClient({
        account: embeddedWallet.address,
        chain: sepolia, // Replace this with the chain used by your application
        transport: custom(eip1193provider)
    });
    ```

    Next, using the **`privyClient`** from above, create a **`SmartAccountClient`** which represents the user's smart account. In creating the smart account, you can also specify which smart account implementation you'd like to use. Possible options include: [Safe](https://docs.pimlico.io/permissionless/how-to/accounts/use-safe-account), [Kernel](https://docs.pimlico.io/permissionless/how-to/accounts/use-kernel-account), [Biconomy](https://www.biconomy.io/), and [SimpleAccount](https://docs.pimlico.io/permissionless/how-to/accounts/use-simple-account) (the original smart account implementation).

    If your app also uses a **paymaster** to sponsor gas on behalf of users, you can also specify which paymaster to use by calling the **`createPimlicoPaymasterClient`** method from `permissionless` with the RPC URL in your Pimlico Dashboard.

    ```ts
    import {createSmartAccountClient, walletClientToCustomSigner} from 'permissionless';
    import {signerToSimpleSmartAccount} from 'permissionless/accounts';
    import {createPimlicoPaymasterClient} from 'permissionless/clients/pimlico';
    import {createPublicClient, http} from 'viem';

    // The `privyClient` comes from the snippet above
    const customSigner = walletClientToCustomSigner(privyClient);

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your app
      transport: http()
    });

    // Initialize the smart account for the user
    const simpleSmartAccount = await signerToSimpleSmartAccount(publicClient, {
      entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
      signer: customSigner,
      factoryAddress: '0x9406Cc6185a346906296840746125a0E44976454'
    });

    // Create the Paymaster for gas sponsorship using the API key from your Pimlico dashboard
    const pimlicoPaymaster = createPimlicoPaymasterClient({
      transport: http('https://api.pimlico.io/v2/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY')
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: simpleSmartAccount,
      chain: sepolia, // Replace this with the chain for your app
      transport: http('https://api.pimlico.io/v1/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY'),
      sponsorUserOperation: pimlicoPaymaster.sponsorUserOperation // If your app uses a paymaster for gas sponsorship
    });
    ```

    When using the snippets above, make sure replace `YOUR_PIMLICO_API_KEY` with your Pimlico API key that you created in step 2!

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx
      /**
       * This example assumes your app is wrapped with the `PrivyProvider` and
       * is configured to create embedded wallets for users upon login. Aside from
       * the imports, all of the code in this snippet must be used within a React component
       * or context.
       */
      import {useWallets} from '@privy-io/react-auth';
      import {sepolia} from 'viem/chains'; // Replace this with the chain used by your application
      import {createWalletClient, createPublicClient, custom, http} from 'viem';
      import {createSmartAccountClient, walletClientToCustomSigner} from "permissionless";
      import {createPimlicoPaymasterClient} from "permissionless/clients/pimlico";
      import {signerToSimpleSmartAccount} from "permissionless/accounts";

      ...

      // Find the embedded wallet and get its EIP1193 provider
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
      const eip1193provider = await embeddedWallet.getEthereumProvider();

      // Create a viem WalletClient from the embedded wallet's EIP1193 provider
      const privyClient = createWalletClient({
          account: embeddedWallet.address,
          chain: sepolia, // Replace this with the chain used by your application
          transport: custom(eip1193provider)
      });

      // Create a viem public client for RPC calls
      const publicClient = createPublicClient({
        chain: sepolia, // Replace this with the chain of your app
        transport: http()
      })

      // Initialize the smart account for the user using the embedded wallet as the signer
      const customSigner = walletClientToCustomSigner(privyClient);
      const simpleSmartAccount = await signerToSimpleSmartAccount(publicClient, {
          entryPoint: "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
          signer: customSigner,
          factoryAddress: "0x9406Cc6185a346906296840746125a0E44976454"
      })

      // Create the Paymaster for gas sponsorship using the API key from your Pimlico dashboard
      const pimlicoPaymaster = createPimlicoPaymasterClient({
          transport: http(
              "https://api.pimlico.io/v2/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY",
          ),
      })

      // Create the SmartAccountClient for requesting signatures and transactions
      const smartAccountClient = createSmartAccountClient({
          account: simpleSmartAccount,
          chain: sepolia, // Replace this with the chain for your app
          transport: http("https://api.pimlico.io/v1/sepolia/rpc?apikey=YOUR_PIMLICO_API_KEY"),
          sponsorUserOperation: pimlicoPaymaster.sponsorUserOperation // If your app uses a paymaster for gas sponsorship
      })
      ```

      Note: if your app uses React, we suggest that you store the user's `SmartAccountClient` in a [React context](https://react.dev/learn/passing-data-deeply-with-context) that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ### 5. Send transactions from the smart account

    You can now send transactions using the **`sendTransaction`** method on the [**`SmartAccountClient`**](https://docs.pimlico.io/permissionless/reference/clients/smartAccountClient) object, like so:

    ```ts
    const txHash = await smartAccountClient.sendTransaction({
      account: smartAccountClient.account,
      to: zeroAddress,
      data: '0x',
      value: BigInt(0)
    });
    ```

    You can also request signatures, typed data signatures, and more from the smart account! The [**`SmartAccountClient`**](https://docs.pimlico.io/permissionless/reference/clients/smartAccountClient) functions as a drop-in replacement for [`viem`'s wallet client](https://viem.sh/docs/clients/wallet#wallet-client) - you can use the same interfaces with the [**`SmartAccountClient`**](https://docs.pimlico.io/permissionless/reference/clients/smartAccountClient) object!

    **That's it! Once you've created smart accounts for your users, you can easily add AA features into your application like gas sponsorship, batched transactions, and more.** 🎉
  </Tab>

  <Tab title="Biconomy">
    ## Account abstraction with Biconomy

    <Info>
      Biconomy has an updated guide for using the new [Biconomy
      Nexus](https://www.biconomy.io/post/nexus-modular-smart-account) smart accounts. Please refer to
      the [Biconomy guide](https://docs.biconomy.io/tutorials/signers/privy) for the most up-to-date
      information.
    </Info>

    [Biconomy](https://www.biconomy.io/) is a toolkit for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart accounts for your users, using the user's EOA as the smart account's signer. This allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) features into your app.

    **You can easily integrate Biconomy alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with [gas sponsorship](https://docs.biconomy.io/dashboard/paymaster) and more!**

    Read below to learn how to configure your app to create smart wallets for *all* your users!

    <Tip>
      Want to see an end-to-end integration of Privy with Biconomy? Check out **an example
      [app](https://aaprivy.vercel.app/) and [repo](https://github.com/bcnmy/biconomy_privy_example)**!
    </Tip>

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. Biconomy's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from Biconomy). The smart wallet (Biconomy) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    ### 1. Install Privy and Biconomy

    In your app's repository, install the [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth) SDK from Privy and the [**`@biconomy/account`**](https://docs.biconomy.io/Account/integration#installation) SDK from Biconomy:

    ```sh
    npm i @privy-io/react-auth @biconomy/account
    ```

    ### 2. Configure your app's `PrivyProvider`

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

    Next, set **Add confirmation modals** to "off" in your app's **Embedded wallets** page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [`UserOperation`](https://www.alchemy.com/overviews/user-operations)s they sign.

    Then, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
            }
            ...insertTheRestOfYourPrivyProviderConfig
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 3. Configure your Biconomy bundler and paymaster

    Go to the [**Biconomy Dashboard**](https://dashboard.biconomy.io/) and configure a **Paymaster** and a **Bundler** for your app. Make sure these correspond to the desired network for your user's smart accounts.

    <figure style="width: 100%; display: flex; flex-direction: column; align-items: center;">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/biconomy-paymaster.png" style="width: 80%;" alt="Pregenerate user wallets" />

      <figcaption>Configuring your Biconomy Paymaster</figcaption>
    </figure>

    Once you've configured a **Paymaster**, you can also deposit funds into your app's gas tank and configure specific policies for [**gas sponsorship**](https://docs.biconomy.io/dashboard/paymaster).

    Save the bundler URL and paymaster API key for your project, as you will need those values later.

    ### 4. Initialize your users' smart accounts

    When users log into your app, Privy provisions each user an embedded wallet, which is an EOA. In order to leverage the features of Biconomy's account abstraction, each user also needs a Biconomy smart account. **You can provision Biconomy smart accounts for each user by assigning their embedded wallet as a signer for their smart account**.

    To start, after a user logs in, **find the user's embedded wallet from Privy's `useWallets` hook, and switch its network to your app's target network**. You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx
    import {useWallets} from '@privy-io/react-auth';
    ...
    // Find the embedded wallet
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    // Switch the embedded wallet to your target network
    // Replace '80001' with your desired chain ID.
    await embeddedWallet.switchChain(80001);
    ```

    Next, using your paymaster API key and bundler URL from the Biconomy Dashboard, **initialize the user's smart account using Biconomy's [`createSmartAccountClient`](https://docs.biconomy.io/Account/methods#createsmartaccountclient) method**:

    ```tsx
    import { createSmartAccountClient } from "@biconomy/account";
    ...
    // Get an ethers provider and signer for the user's embedded wallet
    const provider = await embeddedWallet.getEthereumProvider();
    const ethersProvider = new ethers.providers.Web3Provider(provider);
    const ethersSigner = ethersProvider.getSigner()

    const smartAccount = await createSmartAccountClient({
        signer: ethersSigner,
        bundlerUrl: 'your-bundler-url-from-the-biconomy-dashboard',
        biconomyPaymasterApiKey: 'your-paymaster-api-key-from-the-biconomy-dashboard'
    });
    ```

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx
      import {createSmartAccountClient} from '@biconomy/account';

      import {useWallets} from '@privy-io/react-auth';

      // Find the embedded wallet and switch it to your target network
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
      await embeddedWallet.switchChain(80001);

      const provider = await embeddedWallet.getEthereumProvider();
      const ethersProvider = new ethers.providers.Web3Provider(provider);
      const ethersSigner = ethersProvider.getSigner();

      // Initialize your smart account
      const smartAccount = await createSmartAccountClient({
        signer: ethersSigner,
        bundlerUrl: 'your-bundler-url-from-the-biconomy-dashboard',
        biconomyPaymasterApiKey: 'your-paymaster-api-key-from-the-biconomy-dashboard'
      });
      ```

      Note: if your app uses React, we suggest that you store the user's Biconomy `smartAccount` in a React context that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ## 5. Send transactions from the smart account

    Now that your users have Biconomy smart accounts, they can now send transaction from their smart account.

    To send a transaction from a user's smart account, use Biconomy's [**`sendTransaction`**](https://docs.biconomy.io/Account/methods#sendtransaction-) method. An example of sending a transaction to mint an NFT gaslessly is below:

    ```tsx
    // Initialize an ethers JsonRpcProvider for your network
    const provider = new ethers.providers.JsonRpcProvider(`insert-rpc-url-for-your-network`);
    // Initialize an ethers contract instance for your NFT
    const nft = new ethers.Contract('insert-your-NFT-address', insertYourNftAbi, provider);

    // Construct a Transaction for the minting transaction
    const mintTransaction = await nft.populateTransaction.mint!('insert-the-smart-account-address');
    // `smartAccount` is the Biconomy smart account we initialized above
    const mintTx = {
      to: 'insert-your-NFT-address',
      data: mintTransaction.data
    };

    // Send transaction to mempool, to mint NFT gaslessly
    const userOpResponse = await smartAccount.sendTransaction(mintTx, {
      paymasterServiceData: {mode: PaymasterMode.SPONSORED}
    });

    const {transactionHash} = await userOpResponse.waitForTxHash();
    console.log('Transaction Hash', transactionHash);

    const userOpReceipt = await userOpResponse.wait();
    if (userOpReceipt.success == 'true') {
      console.log('UserOp receipt', userOpReceipt);
      console.log('Transaction receipt', userOpReceipt.receipt);
    }
    ```

    **That's it! You've configured your app to create smart wallets for all of your users, and can seamlessly add in AA features like [gas sponsorship](https://docs.biconomy.io/dashboard/paymaster) and more.** 🎉
  </Tab>

  <Tab title="AccountKit">
    ## Account Abstraction with AccountKit

    [AccountKit](https://accountkit.alchemy.com/) is a toolkit by [Alchemy](https://www.alchemy.com/) for creating [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)-compatible smart accounts for your users, using the user's EOA as the smart account's signer. This allows you to easily add [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) features into your app.

    **You can easily integrate AccountKit alongside Privy to create smart wallets from your user's embedded or external wallets, allowing you to enhance your app with gas sponsorship, batched transactions, and more!**

    Read below to learn how to configure your app to create smart wallets for *all* your users!

    <details>
      <summary><b>What is an EOA?</b></summary>

      An [**EOA, or externally-owned account**](https://ethereum.org/en/developers/docs/accounts/), is any Ethereum account that is controlled by a private key. Privy's embedded wallets and most external wallets (MetaMask, Coinbase Wallet, Rainbow Wallet, etc.) are EOAs.

      EOAs differ from **contract accounts**, which are instead controlled by smart contract code and do not have their own private key. AccountKit's smart wallet is a contract account. Contract accounts have [enhanced capabilities, such as gas sponsorship and batched transactions](https://ethereum.org/en/roadmap/account-abstraction/).

      Since they do not have their own private key, contract accounts cannot *directly* produce signatures and initiate transaction flows. Instead, each contract account is generally "managed" by an EOA, which authorizes actions taken by the contract account via a signature; this EOA is called a **signer**.

      In this integration, the user's EOA (from Privy) serves as the signer for their smart wallet (from AccountKit). The smart wallet (AccountKit) holds all assets and submits all transactions to the network, but the signer (Privy) is responsible for producing signatures and "kicking off" transaction flows.
    </details>

    ### 1. Install Privy and AccountKit

    Install the [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth) SDK from Privy, the [**`@alchemy/{aa-core, aa-alchemy}`**](https://accountkit.alchemy.com/package-overview.html) SDKs from Alchemy, and [**`viem`**](https://viem.sh/):

    ```sh
    npm i @privy-io/react-auth @alchemy/aa-core @alchemy/aa-alchemy @alchemy/aa-accounts viem
    ```

    ### 2. Configure your app's `PrivyProvider`

    First, follow the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

    Next, set **Add confirmation modals** to "off" in your app's **Embedded wallets** page in the Privy [**dashboard**](https://dashboard.privy.io). This will configure Privy to *not* show its default UIs when your user must sign messages or send transactions. Instead, we recommend you use your own custom UIs for showing users the [`UserOperation`](https://www.alchemy.com/overviews/user-operations)s they sign.

    Then, update the **`config.embeddedWallets.createOnLogin`** property of your **`PrivyProvider`** to `'users-without-wallets'`.This will configure Privy to create an embedded wallet for users logging in via a web2 method (email, phone, socials), ensuring that *all* of your users have a wallet that can be used as an EOA.

    Your **`PrivyProvider`** should then look like:

    ```tsx
    <PrivyProvider
        appId='insert-your-privy-app-id'
        config={{
            /* Replace this with your desired login methods */
            loginMethods: ['email', 'wallet'],
            /* Replace this with your desired appearance configuration */
            appearance: {
                theme: 'light',
                accentColor: '#676FFF',
                logo: 'your-logo-url'
            }
            embeddedWallets: {
                createOnLogin: 'users-without-wallets',
                showWalletUIs: false
            },
            // Import your desired chain from `viem/chains` and pass it to `defaultChain`
            defaultChain: sepolia,
        }}
    >
        {/* Your app's components */}
    </PrivyProvider>
    ```

    ### 3. Initialize your users' smart accounts

    When users log into your app, Privy provisions each user an embedded wallet, which is an EOA. In order to leverage the features of Alchemy's account abstraction, each user also needs a smart account from AccountKit. **You can provision smart accounts with AccountKit for each user by assigning their embedded wallet as a signer for their smart account**.

    To start, after a user logs in, **find the user's embedded wallet from Privy's `useWallets` hook, and create a viem [`WalletClient`](https://viem.sh/docs/clients/wallet.html) for it**. You can find embedded wallet by finding the only entry in the **`useWallets`** array with a **`walletClientType`** of `'privy'`.

    ```tsx
    import {useWallets} from '@privy-io/react-auth';
    import {sepolia} from 'viem/chains';
    import {createWalletClient, custom} from 'viem';

    ...

    // Find the embedded wallet and get its EIP1193 provider
    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => (wallet.walletClientType === 'privy'));
    const eip1193provider = await embeddedWallet.getEthereumProvider();

    // Create a viem WalletClient from the embedded wallet's EIP1193 provider
    const privyClient = createWalletClient({
        account: embeddedWallet.address,
        chain: sepolia,
        transport: custom(eip1193provider)
    });
    ```

    Then, **from the embedded wallet's [`WalletClient`](https://viem.sh/docs/clients/wallet.html), initialize an AccountKit [`SmartAccountSigner`](https://accountkit.alchemy.com/packages/aa-core/signers/wallet-client.html)**, like below. This configures the user's embedded wallet (EOA, from Privy) to be the **signer** for their smart account (contract account, from AccountKit).

    ```tsx
    import { WalletClientSigner, type SmartAccountSigner } from "@alchemy/aa-core";

    ...

    // Create an AccountKit SmartAccountSigner from the embedded wallet
    const privySigner: SmartAccountSigner = new WalletClientSigner(
        privyClient,
        "json-rpc"
    );
    ```

    Lastly, with the user's [`SmartAccountSigner`](https://accountkit.alchemy.com/packages/aa-core/signers/wallet-client.html), initialize an instance of an [`AlchemySmartAccountClient`](https://accountkit.alchemy.com/packages/aa-alchemy/light-account-client/). You will later use this smart account client to send transactions from the user's smart account.

    ```tsx
    import { createLightAccountAlchemyClient } from "@alchemy/aa-alchemy";

    ...

    // Create an Alchemy Light Account Client with the `privySigner`
    export const smartAccountClient = await createLightAccountAlchemyClient({
      account: {
        signer: privySigner,
      },
      chain: sepolia,
      apiKey: "YOUR_ALCHEMY_API_KEY",
    });
    ```

    <Tip>
      You can also store the user's smart account address on Privy's user object. See [this
      guide](./address.md) for more.
    </Tip>

    <details>
      <summary><b>Want to see this code end-to-end?</b></summary>
      You can find the code snippets above pasted in an end-to-end example below.

      ```tsx
      /**
       * This example assumes your app is wrapped with the `PrivyProvider` and
       * is configured to create embedded wallets for users upon login.
       */

      import {createLightAccountAlchemyClient} from '@alchemy/aa-alchemy';
      import {WalletClientSigner, type SmartAccountSigner} from '@alchemy/aa-core';
      import {createWalletClient, custom} from 'viem';
      import {sepolia} from 'viem/chains';

      import {useWallets} from '@privy-io/react-auth';

      // The code below makes use of Privy's React hooks. You must paste
      // or use it within a React Component or Context.

      // Find the user's embedded wallet
      const {wallets} = useWallets();
      const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

      // Get a viem client from the embedded wallet
      const eip1193provider = await embeddedWallet.getEthereumProvider();
      const privyClient = createWalletClient({
        account: embeddedWallet.address,
        chain: sepolia,
        transport: custom(eip1193provider)
      });

      // Create a smart account signer from the embedded wallet's viem client
      const privySigner: SmartAccountSigner = new WalletClientSigner(privyClient, 'json-rpc');

      // Create an Alchemy Light Account Client with the `privySigner`
      export const smartAccountClient = await createLightAccountAlchemyClient({
        account: {
          signer: privySigner
        },
        chain: sepolia,
        apiKey: 'YOUR_ALCHEMY_API_KEY'
      });
      ```

      Note: if your app uses React, we suggest that you store the user's AccountKit `SmartAccountSigner` and `AlchemySmartAccountClient` in a [React context](https://react.dev/learn/passing-data-deeply-with-context) that wraps your application. This allows you to easily access the smart account from your app's pages and components.
    </details>

    ## 5. Send UserOperations from the smart account

    Now that your users have AccountKit smart accounts, they can now send [user operations](https://eips.ethereum.org/EIPS/eip-4337) from their smart account. This is the AA analog to sending a transaction.

    **To send a user operation from a user's smart account, use the [`AlchemySmartAccountClient`](https://accountkit.alchemy.com/packages/aa-alchemy/provider/introduction.html)'s [`sendUserOperation`](https://accountkit.alchemy.com/packages/aa-core/provider/sendUserOperation.html) method.**

    As a parameter to this method, you should pass an object containing a `uo` field with the desired user operation as the value.

    ```tsx
    // this is an example ABI for a contract with a "mint" function
    const ABI = [
      {
        inputs: [{internalType: 'address', name: 'recipient', type: 'address'}],
        name: 'mint',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
      }
    ];

    // Using `encodeFunctionData` from `viem`
    const uoCallData = encodeFunctionData({
      abi: ABI,
      functionName: 'mint',
      args: [smartAccountClient.getAddress()]
    });

    const uo = await smartAccountClient.sendUserOperation({
      uo: {
        target: '0xTARGET_ADDRESS',
        data: uoCallData
      }
    });
    const txHash = await smartAccountClient.waitForUserOperationTransaction(uo);
    console.log(txHash);
    ```

    **That's it! You've configured your app to create smart wallets for all of your users, and can seamlessly add in AA features like gas sponsorship, batched transactions, and more.** 🎉
  </Tab>
</Tabs>


# Funding wallets with Apple Pay and Google Pay
Source: https://docs.privy.io/recipes/card-based-funding



Privy makes it easy to allow your users to fund their embedded wallets with convenient payment methods like Apple Pay and Google Pay via `@privy-io/expo` and on the web through `@privy-io/react-auth`.

This guide will walk you through setting up Privy's funding flows, allowing your users to fund their wallets quickly and easily in under two minutes.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/card-based-funding.png" />
</Frame>

## 1. Enable debit card funding in the Dashboard

In the [Privy
Dashboard](https://dashboard.privy.io/apps?page=funding), enable **Pay with card** on the **User management > Account funding** page.

With this option enabled, if Apple Pay or Google Pay is available on your user's device, Privy will provide users the option to purchase with those methods.

Choose your desired network across EVM and Solana and set a recommended amount for users to fund. Users can update the amount manually if they choose.

## 2. Prompt the user to fund

### `@privy-io/react-auth`

Prompt the user to fund by calling `fundWallet`

<Tabs>
  <Tab title="Fund with EVM">
    | Parameter | Type                                                | Description                                                                                                                                                                                                                                                                               |
    | --------- | --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `chain`   | [`Chain`](https://viem.sh/docs/chains/introduction) | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                                                    |
    | `asset`   | `'native-currency' \| 'USDC' \| {erc20: string}`    | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or a token address in the `erc20` field to fund with an arbitrary ERC20. Defaults to `'native-currency'`. |
    | `amount`  | `string`                                            | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                        |

    ```tsx
    import {useFundWallet} from '@privy-io/react-auth';
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      chain: base,
      amount: '0.01' // Since no `asset` is set, defaults to 'native-currency' (ETH)
    })
    ```
  </Tab>

  <Tab title="Fund with SOL">
    | Parameter | Type            | Description                                                                                                                                                        |
    | --------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | `cluster` | `SolanaCluster` | Optional. An object for the cluster on which users should fund their accounts. Defaults to `mainnet-beta`.                                                         |
    | `amount`  | `string`        | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard. |

    As an example, you can configure the cluster and amount to fund like so:

    ```tsx
    import {useFundWallet} from '@privy-io/react-auth/solana';
    ...
    // `fundWallet` from the useFundWallet() hook
    const {fundWallet} = useFundWallet();
    fundWallet('your-wallet-address-here', {
      cluster: {name: 'devnet'},
      amount: '0.01', // SOL
    });
    ```
  </Tab>
</Tabs>

### `@privy-io/expo`

<Tabs>
  <Tab title="Fund with EVM">
    | Parameter | Type                                                | Description                                                                                                                                                                                                                                                                               |
    | --------- | --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `address` | `string`                                            | The destination address to fund.                                                                                                                                                                                                                                                          |
    | `chain`   | [`Chain`](https://viem.sh/docs/chains/introduction) | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                                                    |
    | `asset`   | `'native-currency' \| 'USDC' \| {erc20: string}`    | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or a token address in the `erc20` field to fund with an arbitrary ERC20. Defaults to `'native-currency'`. |
    | `amount`  | `string`                                            | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                        |

    ```tsx
    import {useFundWallet} from '@privy-io/expo/ui';
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet({
      address: '0x2F3eb40872143b77D54a6f6e7Cc120464C764c09',
      asset: "USDC",
      chain: base,
      amount: '1'
    })
    ```
  </Tab>

  <Tab title="Fund with SOL">
    | Parameter | Type            | Description                                                                                                                                                        |
    | --------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | `cluster` | `SolanaCluster` | Optional. An object for the cluster on which users should fund their accounts. Defaults to `mainnet-beta`.                                                         |
    | `amount`  | `string`        | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard. |

    As an example, you can configure the cluster and amount to fund like so:

    ```tsx
    import {useFundSolanaWallet} from '@privy-io/expo/ui';
    ...
    // `fundWallet` from the useFundSolanaWallet() hook
    const {fundWallet} = useFundSolanaWallet();
    fundWallet({
      address: 'address'
      amount: '0.01', // SOL
    });
    ```
  </Tab>
</Tabs>

## All set!

Users can now fund their wallets with Apple Pay and Google Pay natively within the application.


# Configure account transfer
Source: https://docs.privy.io/recipes/dashboard/account-transfer



### Login method transfer

If **User management > Authentication > Login method transfer** is enabled, if a user attempts to link a login method that is already linked to another account they own, they can choose to transfer the login method to their currently logged-in account.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/account-transfer.png" alt="Sample account transfer flow" />
</Frame>

**Once the login method is transferred to the current user, the previous account will then be deleted.** Please ensure that the embedded wallet associated with the previous account has either been exported or that its assets have been transferred out prior to the account deletion.

<Info>
  Currently, login method transfer is only supported when the orphan account is associated with a
  single login method (the account to transfer). We are working to allow for transfers of login
  methods without full deletion of the orphan account to allow for login method transfer when
  multiple login methods are linked to the orphan account.
</Info>


# Customize your application
Source: https://docs.privy.io/recipes/dashboard/customization



Use the **Configuration > UI components** page of the dashboard to configure your app's brand settings, including name, logo, accent color, and legal policies.

## Name

Use the **Name** input to set a name for your product as you'd like to present it to users. Privy will use this value to reference your product in OTP messages sent to users for login and various UIs throughout your app.

## Logo

Use the **Logo** input to set a logo for your product. Provide the URL to a hosted image. We recommend a 2:1 aspect ratio with a size of 180px by 90px for best results. Please note that SVGs are not allowed, as they are incompatible with many major email clients.

Privy will use this logo in two places:

* in OTP emails sent to your users for passwordless email login
* in the Privy modal shown to users when they login to your app

If you'd like to remove the logo from the Privy modal or set a different logo instead, you can customize the logo via the SDK directly. You should still set a logo in the dashboard for use in OTP emails.

## Brand color

Use the **Brand color** input to set an accent color for your application. Provide the color as a hexadecimal string. This will apply to links and buttons within Privy's UIs in your app.

## Legal

### Terms & conditions

Use the **Terms & conditions** input to set the terms & conditions for your app. Please provide a hosted URL to a publicly viewable site.

If set, users will be shown your terms & conditions as part of their login flow.

### Privacy policy

Use the **Privacy policy** input to set the privacy policy for your app. Please provide a hosted URL to a publicly viewable site.

If set, users will be shown your privacy policy as part of their login flow.

### Affirmative consent

If your app requires affirmative consent for your users for your terms & conditions and privacy policy, enable the **Require affirmative consent** option.

If enabled, users will be prompted for affirmative consent on your legal policies as part of their first login to your app. If disabled, users will be shown your legal policies without an explicit prompt.


# Configure SMS login
Source: https://docs.privy.io/recipes/dashboard/login-methods/sms



Privy enables your users to log in via SMS or link verified phone numbers to their account. You can enable SMS login and linking via the **Login Methods** page of the dashboard.

<Info>
  For most apps, we recommend either including alternative login options alongside SMS or enabling
  [Multi-Factor Authentication](/authentication/user-authentication/mfa). This ensures broad
  accessibility in regions without SMS coverage and that users can continue accessing their accounts
  in the event that they lose SMS access.
</Info>

## Region support

US- and Canada-only region support is included at no additional cost on all plans (Developer, Pro, and Enterprise).

You can request access to international SMS via the **Login Methods** page of the dashboard. Once approved, international SMS will automatically be enabled for all apps on your account. International region support is available on the Enterprise plan.

<Info>
  If you enable SMS login, you may be responsible for additional charges per SMS sent. Underlying
  Twilio network costs will be passed through directly. See Twilio's pricing page
  [here](https://assets.cdn.prod.twilio.com/pricing-csv/SMSPricing.csv).
</Info>

## International region support

You can request access to international SMS via the **Login Methods** page of the dashboard. By default, Privy supports the following regions for the international SMS plan:

<Tip>
  Region support is subject to change. If you would like to request access to additional SMS regions
  for your account, please reach out to [support@privy.io](mailto:support@privy.io)!
</Tip>

<Info>
  Supported regions may differ for your app if you enabled international SMS prior to August 26,
  2024\.
</Info>

<Expandable title="list of supported international regions for SMS">
  | Region         | Region Code |
  | -------------- | ----------- |
  | Argentina      | +54         |
  | Australia      | +61         |
  | Canada         | +1          |
  | Chile          | +56         |
  | Czech Republic | +420        |
  | Germany        | +49         |
  | Hong Kong      | +852        |
  | Hungary        | +36         |
  | Japan          | +81         |
  | New Zealand    | +64         |
  | Portugal       | +351        |
  | Saudi Arabia   | +966        |
  | Singapore      | +65         |
  | South Korea    | +82         |
  | Sweden         | +46         |
  | Taiwan         | +886        |
  | Thailand       | +66         |
  | Turkey         | +90         |
  | United Kingdom | +44         |
  | United States  | +1          |
</Expandable>


# Optimize your setup
Source: https://docs.privy.io/recipes/dashboard/optimizing



For developers looking to optimize their Privy integration, we have a few key features that should help fine-tune the performance your setup.

## Manually set a verification key for authorization

When verifying a Privy access token to authorize requests to your servers, by default the Privy Client's `verifyAuthToken` method will make a request to Privy's API to fetch the verification key for your app. Although it is cached for reuse, you can avoid this API request entirely by copying your verification key from the [Configuration > App settings > Basics tab of the Dashboard](https://dashboard.privy.io/apps?page=settings), under "Verify with key instead", and passing it as a second parameter to `verifyAuthToken`:

```ts
const verifiedClaims = await privy.verifyAuthToken(
  authToken,
  'paste-your-verification-key-from-the-dashboard'
);
```

If you ever rotate your verification key, you will have to update this, but this will remove any network dependency on Privy for token verification.

## Get user data with identity tokens

If you need access to the user object, especially on the server, this can be a costly action. To remove a network call from your critical path, we recommend using Privy's [identity tokens](/user-management/users/identity-tokens), which include the latest user information in token form. While it does not have the full user details (it omits certain lesser-needed fields for efficiency), it should have what you need to get started quickly.

## Set a custom API URL for `HttpOnly` cookies (`react-auth` only)

In the case where you have set up and enabled `HttpOnly` cookies, on initial page load, the Privy SDK will start by making a call to fetch app details on our default `https://auth.privy.io` API URL. In `HttpOnly` cookie mode however, all your requests are routed through `https://privy.<customdomain.com>`. To avoid an occasional extra call on page load, we recommend explicitly setting the `apiUrl` in your `PrivyProvider`:

```tsx
return (
  <PrivyProvider
    appId={'your-app-ID'}
    // @ts-expect-error currently a beta feature
    apiUrl="https://privy.customdomain.com"
  >
    {children}
  </PrivyProvider>
);
```

Note that this has a risk - if you are ever *disabling* `HttpOnly` cookies, you will need to remove this in order for your app to continue functioning properly. For a smooth transition, first remove the `apiUrl`, deploy, and then disable HttpOnly cookies.


# Configure log in with Telegram
Source: https://docs.privy.io/recipes/dashboard/telegram



Privy enables developers to quickly integrate Login with Telegram into their applications. With the Privy Telegram integration, users can log in with Telegram and link Telegram accounts.

From a web environment, Privy enables Telegram login via the [Telegram Login widget](https://core.telegram.org/widgets/login). Privy also enables seamless Telegram login directly from within a Telegram bot or within Telegram Mini-Apps!

## Configure Telegram

### Configure Telegram login

Follow [this](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) guide to create a telegram bot. After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. You will need to provide the following to Privy via the Privy Dashboard upon completion:

* Bot token (eg: `1234567890:AzByCxDwEvFuGtHsIr1k2M4o5Q6s7U8w9Y0`)
* Bot handle (eg: `@MyBot_bot`)

Note that when configuring Telegram login:

* Your domain must be configured as your bot's allowed domain.
* If you have CSP enforcement, you’ll need to update these directives:
  * `script-src` must allow `https://telegram.org` in order to be able to download Telegram's widget script.
  * `frame-src` must allow `https://oauth.telegram.org` in order to be able to render Telegram's widget iframe.

<Tip>
  To use your app as a Telegram Mini-App in the Telegram web client, add `http://web.telegram.org`
  and `https://web.telegram.org` to your allowed domains in the dashboard [Configuration > App
  settings > Domains](https://dashboard.privy.io?page=settings) page.
</Tip>

<Info>
  Since you need to set your bot's allowed domain you'll need to use a tunneling tool for local
  development such as [Cloudflare
  tunnels](https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/) or
  [ngrok](https://ngrok.com/).
</Info>

### Essential: Secure your bot secret

<Warning>
  Telegram login requires developers to create a Telegram bot with a bot secret. This bot secret controls the Telegram bot and is also used as a symmetric key for authentication. Control over this key enables a developer to sign over authentication data, meaning compromise of this key puts your users (and their accounts) at risk.

  **Securing this symmetric key is essential for the security of all of your app’s Telegram logins.**
</Warning>

## Integration interfaces

### \[optional] Enable Telegram in your client-side `loginMethods`

You must enable Telegram in the Privy Dashboard to enable login with Telegram.

If you *additionally* have `loginMethods` configured client-side in your `PrivyProvider` config, make sure you add `"telegram"` to that list as well. Client-side login method configuration is only necessary if you want to restrict logins to a subset of those configured in the Dashboard.

```jsx
  <PrivyProvider
    appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ""}
    config={{
      loginMethods: ["email", "google", "telegram"],
      ...
    }}
  >
```

### Seamless login with Telegram

You can integrate Privy to enable login directly from within a Telegram bot or Telegram mini-app.

* If enabled, Privy will automatically log your user in when your user initiates login from within Telegram. You *do not* have to call `login` from the `usePrivy` hook in this case!
* To enable seamless login, send your website URL using [KeyboardButton.web\_app](https://core.telegram.org/bots/api#keyboardbutton), [InlineKeyboardButton.web\_app](https://core.telegram.org/bots/api#inlinekeyboardbutton) or [InlineKeyboardButton.login\_url](https://core.telegram.org/bots/api#inlinekeyboardbutton) or use a direct link (ex: `t.me/xxx_bot/xxx`)
* For reference, see these docs:
  * [https://core.telegram.org/bots/api#keyboardbutton](https://core.telegram.org/bots/api#keyboardbutton)
  * [https://core.telegram.org/bots/api#inlinekeyboardbutton](https://core.telegram.org/bots/api#inlinekeyboardbutton)

```jsx
bot.send_message(chat_id, 'Log in to demo!', {
  reply_markup: {
    inline_keyboard: [
      [
        {
          text: 'Login',
          login_url: {url: 'https://your-website-url'}
        },
        {
          text: 'Mini App',
          web_app: {url: 'https://your-website-url'}
        }
      ]
    ]
  }
});
```

### Login with Telegram

Once Telegram is enabled, you will *automatically* see Telegram in the Privy login modal. You can also list `'telegram'` when [configuring login methods client-side](/basics/react/advanced/configuring-appearance), in the `PrivyProvider`.

### Link Telegram

You can use the `linkTelegram` and `unlinkTelegram` methods from the `usePrivy` hook to add or remove Telegram accounts from a user. See the SDK reference for more details:

```jsx
const {linkTelegram, unlinkTelegram} = usePrivy();
```

### Link Telegram seamlessly within a Telegram Mini app

You can use the `linkTelegram` methods from the `usePrivy` hook within a Telegram Mini App to add to a user seamlessly by passing `launchParams` as a parameter. See the SDK reference for more details:

```jsx
// Sample library to retrieve launchParams
import {retrieveLaunchParams} from '@telegram-apps/bridge';

const {linkTelegram} = usePrivy();
const launchParams = retrieveLaunchParams();
linkTelegram({launchParams});
```

<Warning>Telegram `launchParams` are treated as expired after five minutes for security.</Warning>

### TelegramAccount type

The `user` object contains information about [all of the accounts](/user-management/users/the-user-object) a user has linked with Privy.

```jsx
Use the fields:
- **`user.linkAccounts`** to get a list of all the user's linked accounts
- **`user.telegram`** to get the user's Telegram account
```

**`TelegramAccount` extends `LinkedAccount`**

| Field              | Type       | Description                                                      |
| ------------------ | ---------- | ---------------------------------------------------------------- |
| type               | 'telegram' | N/A                                                              |
| telegram\_user\_id | string     | ID of a user's telegram account.                                 |
| first\_name        | string     | The first name displayed on a user's telegram account.           |
| last\_name         | string     | (Optional) The last name displayed on a user's telegram account. |
| username           | string     | (Optional) The username displayed on a user's telegram account.  |
| photo\_url         | string     | (Optional) The url of a user's telegram account profile picture. |


# Building a Farcaster Mini App (frame)
Source: https://docs.privy.io/recipes/farcaster/frames



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

**Privy enables seamless login with your user's Farcaster account within a Mini App.** This means you can easily integrate Privy with Farcaster Mini Apps to compose experiences with a user's existing social graph or network.

Here's how!

<Tip>
  Check out a live example of using Privy in a Mini App to have your users sending blockchain
  transactions in seconds! All code is [available on
  GitHub](https://github.com/privy-io/privy-frames-v2-demo).
</Tip>

<Expandable title="How does seamless Farcaster login work in a Mini App?">
  Privy uses a standard called **Sign in with Farcaster** ([FIP-11](https://github.com/farcasterxyz/protocol/discussions/110)) to issue a signature request to a user's Farcaster account via the client a user has.

  The [Mini Apps v2 spec](https://docs.farcaster.xyz/developers/frames/v2/spec#feature-auth) introduces a new `sdk.actions.signIn` action. This will produce the same [FIP-11](https://github.com/farcasterxyz/protocol/discussions/110) conformant signature automatically on the Warpcast mobile app.

  The `sdk.actions.signIn` action, in combination with the Privy `useLoginToFrame` hook, provides a seamless login experience that automatically and securely authenticates a user on Warpcast.
</Expandable>

### 1. Enable Farcaster login in your dashboard

Go to your app in your [developer dashboard](https://dashboard.privy.io/apps?page=login-methods) and navigate to **User management > Authentication > Socials**. From here, enable **Farcaster** as a social option.

This will enable you to configure Farcaster as a login and account linking option in your app.

### 2. Configure your allowed domains

<Info>
  When building a Farcaster Mini App, you must include `https://warpcast.com` as an allowed domain. Allowed domains is **required** for iframe-in-iframe which Warpcast uses, even for staging environments.
</Info>

Go to the `Domains` tab of your `Configuration > App settings` page in the developer dashboard and [configure allowed domains](/recipes/react/allowed-domains) for your app. This is the URL that your app is deployed to.

To use the embedded wallet, your application must also include `https://warpcast.com` as an allowed domain. Including Warpcast as an allowed domain allows the Privy iframe, where the embedded wallet is hosted, to load in the Warpcast browser app.

### 3. Configure your app's Farcaster integration

<Warning>
  Login with Coinbase smart wallet is not compatible with Farcaster Mini Apps (frames). Users can
  still login with their Coinbase EOA by configuring the `eoaOnly` login method
  [here](/wallets/connectors/setup/configuring-external-connector-wallets#configuring-the-coinbase-smart-wallet).
</Warning>

The following assumes you have set up Privy with your app. If you haven't, start by following the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

Be sure to configure `'farcaster'` as an upfront login method in your **`PrivyProvider`**, like so:

```tsx
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}
  config={{
    loginMethods: ['farcaster', ...insertTheRestOfYourLoginMethods]
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
```

### 4. Setup seamless Farcaster login with the Mini Apps SDK

<Warning>
  Automatic embedded wallet creation is currently not supported for farcaster frames, you must
  [manually create embedded wallets](/wallets/wallets/create/from-my-client) for your users at the
  desired point in your onboarding flow.
</Warning>

In your app, install the [@farcaster/frame-sdk](https://www.npmjs.com/package/@farcaster/frame-sdk).

Add the below `useEffect` to your main frame page. This will automatically log a user in, if they are not already authenticated.

```tsx
import frameSdk, { type FrameContext } from "@farcaster/frame-sdk";
import { usePrivy } from "@privy-io/react-auth";
import { useLoginToFrame } from "@privy-io/react-auth/farcaster";

...

const { ready, authenticated } = usePrivy();
const { initLoginToFrame, loginToFrame } = useLoginToFrame();

...

// Login to Mini App with Privy automatically
useEffect(() => {
  if (ready && !authenticated) {
    const login = async () => {
      // Initialize a new login attempt to get a nonce for the Farcaster wallet to sign
      const { nonce } = await initLoginToFrame();
      // Request a signature from Warpcast
      const result = await frameSdk.actions.signIn({ nonce: nonce });
      // Send the received signature from Warpcast to Privy for authentication
      await loginToFrame({
        message: result.message,
        signature: result.signature,
      });
    };
    login();
  }
}, [ready, authenticated]);
```

<Tip>
  Always check that `ready` and `authenticated` from the `usePrivy` hook is `true` before taking
  actions!
</Tip>

Once a user has logged in with or linked their Farcaster account, you can find their **`Farcaster`** object, including their `fid`, `username`, `pfp` and more, in the [**`user`**](/user-management/users/the-user-object) object returned by the `usePrivy` hook.

**That's it! You can now use this to power composable experiences in your new Mini App.** When building out your Mini App, be sure to visit [Farcaster's resources page](https://docs.farcaster.xyz/developers/frames/v2/resources) for help with testing and common issues!


# Writing to Farcaster
Source: https://docs.privy.io/recipes/farcaster/writes



[**Farcaster**](https://www.farcaster.xyz/) is a sufficiently decentralized social network whose core social graph is stored on-chain. Users can choose how content they create is stored and it enables unique, composable experiences by enabling users to link their accounts with a wallet of their choosing.

## Getting started

**Privy enables your users to easily log in to and write with their Farcaster account.** This means you can easily integrate Privy with Farcaster to compose experiences with a user's existing social graph or network. Generating a signer to power this is sponsored by the Privy team and is free to you and your users.

You can see a demo here: [https://farcaster-demo.vercel.app](https://farcaster-demo.vercel.app).
The example repo is at [https://github.com/privy-io/farcaster-demo](https://github.com/privy-io/farcaster-demo).

Here's how to get started!

### 0. Install the latest version of @privy-io/react-auth

In order to use embedded signers, we recommend you install the latest version of our SDK, as the interfaces have changed.

### 1. Login with Farcaster

The following assumes you have set up Privy with your app. If you haven't, start by following the instructions in the [**Privy Quickstart**](/basics/react/quickstart) to get your app set up with Privy.

You must also enable Farcaster as a sign-in method for your app from the dashboard. Please see the [**Farcaster Integration**](/authentication/user-authentication/login-methods/farcaster) recipe to get set up.

### 2. Create an embedded Farcaster signer

The first step to write to Farcaster is to create an embedded signer.

<details>
  <summary><b>What is an embedded Farcaster signer?</b></summary>

  Farcaster data is shared across a network of servers called "hubs". Hubs are responsible for verifying and sharing messages on the protocol. In order to submit messages, you need to create a Farcaster signer.

  This is an `ed25519` key-pair that is authorized to sign messages on your user's behalf. Privy generates a new non-custodial signer for your user.

  A user can authorize their embedded Farcaster signer to post on their behalf via Warpcast's signer connect flow. This allows your app to post messages with your user's Warpcast account!

  ***
</details>

In order to do so, a user must go through an authorization flow, which grants their new Farcaster signer permission to submit casts on their behalf. Use the `useFarcasterSigner()` hook to request a new signer from a user's existing Warpcast account.

```tsx
import { useFarcasterSigner, usePrivy } from @privy-io/react-auth;

const { user } = usePrivy();
const { requestFarcasterSignerFromWarpcast } = useFarcasterSigner();

const farcasterAccount = user.linkedAccounts.find((account) => account.type === 'farcaster');

<button
  onClick={() => requestFarcasterSignerFromWarpcast()}
  // Prevent requesting a Farcaster signer if a user has not already linked a Farcaster account
  // or if they have already requested a signer
  disabled={!farcasterAccount || farcasterAccount.signerPublicKey}
>
  Authorize my Farcaster signer from Warpcast
</button>
```

<Tip>
  You can see if your user already has an embedded Farcaster signer authorized by checking if
  `user.linkedAccounts.find((account) => account.type === 'farcaster').signerPublicKey` is defined!
</Tip>

### 3. Create an external signer

In order to interface with Farcaster libraries, we need to build a simple signer object. This can easily be constructed using the Privy Farcaster signer interfaces.

This step requires that you install [@standard-crypto/farcaster-js](https://www.npmjs.com/package/@standard-crypto/farcaster-js).

```
npm install @farcaster/frame-sdk
```

First, define an ExternalEd25519Signer:

```tsx
import {ExternalEd25519Signer} from '@standard-crypto/farcaster-js';

const {getFarcasterSignerPublicKey, signFarcasterMessage} = useFarcasterSigner();

const privySigner = new ExternalEd25519Signer(signFarcasterMessage, getFarcasterSignerPublicKey);
```

### 4. Build the hub client

Now that we have a signer object built, we can build our [@standard-crypto/farcaster-js](https://www.npmjs.com/package/@standard-crypto/farcaster-js) client for interacting with Farcaster!

```tsx
import {HubRestAPIClient} from '@standard-crypto/farcaster-js';

const client = new HubRestAPIClient({
  hubUrl: 'https://hub.farcaster.standardcrypto.vc:2281'
});
```

### 5. Submit a cast

Now that you have a client initialized, you can now begin submitting messages to the protocol!

Luckily, farcaster-js makes submitting a cast as easy as:

```tsx
const submitCastResponse = await client.submitCast(
  {text: 'Hello world!'},
  user.farcaster.fid,
  privySigner
);
```

### 6. Interact with other Farcasters!

Alright, your user has created a new cast, but how do they interact with other people?

First off, we need our user to follow people to display casts on their feed! Let's go ahead and follow Vitalik.

```tsx
// Vitalik's Farcaster ID (FID) is 5650
const followUserResponse = await client.followUser(5650, user.farcaster.fid, privySigner);
```

Next, let's like and recast some of his casts.

```tsx
// Liking one of Vitalik's recent casts
// https://warpcast.com/vitalik.eth/0x3e9b3734
const submitLikeResponse = await client.submitReaction(
  {
    type: 'like',
    target: {
      fid: 5650,
      hash: '0x3e9b3734a29ad341f1c73912c42343a21d5df75a'
    }
  },
  user.farcaster.fid,
  privySigner
);

// Recasting another one of Vitalik's recent casts
// https://warpcast.com/vitalik.eth/0x6be44f32
const submitRecastResponse = await client.submitReaction(
  {
    type: 'recast',
    target: {
      fid: 5650,
      hash: '0x6be44f32011a59e239d5a00bb6302c3105ad3214'
    }
  },
  user.farcaster.fid,
  privySigner
);
```

Awesome! We've already submitted, liked, and recasted a cast + followed a user.

Now, your user wants to shake up their feed, so they are going to unfollow Vitalik.

```tsx
const unfollowUserResponse = await client.unfollowUser(5650, user.farcaster.fid, privySigner);
```

That's it!

Your user has now logged in with Farcaster, authorized a new non-custodial signer, and started writing to the protocol. Wowow!

## Caveats

Some Privy features cannot be used alongside Farcaster embedded signers.

1. A user must always have an embedded wallet to use Farcaster embedded signers. Before calling `requestFarcasterSignerFromWarpcast` be sure to either [manually or automatically](/wallets/wallets/create/from-my-client) create an embedded wallet.
2. **MFA** cannot be enabled when using Farcaster embedded signers.
3. **Passwords** on embedded wallets cannot be added when using Farcaster embedded signers.

## Resources

If you're new to Farcaster, here are some great places to get started:

* [https://docs.farcaster.xyz/](https://docs.farcaster.xyz/)
* [https://www.thehubble.xyz/](https://www.thehubble.xyz/)

Interacting with the Farcaster protocol requires reading existing data. The Farcaster team has a set of open source libraries for reading from hubs directly: [https://github.com/farcasterxyz](https://github.com/farcasterxyz).

Alternatively, you can use data APIs built for Farcaster developers that drastically improve developer and user UX using [Neynar](https://neynar.com/).

## FAQ

<br />

**Q**: *Will my users have to pay Warps?*

**A**: We are sponsoring all signers created so that your users will not have to spend any Warps!

**Q**: *How do I revoke my embedded Farcaster signer?*

**A**: If your account was created on Warpcast, you can go to Settings -> Advanced -> Manage connected apps. Then, delete the key you wish to revoke. Note that this will **delete all messages** posted by that signer. Revoking a signer without Warpcast is a somewhat involved process. Using your custody address (wallet from Warpcast), you can call `remove(mySignerPublicKey)` on the [Farcaster Key Registry](https://optimistic.etherscan.io/address/0x00000000fc1237824fb747abde0ff18990e59b7e) contract to permanently deauthorize an embedded Farcaster signer. [Here is an example](https://optimistic.etherscan.io/tx/0x49f4de7596eced1ac34abd2e78329ba8ff02569156cf4f5919250cca0144e783).

<br />

**Q**: *I really like/dislike 'X'. How do I tell someone?*

**A**: We would love ANY feedback on your experience so far! Please reach out to us on [Warpcast](https://warpcast.com/privy) or [Slack](https://privy.io/slack).


# Integrating Flashbots Protect
Source: https://docs.privy.io/recipes/flashbots-protect



[Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview) is an RPC service that helps protect your users' Ethereum transactions from dangerous frontrunning attacks by submitting transactions to a private mempool that remains hidden from bots. You can also use the service to earn MEV refunds on any MEV realized through backrunning.

To integrate Flashbots Protect with Privy, first configure the [Flashbots RPC URL](https://docs.flashbots.net/flashbots-protect/quick-start) for the chain your app needs:

<Tabs>
  <Tab title="Mainnet">
    ```tsx
    import {mainnet} from 'viem/chains';

    import {addRpcUrlOverrideToChain} from '@privy-io/react-auth';

    // Configure the Flashbots RPC URL for mainnet
    const mainnetWithFlashbotsProtect = addRpcUrlOverrideToChain(
      mainnet,
      'https://rpc.flashbots.net/fast'
    );
    ```
  </Tab>

  <Tab title="Sepolia">
    ```tsx
    import {sepolia} from 'viem/chains';

    import {addRpcUrlOverrideToChain} from '@privy-io/react-auth';

    // Configure the Flashbots RPC URL for sepolia
    const sepoliaWithFlashbotsProtect = addRpcUrlOverrideToChain(
      sepolia,
      'https://rpc-sepolia.flashbots.net/'
    );
    ```
  </Tab>

  <Tab title="Holesky">
    ```tsx
    import {holesky} from 'viem/chains';

    import {addRpcUrlOverrideToChain} from '@privy-io/react-auth';

    // Configure the Flashbots RPC URL for holesky
    const holeskyWithFlashbotsProtect = addRpcUrlOverrideToChain(
      holesky,
      'https://rpc-holesky.flashbots.net/'
    );
    ```
  </Tab>
</Tabs>

Next, pass the chain configured with the Flashbots RPC URL to the `config.supportedChains` property of the `PrivyProvider`:

<Tabs>
  <Tab title="Mainnet">
    ```tsx
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        ...theRestOfYourConfig,
        supportedChains: [mainnetWithFlashbotsProtect, ...otherChains]
      }}
    >
      {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="Sepolia">
    ```tsx
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        ...theRestOfYourConfig,
        supportedChains: [sepoliaWithFlashbotsProtect, ...otherChains]
      }}
    >
      {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="Holesky">
    ```tsx
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        ...theRestOfYourConfig,
        supportedChains: [holeskyWithFlashbotsProtect, ...otherChains]
      }}
    >
      {/* your app's content */}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>

**That's it!** Once you've configured Flashbots Protect as the RPC URL for your desired chain, Privy will route your users' transactions through the private Flashbots mempool.

<Info>
  Flashbots Protect currently only supports Ethereum mainnet, the Ethereum Sepolia testnet, and the
  Ethereum Holesky testnet. The team is actively building support for other networks, including L2s,
  as well.
</Info>


# Hierarchical deterministic (HD) wallets
Source: https://docs.privy.io/recipes/hd-wallets



Privy embedded wallets are **hierarchical deterministic (HD)** wallets. An HD wallet allows you to generate multiple addresses and private keys from a shared source of entropy: the wallet seed (or equivalently, a [BIP-39 mnemonic](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) encoding the seed, known as a seed *phrase*).

In kind, **Privy can be used to provision multiple embedded wallets for a single user.** Read more below to learn how!

<details>
  <summary>Read more about how HD wallets work.</summary>

  HD wallets use a shared source of entropy to derive the wallet seed; this entropy is protected by the Privy cryptosystem.

  Each wallet is generated from the seed and a unique path parameter, which has the format:

  ```
  m / purpose' / coin_type' / account' / change / address_index
  ```

  For Privy's embedded wallets, the path used for the `i`-th wallet is:

  ```
  m/44'/60'/0'/0/i for Ethereum
  m/44'/501'/i/0'  for Solana
  ```

  where `i` is 0-indexed. An HD wallet is said to have an index of `i` if it is derived from the `i`-th path above. You can read more about these derivation paths [here](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).
</details>

<Tabs>
  <Tab title="React">
    ## Creating multiple HD wallets

    To create multiple HD wallets for a user, use the `createWallet` method:

    <Tabs>
      <Tab title="Ethereum">
        ```tsx
        import {useCreateWallet} from '@privy-io/react-auth';

        const {createWallet} = useCreateWallet();
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        import {useSolanaWallets} from '@privy-io/react-auth/solana';

        const {createWallet} = useSolanaWallets();
        ```
      </Tab>
    </Tabs>

    ### Creating the user's first wallet

    If this is the first wallet you are creating for the user (e.g. the 0th index), you may call **`createWallet`** with no parameters:

    ```tsx
    // Creating the first wallet for a user
    await createWallet();
    ```

    ### Creating additional wallets

    There are two approaches to creating additional wallets.

    #### 1. Create an additional wallet with the next available index

    If the user already has an embedded wallet, and you are creating an additional embedded wallet, call `createWallet` with `createAdditional` set to `true`:

    <ParamField path="createAdditional" type="boolean">
      If `true`, will allow the user to create a wallet regardless if it is their first wallet or an
      additional wallet. If `false`, createWallet will succeed *only if the use is creating their first
      wallet.* Defaults to `false`.
    </ParamField>

    Once invoked, **`createWallet`** will return a Promise that resolves to the **`Wallet`** created for the user at the specified index, if it was successful. This method will reject with an error if:

    * the user is not `authenticated`
    * the user already has an embedded wallet and `createAdditional` was not set to `true`
    * if there is another error during wallet creation, such as the user exiting prematurely

    ```tsx
    // Creating additional embedded wallets for the user
    // You can also create the first wallet for the user using this syntax
    await createWallet({createAdditional: true});
    ```

    #### 2. Create an additional wallet with a specified HD wallet index

    To create a wallet at a specified HD wallet index, call `createWallet` with the preferred `walletIndex`.
    This method will either create a new wallet, or return the existing one if one already exists at the specified index.

    <ParamField path="walletIndex" type="number">
      The specified HD wallet index. Must be a positive number, and must be `0` for the user's first
      wallet.
    </ParamField>

    <Info>
      A wallet with HD index 0 must be created before creating a wallet at greater HD indices.
    </Info>

    ```tsx
    // Create an additional embedded wallet at index 5
    await createWallet({walletIndex: 5});
    ```

    An error can be thrown if:

    * the user is not `authenticated`
    * wallet creation fails or the wallet cannot be added to the user's account.
    * an invalid HD wallet index is supplied, i.e. `walletIndex` is less than 0, or if `walletIndex` is greater than 0 while user has no wallet with HD index 0.

    <Tip>
      Since HD wallets use the same underlying wallet seed, the [recovery
      method](/wallets/advanced-topics/new-devices/overview) for the wallet is shared across all of a
      user's embedded wallets.
    </Tip>

    ## Using multiple HD wallets

    ### Getting a specific embedded wallet

    Once a user has one or more embedded wallets, the wallets are added to both [`linkedAccounts`](/user-management/users/the-user-object) array of the **`user`** object and the array of connected wallets returned by [`useWallets`](/wallets/wallets/get-a-wallet/get-connected-wallet).

    To find a specific embedded wallet for the user, search the `useWallets` array for a wallet with `walletClientType: 'privy'` and an `address` that matches your desired address:

    <Tabs>
      <Tab title="Ethereum">
        ```tsx
        // Ensure the wallet address is checksummed per EIP55
        const desiredAddress = 'insert-your-desired-address-in-EIP55-format';
        const {wallets} = useWallets();
        const desiredWallet = wallets.find(
          (wallet) => wallet.walletClientType === 'privy' && wallet.address === desiredAddress
        );
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        const desiredAddress = 'insert-your-desired-address';
        const {wallets} = useSolanaWallets();
        const desiredWallet = wallets.find(
          (wallet) => wallet.walletClientType === 'privy' && wallet.address === desiredAddress
        );
        ```
      </Tab>
    </Tabs>

    You can also get a list of all of the user's embedded wallets by filtering the `useWallets` array for entries with `walletClientType: 'privy'`:

    ```tsx
    const embeddedWallets = wallets.filter((wallet) => wallet.walletClientType === 'privy');
    ```

    ### Requesting signatures and transactions

    Your app can then use Privy's native signature and transaction methods, the wallet's EIP1193 provider, or a third-party library like `viem` or `ethers`, per the instructions below.

    #### Using Privy's native signature and transaction methods

    To use Privy's native `signMessage`, `signTypedData`, and `sendTransaction` methods with a specific embedded wallet, simply pass the address for your desired wallet as the final optional parameter to these methods:

    <Tabs>
      <Tab title="Ethereum">
        #### `signMessage`

        ```tsx
        const {signMessage} = usePrivy();
        const signature = await signMessage(
          {message: 'insert-message-to-sign'},
          {
            uiOptions: insertOptionalUIConfigOrUndefined,
            address: desiredWallet.address // Replace with the address of the desired embedded wallet
          }
        );
        ```

        #### `signTypedData`

        ```tsx
        const {signTypedData} = usePrivy();
        const signature = await signTypedData(insertTypedDataObject, {
          uiOptions: insertOptionalUIConfigOrUndefined,
          address: desiredWallet.address // Replace with the address of the desired embedded wallet
        });
        ```

        #### `sendTransaction`

        ```tsx
        const {sendTransaction} = usePrivy();
        const signature = await sendTransaction(insertTransactionRequest, {
          uiOptions: insertOptionalUIConfigOrUndefined,
          fundingConfig: insertOptionalUIConfigOrUndefined,
          address: desiredWallet.address // Replace with the address of the desired embedded wallet
        });
        ```
      </Tab>

      <Tab title="Solana">
        #### `signMessage`

        ```tsx
        import {useSignMessage} from '@privy-io/react-auth/solana';

        const {signMessage} = useSignMessage();
        const signature = await signMessage(
          {message: new TextEncoder().encode('insert-message-to-sign')},
          {
            uiOptions: insertOptionalUIConfigOrUndefined,
            address: desiredWallet.address // Replace with the address of the desired embedded wallet
          }
        );
        ```

        #### `sendTransaction`

        ```tsx
        import {useSendTransaction} from '@privy-io/react-auth/solana';

        const {sendTransaction} = useSendTransaction();
        const signature = await sendTransaction({
          transaction,
          uiOptions: insertOptionalUIConfigOrUndefined,
          fundWalletConfig: insertOptionalUIConfigOrUndefined,
          address: desiredWallet.address // Replace with the address of the desired embedded wallet
        });
        ```
      </Tab>
    </Tabs>

    #### Using the EIP1193 provider, viem, and ethers (EVM only)

    You can also request signatures and transactions from a specific embedded wallet using the wallet's [EIP1193 provider](/wallets/using-wallets/ethereum/web3-integrations) or a library like `viem` or `ethers`.

    To get the EIP1193 provider for a specific embedded wallet, first find the corresponding `ConnectedWallet` object from the `useWallets` array:

    ```tsx
    // Ensure the wallet address is checksummed per EIP55
    const address = 'insert-your-desired-address-in-EIP55-format';
    const {wallets} = useWallets();
    const wallet = wallets.find(
      (wallet) => wallet.walletClientType === 'privy' && wallet.address === address
    );
    ```

    Then, call the object's `getEthereumProvider` method to get an EIP1193 provider for that wallet:

    ```tsx
    const provider = await wallet.getEthereumProvider();
    ```

    You can then easily pass that EIP1193 provider to a library like [`viem`](/wallets/using-wallets/ethereum/web3-integrations#viem) or [`ethers`](/wallets/using-wallets/ethereum/web3-integrations#ethers) to use those libraries' interfaces to send requests to the wallet.

    ## Exporting HD wallets

    To export the private key or seed phrase for a specific HD wallet, simply pass the address of the wallet you'd like to export as an `address` parameter to the `exportWallet` method:

    <Tabs>
      <Tab title="Ethereum">
        ```tsx
        const {exportWallet} = usePrivy();
        await exportWallet({address: 'insert-your-desired-address'});
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        const {exportWallet} = useSolanaWallets();
        await exportWallet({address: 'insert-your-desired-address'});
        ```
      </Tab>
    </Tabs>

    If no `address` is passed to `exportWallet`, Privy will default to exporting the non-imported wallet at `walletIndex: 0`.

    ## Pregenerating multiple HD wallets (EVM only)

    Privy supports pregenerating multiple HD wallets in Ethereum when creating new users. With our user import endpoint, you can create a user with up to 10 pregenerated HD wallets. Simply call the import endpoint with `create_n_ethereum_wallets` set to the number of embedded wallets you want to generate for your user.

    <Info>
      Pregeneration endpoints have heavier rate limit of 240 users per minute. If you are being rate
      limited, responses will have status code 429. We suggest you setup exponential back-offs starting
      at 1 second to seamlessly recover.
    </Info>

    Below is a sample cURL command for pregenerating two new wallets for a user with Privy:

    ```bash
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    -d '{
      "create_n_ethereum_wallets": 2,
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email"
        }
      ]
    }'
    ```

    A successful response will include the new user object along with their Privy user ID and embedded wallet addresses, like below. The generated wallets will be available to the user upon sign in.

    Below is a sample successful response for generating two new wallets for a user with Privy:

    ```json
    {
      "id": "did:privy:clddy332f002tyqpq3b3lv327",
      "created_at": 1674788927,
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email"
        },
        {
          "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
          "type": "wallet",
          "wallet_index": 0,
          "walletClient": "privy",
          "chain_type": "ethereum"
        },
        {
          "address": "0x1a235d54C58d0B5E339c784Fd98d4D71125fEb1c",
          "type": "wallet",
          "wallet_index": 1,
          "walletClient": "privy",
          "chain_type": "ethereum"
        }
      ]
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Ethereum">
        ## Creating multiple HD wallets

        To create multiple Ethereum wallets for a user, use the `create` method from the `useEmbeddedEthereumWallet` hook:

        ```tsx
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';

        const {create} = useEmbeddedEthereumWallet();
        ```

        As a parameter to `create`, pass an object containing a `createAdditional` boolean specifying if you would like to create an additional wallet, even if the user has an existing one.

        <ParamField path="createAdditional" type="boolean">
          If `true`, will allow the user to create a Ethereum wallet regardless if it is their first wallet
          or an additional wallet. If `false`, createWallet will succeed *only if the use is creating their
          first wallet.* Defaults to `false`.
        </ParamField>

        Once invoked, **`create`** will return a Promise that resolves to the newly created [wallet](/wallets/wallets/get-a-wallet/get-connected-wallet), if it was successful. This method will reject with an error if:

        * the user is not `authenticated`.
        * the user already has an embedded Ethereum wallet and `createAdditional` was not set to `true`.
        * if there is another error during wallet creation, such as the user exiting prematurely.

        ```tsx
        // Creating additional embedded wallets for the user
        // You can also create the first wallet for the user using this syntax
        await create({createAdditional: true});
        ```

        ## Using multiple HD wallets

        Once a user has one or more embedded wallets, the wallets are added to the `wallets` array returned by `useEmbeddedEthereumWallet`:

        ```tsx
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';
        ...
        const {wallets} = useEmbeddedEthereumWallet();
        ```

        Refer to the [requests section](/wallets/wallets/get-a-wallet/get-connected-wallet) to learn how to interact with the wallets you create.

        ### Getting a specific embedded wallet

        To find a specific embedded wallet for the user, search the `wallets` array for a wallet with the `address` that matches your desired address:

        ```tsx
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedEthereumWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        You can alternatively search the wallets array by your desired HD index:

        ```tsx
        // Replace this with your desired HD index
        const desiredHdIndex = 0;
        const {wallets} = useEmbeddedEthereumWallet();
        const desiredWallet = wallets.find((wallet) => wallet.walletIndex === desiredHdIndex);
        ```
      </Tab>

      <Tab title="Solana">
        ## Creating multiple HD wallets

        To create multiple Solana wallets for a user, use the `create` method from the `useEmbeddedSolanaWallet` hook:

        ```tsx
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        ...
        const {create} = useEmbeddedSolanaWallet();
        ```

        As an optional parameter to `create`, you may pass an object containing the following fields:

        <ParamField path="createAdditional" type="boolean">
          If `true`, will allow the user to create a Solana wallet regardless if it is their first wallet or
          an additional wallet. If `false`, createWallet will succeed *only if the use is creating their
          first wallet.* Defaults to `false`.
        </ParamField>

        Once invoked, **`create`** will return a Promise that resolves to the [provider](/wallets/wallets/get-a-wallet/get-connected-wallet) for the wallet created for the user, if it was successful. This method will reject with an error if:

        * the user is not `authenticated`
        * the user already has an embedded Solana wallet and `createAdditional` was not set to `true`
        * if there is another error during wallet creation, such as the user exiting prematurely

        ### Creating the user's first wallet

        If this is the first wallet you are creating for the user (e.g. the 0th index), you may call **`create`** with no parameters:

        ```tsx
        // Creating the first wallet for a user
        const provider = await create();
        ```

        ### Creating additional wallets

        If the user already has an embedded wallet, and you are creating an additional embedded wallet, **you must call `create` with `createAdditional` set to `true`**:

        ```tsx
        // Creating additional embedded wallets for the user
        // You can also create the first wallet for the user using this syntax
        const provider = await create({createAdditional: true});
        ```

        ## Using multiple HD wallets

        Once a user has one or more embedded wallets, the wallets are added to the `wallets` array returned by `useEmbeddedSolanaWallet`:

        ```tsx
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        ...
        const {wallets} = useEmbeddedSolanaWallet();
        ```

        Each entry in the `wallets` array is an object with the following fields:

        <ParamField path="address" type="string">
          The address (base58-encoded public key) for the wallet.
        </ParamField>

        <ParamField path="publicKey" type="string">
          The address (base58-encoded public key) for the wallet.
        </ParamField>

        <ParamField path="walletIndex" type="number">
          The HD index for the wallet.
        </ParamField>

        <ParamField path="getProvider" type="() => Promise<PrivyEmbeddedSolanaWalletProvider>">
          Method to get a [provider](/wallets/wallets/get-a-wallet/get-connected-wallet) for the wallet for
          requesting signatures and transactions.
        </ParamField>

        ### Getting a specific embedded wallet

        To find a specific embedded wallet for the user, search the `wallets` array for a wallet with the `address` that matches your desired address:

        ```tsx
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedSolanaWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        You can alternatively search the wallets array by your desired HD index:

        ```tsx
        // Replace this with your desired HD index
        const desiredHdIndex = 0;
        const {wallets} = useEmbeddedSolanaWallet();
        const desiredWallet = wallets.find((wallet) => wallet.walletIndex === desiredHdIndex);
        ```

        ### Requesting signatures and transactions

        To request a signature or transaction from a specific embedded wallet, first find the corresponding wallet object from the `wallets` array:

        ```tsx
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedSolanaWallet();
        const wallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        Then, call the object's `getProvider` method to get a [provider](/wallets/wallets/get-a-wallet/get-connected-wallet) for the wallet:

        ```tsx
        const provider = await wallet.getProvider();
        ```

        You can then easily request signatures from the [`provider`](/wallets/wallets/get-a-wallet/get-connected-wallet) using its [`request`](/wallets/using-wallets/solana/sign-a-message) method, like so:

        ```tsx
        const message = 'Hello world';
        const {signature} = await provider.request({
          method: 'signMessage',
          params: {
            message: message
          }
        });
        ```
      </Tab>

      <Tab title="Bitcoin">
        ## Creating multiple HD wallets

        To create multiple Bitcoin wallets for a user, use the `create` method from the `useEmbeddedBitcoinWallet` hook:

        ```tsx
        import {useEmbeddedBitcoinWallet} from '@privy-io/expo';

        const {create} = useEmbeddedBitcoinWallet();
        ```

        As a parameter to `create`, pass an object containing a `chainType` field specifying the type of wallet to create and a `createAdditional` boolean specifying if you would like to create an additional wallet of that `chainType`, even if the user has an existing wallet of that `chainType`.

        <ParamField path="chainType" type="'bitcoin-taproot' | 'bitcoin-segtwit'">
          The type of Bitcoin wallet to create.
        </ParamField>

        <ParamField path="createAdditional" type="boolean">
          If `true`, will allow the user to create a Bitcoin wallet regardless if it is their first Bitcoin
          wallet or an additional Bitcoin wallet. If `false`, createWallet will succeed *only if the user is
          creating their first wallet.* Defaults to `false`.
        </ParamField>

        Once invoked, **`create`** will return a Promise that resolves to the newly created [wallet](/wallets/wallets/get-a-wallet/get-connected-wallet), if it was successful. This method will reject with an error if:

        * the user is not `authenticated`
        * the user already has an embedded Bitcoin wallet of the provided `chainType` and `createAdditional` was not set to `true`
        * if there is another error during wallet creation, such as the user exiting prematurely

        ### Creating additional wallets

        If the user already has an embedded wallet, and you are creating an additional embedded wallet, **you must call `create` with `createAdditional` set to `true`**:

        ```tsx
        // Creating additional embedded wallets for the user
        // You can also create the first wallet for the user using this syntax
        const provider = await create({createAdditional: true});
        ```

        ## Using multiple HD wallets

        Once a user has one or more embedded wallets, the wallets are added to the `wallets` array returned by `useEmbeddedBitcoinWallet`:

        ```tsx
        import {useEmbeddedBitcoinWallet} from '@privy-io/expo';
        ...
        const {wallets} = useEmbeddedBitcoinWallet();
        ```

        Refer to the [usage section](/wallets/using-wallets/solana/sign-a-message) to learn how to interact with the wallets you create.

        ### Getting a specific embedded wallet

        To find a specific embedded wallet for the user, search the `wallets` array for a wallet with the `address` that matches your desired address:

        ```tsx
        const desiredAddress = 'insert-your-desired-wallet-address';
        const {wallets} = useEmbeddedBitcoinWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        You can alternatively search the wallets array by your desired HD index:

        ```tsx
        // Replace this with your desired HD index
        const desiredHdIndex = 0;
        const {wallets} = useEmbeddedBitcoinWallet();
        const desiredWallet = wallets.find(
          (wallet) => wallet.chainType === 'bitcoin-taproot' && wallet.walletIndex === desiredHdIndex
        );
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Login with Lens
Source: https://docs.privy.io/recipes/lens



[Lens Protocol](https://www.lens.xyz/docs/) is an open social network that allows users to own their content and connections. Developers can build on the network, leveraging its audience and infrastructure. Users can seamlessly switch between social apps without losing their profiles, content, or connections.

Allowing users to log into Lens with Privy is fully supported and simple to integrate.

In this recipe, we'll show you how to integrate your Privy integration with the Lens SDK to easily read from Lens and mint a Lens profile using an embedded or external wallet connected with Privy. Here's how!

<Tip>
  Building a new app? Check out the [Lens API
  Examples](https://github.com/lens-protocol/lens-sdk/tree/develop/examples), which includes [a
  basic Lens x Privy
  integration](https://github.com/lens-protocol/lens-sdk/tree/develop/examples/lens-next-privy-app).
</Tip>

### 0. Prerequisite

In order to integrate the Privy React SDK with the Lens React SDK, your project must be on:

* the latest version of [@privy-io/react-auth](https://www.npmjs.com/package/@privy-io/react-auth)
* a minimum Lens React SDK version of `2.0.0`

We also assume you have set up the [Lens SDK](https://github.com/lens-protocol/lens-sdk) with your app. If you haven't, start by following the instructions in the [Lens Quickstart](https://www.lens.xyz/docs/getting-started/react-web) guide to get your app set up.

### 1. Installation

Install the [@privy-io/react-auth](https://www.npmjs.com/package/@privy-io/react-auth) SDK and [@privy-io/wagmi](https://www.npmjs.com/package/@privy-io/wagmi) (Privy's [wagmi](https://wagmi.sh/) bindings):

```sh
npm install @privy-io/react-auth@latest @privy-io/wagmi
```

When your app integrates Privy alongside Wagmi, you should:

* use Privy to connect external wallets and create embedded wallets
* use wagmi to take read or write actions from a connected wallet

More details on using Privy with Wagmi is available [here](/wallets/connectors/ethereum/integrations/wagmi).

### 2. Configure the Privy Provider

If following the Lens Quickstart, your existing Provider setup should look similar to this:

```tsx
<WagmiProvider config={wagmiConfig}>
  <QueryClientProvider client={queryClient}>
    <LensProvider config={lensConfig}>{/** Your App */}</LensProvider>
  </QueryClientProvider>
</WagmiProvider>
```

In the Lens example the `WagmiProvider` and `Config` creation function are provided by `wagmi`. However, when integrating with Privy, the `@privy-io/wagmi` package should be used instead.

Change the import statements from:

```tsx
import {WagmiProvider, createConfig, http} from 'wagmi';
```

to

```tsx
import {http} from 'wagmi';

import {WagmiProvider, createConfig} from '@privy-io/wagmi';
```

Lens Protocol runs on Polygon, so the Privy Client configuration must include `polygon` as a supported chain. Your config should look something like:

```tsx
const privyConfig: PrivyClientConfig = {
  defaultChain: polygon,
  supportedChains: [polygon],
  embeddedWallets: {
    createOnLogin: 'users-without-wallets'
  }
};
```

**Note:** `PrivyProvider` requires that the `QueryClientProvider` wraps the `WagmiProvider`.

Next, simply wrap the existing Providers with the `PrivyProvider`:

```tsx
<PrivyProvider appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID!} config={privyConfig}>
  <QueryClientProvider client={queryClient}>
    <WagmiProvider config={wagmiConfig}>
      <LensProvider config={lensConfig}>{children}</LensProvider>
    </WagmiProvider>
  </QueryClientProvider>
</PrivyProvider>
```

Here's an example of the full `PrivyProvider` setup with the Lens SDK:

```tsx
import {LensConfig, LensProvider, development} from '@lens-protocol/react-web';
import {bindings} from '@lens-protocol/wagmi';
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
import React from 'react';
import {http} from 'wagmi';
import {polygon, polygonAmoy} from 'wagmi/chains';

import {PrivyClientConfig, PrivyProvider} from '@privy-io/react-auth';
import {WagmiProvider, createConfig} from '@privy-io/wagmi';

const wagmiConfig = createConfig({
  chains: [polygon, polygonAmoy],
  transports: {
    [polygon.id]: http(),
    [polygonAmoy.id]: http()
  }
});

const privyConfig: PrivyClientConfig = {
  defaultChain: polygonAmoy, // or polygon
  supportedChains: [polygon, polygonAmoy],
  embeddedWallets: {
    createOnLogin: 'users-without-wallets'
  }
};

const queryClient = new QueryClient();

const lensConfig: LensConfig = {
  environment: development, // or production
  bindings: bindings(wagmiConfig),
  debug: true
};

export function Web3Provider({children}: {children: React.ReactNode}) {
  return (
    <PrivyProvider appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID!} config={privyConfig}>
      <QueryClientProvider client={queryClient}>
        <WagmiProvider config={wagmiConfig}>
          <LensProvider config={lensConfig}>{children}</LensProvider>
        </WagmiProvider>
      </QueryClientProvider>
    </PrivyProvider>
  );
}
```

### 3. Login with Privy

That's it! Your app is now fully setup to interact with the Lens SDK using Privy. To start interacting with Lens, we must first connect a wallet with Privy.

```tsx
import {usePrivy} from '@privy-io/react-auth';

const {connectOrCreateWallet} = usePrivy();

<button onClick={connectOrCreateWallet}>Connect wallet</button>;
```

<Tip>
  If a user does not have an a wallet, an embedded wallet will be generated for them after logging
  in with Privy. This behavior is completely configurable to match the desired functionality for
  your app.
</Tip>

Once a wallet is connected, you can access the most recently connected wallet at the first element in the wallets array.

```tsx
import {useWallets} from '@privy-io/react-auth';

const {wallets} = useWallets();

const walletAddress = wallets[0].address;
```

### 4. Interact with Lens

Now, that we have a wallet connected and ready to use, let's retrieve the list of Profiles that the it currently owns or manages. This can be accomplished using the `useProfilesManaged` hook from the Lens SDK:

```tsx
import {useProfilesManaged, Profile} from '@lens-protocol/react-web';

const {data: profiles} = useProfilesManaged({
  for: walletAddress,
  includeOwned: true
});
```

Next, use the `useLogin` hook from the Lens SDK to log in with one of the profiles returned:

```tsx
import {useLogin} from '@lens-protocol/react-web';

const {execute: loginWithLensAPI} = useLogin();
const result = await loginWithLensAPI({
  address: walletAddress,
  profileId: profiles[0].id
});

if (result.isSuccess()) {
  // You can now interact with the Lens SDK hooks that require a logged in user
}
```

### 5. Further

Check out the [Lens SDK Privy example](https://github.com/lens-protocol/lens-sdk/tree/develop/examples/lens-next-privy-app), which includes profile creation and login using the setup from this guide. You can now use the Lens SDK to:

* [log your users in to the Lens API](https://www.lens.xyz/docs/primitives/authentication#profile-login)
* [create a Lens Profile](https://www.lens.xyz/docs/best-practices/onboarding#crypto-onboarding)
* [update Lens Profile metadata](https://www.lens.xyz/docs/primitives/profile/metadata#update-profile-metadata)
* [create a post](https://www.lens.xyz/docs/primitives/publications/content-creation#creating-a-post)
* [make a post collectable](https://www.lens.xyz/docs/primitives/collect/collectables#collect-actions-simple-collect)
* [react to (like) a publication](https://www.lens.xyz/docs/primitives/publications/reactions#react-to-publication)

and so much more! Examples from the [Lens Docs](https://www.lens.xyz/docs/) can be used without any modification.


# Mocking tokens for testing
Source: https://docs.privy.io/recipes/mock-jwt



If your project uses automated testing (e.g. with [Jest](https://jestjs.io/docs/configuration)), your test setup may need access to a Privy token in order to mock out an authenticated session, authorized API calls, and more.

To obtain a Privy token for tests, we **do not recommend** using an actual auth token issued by Privy's production service. Rather, you should construct a test JWT in the [Privy format](/authentication/user-authentication/access-tokens) and then sign it with a key that you control.

### Overview

At a high-level, the instructions for creating and signing a JWT in the Privy format are:

1. **Generate your signing & verification keys for tests.** Privy uses an asymmetric [ECDSA P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) keypair, but you can choose any key setup you like.
2. **Construct a JWT with the Privy claims.** For tests, you can use any arbitrary Privy DID for the `sub` claim and any arbitrary session ID for the `sid` claim.
3. **Sign your JWT with your signing key.** Privy uses the [ES256 algorithm](https://ldapwiki.com/wiki/ES256) to sign & verify JWTs for your app, but you can choose any signing algorithm you like, as long as it is compatible with your key setup from Step 1.

Below is a reference implementation in JavaScript for generating keys, signing JWTs in the Privy format, and verifying those JWTs using the library [`jose`](https://www.npmjs.com/package/jose).

### Generating signing & verification keys for tests

Generate a keypair using `jose`'s [`generateKeyPair`](https://github.com/panva/jose/blob/HEAD/docs/functions/key_generate_key_pair.generateKeyPair.md#readme) method, specifying the 'ES256' algorithm as a parameter.

```typescript
const {publicKey, privateKey} = await jose.generateKeyPair('ES256');
```

You can now use the `privateKey` to sign JWTs and the `publicKey` to verify JWTs in your tests.

### Creating and signing test JWTs

First, define the values you will use to populate your test JWT's claims.

```typescript
const session = /* an arbitrary session ID */
const subject = /* an arbitrary Privy DID */
const issuer = 'privy.io';
const audience = /* your Privy app ID */
const expiration = '1h';
```

Next, create and sign your test JWT with your test [`privateKey`](./mock-jwt.md#generating-signing--verification-keys-for-tests) using `jose`'s [`SignJWT`](https://github.com/panva/jose/blob/9a918a88c5fded3b17bcf356dd58fafefb34a4d0/docs/classes/jwt_sign.SignJWT.md) class.

{/* spellchecker:off */}

```typescript
const authToken = await new jose.SignJWT({sid: session})
  .setProtectedHeader({alg: 'ES256', typ: 'JWT'})
  .setIssuer(issuer)
  .setIssuedAt()
  .setAudience(audience)
  .setSubject(subject)
  .setExpirationTime(expiration)
  .sign(privateKey);
```

{/* spellchecker:on */}

### Verifying test JWTs

Use `jose`'s [`jwtVerify`](https://github.com/panva/jose/blob/9a918a88c5fded3b17bcf356dd58fafefb34a4d0/docs/functions/jwt_verify.jwtVerify.md) method to verify your test JWT against your test [`publicKey`](./mock-jwt.md#generating-signing--verification-keys-for-tests)

```typescript
try {
	const payload = await jose.jwtVerify(authToken, verificationKey, {
		issuer: 'privy.io',
		audience: /* your Privy App ID */
	});
	console.log(payload);
} catch (error) {
	console.log(`JWT failed to verify with error ${error}.`);
}
```


# Integrating OneBalance
Source: https://docs.privy.io/recipes/one-balance



[OneBalance](https://docs.onebalance.io/) is a framework for setting up [Credible Accounts](https://docs.onebalance.io/technical-details/onebalance-accounts) for users, that allow them to use their balance on any EVM chain for transactions on any other EVM chain. This allows your app to abstract away the concept of "chains" for end users, and makes it significantly simpler to use balances across multiple EVM chains without the UX friction of explicitly bridging between them.

You can easily [integrate OneBalance with Privy](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance) to abstract users' embedded wallet balances across the various chains that your app might support.

Get started with the steps below, or check out [the sample app](https://github.com/OneBalance-io/integration-examples/blob/main/privy/src/features/quote/sign-quote.ts) for a full walkthrough!

## 1. Set up OneBalance accounts for users

To start, create OneBalance accounts for your users and deposit any user assets to the account to set it up for executing transactions.

Follow the guide [here](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance/step-2-setting-configurations) to create your OneBalance API key and instantiate your users' accounts and deposit their assets to it.

You can also use your OneBalance API key to fetch an aggregated balance across all the chains your app supports.

## 2. Fetch a quote for a transaction

When executing a transaction, first fetch a quote from the OneBalance API for the transaction per this [guide](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance/step-5-fetch-a-quote-for-transaction-execution).

OneBalance supports swaps, transfers, and arbitrary calldata execution, supporting any transaction use case that your app might have.

## 3. Sign the transaction with the embedded wallet

Lastly, after fetching a quote for the transaction, sign the transaction using the user's embedded wallet by requesting an [EIP-712](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md) typed data signature, like so:

```tsx
// below interface corresponds to ChainOperationSwaggerDto on OneBalance Swagger documentation
import {ChainOperation} from '<your path to OneBalance interfaces>';
// below interface corresponds to QuoteSwaggerDto on OneBalance Swagger documentation
import {Quote} from '<your path to OneBalance interfaces>';
import {Address, createWalletClient, custom, Hash} from 'viem';

import {ConnectedWallet} from '@privy-io/react-auth';

const signTypedDataWithPrivy =
  (embeddedWallet: ConnectedWallet) =>
  async (typedData: any): Promise<Hash> => {
    const provider = await embeddedWallet.getEthereumProvider();
    const walletClient = createWalletClient({
      transport: custom(provider),
      account: embeddedWallet.address as Address
    });

    return walletClient.signTypedData(typedData);
  };

const signOperation =
  (embeddedWallet: ConnectedWallet) =>
  async (operation: ChainOperation): Promise<ChainOperation> => {
    const signature = await signTypedDataWithPrivy(embeddedWallet)(operation.typedDataToSign);

    return {
      ...operation,
      userOp: {...operation.userOp, signature}
    };
  };

export const signQuote = async (quote: Quote, embeddedWallet: ConnectedWallet) => {
  const signWithEmbeddedWallet = signOperation(embeddedWallet);

  const signedQuote = {
    ...quote
  };

  signedQuote.originChainsOperations = await Promise.all(
    quote.originChainsOperations.map(signWithEmbeddedWallet)
  );
  if (quote.destinationChainOperation) {
    signedQuote.destinationChainOperation = await signWithEmbeddedWallet(
      quote.destinationChainOperation
    );
  }
  return signedQuote;
};
```

Once you have successfully signed the transaction, you can [execute the transaction with the OneBalance API](https://docs.onebalance.io/chain-abstraction-suite/getting-started-guide-for-privy-less-than-greater-than-onebalance/step-7-executing-transactions) and track its execution status.

**That's it! Your users can now transact on any chain with a unified balance!**


# null
Source: https://docs.privy.io/recipes/overview



<div className="recipes">
  <div className="text-center">
    <h1>Recipes</h1>

    <p className="text-center">
      Learn how to implement common Privy features and integrations in your app.
    </p>
  </div>

  <div id="recipes-search" className="search" onClick={() => initRecipesSearch()}>
    <span>Search recipes</span>

    <Icon icon="magnifying-glass" iconType="solid" size={14} />
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">Popular</h2>

    <CardGroup cols={2}>
      <Card title="Test accounts" icon="keyboard" href="/recipes/using-test-accounts" horizontal>
        Enable test accounts for your app.
      </Card>

      <Card title="Optimize your setup" icon="lightbulb" href="/recipes/dashboard/optimizing" horizontal>
        Best tips and tricks to optimize your setup.
      </Card>
    </CardGroup>
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">Funding</h2>

    <CardGroup cols={2}>
      <Card title="Card-based funding" icon="credit-card" href="/recipes/card-based-funding" horizontal>
        Easily fund wallets with credit card, Apple Pay, and Google Pay.
      </Card>

      <Card title="OneBalance" icon="money-bill" href="/recipes/one-balance" horizontal>
        Use OneBalance to abstract away chains and tokens for users.
      </Card>
    </CardGroup>
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">Social</h2>

    <CardGroup cols={2}>
      <Card title="Frames" icon="image" href="/recipes/farcaster/frames" horizontal>
        Build a Farcaster frame with Privy.
      </Card>

      <Card title="Writes" icon="comment" href="/recipes/farcaster/writes" horizontal>
        Use embedded Farcaster signers to cast to Farcaster.
      </Card>

      <Card title="Telegram login" icon="paper-plane" href="/recipes/dashboard/telegram" horizontal>
        Configure settings for Telegram login.
      </Card>

      <Card title="Seamless Telegram login" icon="paper-plane" href="/recipes/react/seamless-telegram" horizontal>
        Integrate Seamless Telegram login and linking.
      </Card>

      <Card title="Lens" icon="eye" href="/recipes/lens" horizontal>
        Integrate Lens as a login method for your app
      </Card>

      <Card title="Telegram trading bot guide" icon="paper-plane" href="/recipes/telegram-trading-guide" horizontal>
        Build a Telegram trading bot
      </Card>
    </CardGroup>
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">Security</h2>

    <CardGroup cols={2}>
      <Card title="Allowed domains" icon="square-check" href="/recipes/react/allowed-domains" horizontal>
        Enforce allowed domains for your Privy app ID.
      </Card>

      <Card title="Cookies" icon="rectangle-list" href="/recipes/react/cookies" horizontal>
        Set up your app with `HttpOnly` cookies for additional security.
      </Card>

      <Card title="Allowed OAuth redirects" icon="compass" href="/recipes/react/allowed-oauth-redirects" horizontal>
        Configure allowed redirect URLs for OAuth login flows.
      </Card>
    </CardGroup>
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">UI customization</h2>

    <CardGroup cols={2}>
      <Card title="Brand settings" icon="circle-info" href="/recipes/dashboard/customization" horizontal>
        Customize brand settings.
      </Card>

      <Card title="System theme" icon="circle-info" href="/recipes/system-theme" horizontal>
        Configure your Privy modal to automatically match users' system themes.
      </Card>
    </CardGroup>
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">Advanced user management</h2>

    <CardGroup cols={2}>
      <Card title="SMS login" icon="message" href="/recipes/dashboard/login-methods/sms" horizontal>
        Configure settings for SMS login.
      </Card>

      <Card title="Cloud recovery" icon="user" href="/wallets/advanced-topics/new-devices/cloud-recovery" horizontal>
        Set up cloud-based recovery for your wallets.
      </Card>

      <Card title="Native Apple login" icon="user" href="/recipes/swift/apple" horizontal>
        Integrate Native Apple login in your Swift app.
      </Card>

      <Card title="Account transfer" icon="circle-right" href="/recipes/dashboard/account-transfer" horizontal>
        Enable account transfer for your users.
      </Card>
    </CardGroup>
  </div>

  <div className="card-group-wrapper">
    <h2 className="font-semibold text-lg pb-2">Miscellaneous</h2>

    <CardGroup cols={2}>
      <Card title="Mock JWT" icon="file-code" href="/recipes/mock-jwt" horizontal>
        Mock out the Privy JWT for use in unit tests and more.
      </Card>

      <Card title="EIP-7702" icon="robot" href="/recipes/react/eip-7702" horizontal>
        Use EIP-7702 features with Privy embedded wallets.
      </Card>

      <Card title="tRPC" icon="file-code" href="/recipes/trpc" horizontal>
        Integrate Privy with the tRPC framework.
      </Card>

      <Card title="Flashbots Protect" icon="eye" href="/recipes/flashbots-protect" horizontal>
        Integrate Flashbots Protect for private transaction submission.
      </Card>

      <Card title="Custom smart wallet implementation" icon="eye" href="/recipes/account-abstraction/custom-implementation" horizontal>
        Build your own smart wallet implementation
      </Card>

      <Card title="Deeplinking Solana wallets in React Native applications" icon="ghost" href="/recipes/react-native/deeplinking-wallets" horizontal>
        Deeplink Solana wallets into your mobile app
      </Card>

      <Card title="Using passkeys with server wallets" icon="key" href="/recipes/passkey-server-wallets" horizontal>
        Implement passkey-controlled server wallets for your users
      </Card>
    </CardGroup>
  </div>
</div>


# Using passkeys with server wallets
Source: https://docs.privy.io/recipes/passkey-server-wallets



Passkeys provide a secure way to authorize actions on Privy server wallets. This guide shows how to integrate your existing passkey implementation as an authorization mechanism for Privy server wallets, combining modern authentication with powerful onchain actions.

## Overview

Authorization keys provide a way to ensure that actions taken by your app's wallets can only be authorized by an explicit user request. When you specify an `owner` of a resource, all requests to update that resource **must be signed** with this key. This security measure verifies that each request comes from your authorized passkey owner and helps prevent unauthorized operations.

## Setting up passkeys

If you need a passkey implementation set up for your application, we recommend using the WebAuthn standard, which provides phishing-resistant, passwordless authentication.

<Accordion title="Sample passkey registration flow (if needed)">
  If you have not already done so, install the dependencies necessary for a simple passkey integration.
  `sh npm install @simplewebauthn/server @simplewebauthn/browser `

  ```typescript
  // Server-side registration endpoint
  app.post('/api/register-passkey/begin', async (req, res) => {
    const userId = req.body.userId;

    // Generate registration options
    const options = await generateRegistrationOptions({
      rpName: 'Your App Name',
      rpID: 'yourdomain.com',
      userID: userId
      // Additional options...
    });

    // Store options temporarily
    await storeRegistrationOptions(userId, options);

    return res.json(options);
  });

  // Client-side registration
  async function registerPasskey() {
    // Get registration options from your server
    const options = await fetchRegistrationOptions();

    // Start the registration process in the browser
    const attestation = await startRegistration(options);

    // Send the response to your server for verification
    const verification = await verifyRegistration(attestation);

    return verification;
  }
  ```
</Accordion>

## Creating and registering server wallets with passkey authorization

Follow these steps to create a server wallet and register it with a user's passkey for authorization.

1. Retrieve the user's passkey P-256 public key and send it to your backend.

2. From your backend, call the Privy API to create a wallet with that P-256 public key as the owner. You can do this via the Privy SDK (below) or by hitting the [Privy API](/api-reference/wallets/create) directly.

```typescript
const passkeyP256PublicKey = 'your-p256-public-key';

const privy = new PrivyClient('your-app-id', 'your-app-secret');

const wallet = await privyClient.wallets.create({
  owner: {
    publicKey: passkeyP256PublicKey
  }
});
```

3. Associate the returned wallet ID with the user on your backend for use in future requests.

## Sending transactions with passkey authorization

Below are the steps necessary to create a transaction request, have the user sign it with their passkey, and submit the signed request to Privy:

1. On your client, create you [desired transaction request body](/api-reference/wallets/ethereum/eth-send-transaction).

2. Format the request body [in preparation for signing](/api-reference/authorization-signatures). You can do this manually or using the Privy SDK (below).

```typescript
import {formatRequestForAuthorizationSignature} from '@privy-io/server-auth/wallet-api';

const input: WalletApiRequestSignatureInput = ...;
const serializedPayload = formatRequestForAuthorizationSignature(input);
```

3. Sign the formatted transaction request with the user's passkey.

4. Send the signature and transaction request to your backend.

5. Send the transaction request with the signature to [the Privy API](/api-reference/wallets/ethereum/eth-send-transaction).
   * Set the [`privy-authorization-signature` header](/api-reference/authorization-signatures#required-headers) to the signature you created in step 3.
   * Set the request body as the transaction request you created in step 1.

**That's it! Whenever a user registers a passkey for your app, they will then have access to a provisioned server wallet for secure and flexible transaction signing and sending.** 🎉


# Deeplinking Solana wallets in React Native applications
Source: https://docs.privy.io/recipes/react-native/deeplinking-wallets



If your Expo mobile app uses Privy, you can implement wallet deeplinking to allow your users to connect their existing mobile wallets (like Phantom) with a seamless experience. This guide will walk you through the steps to set up wallet deeplinking in your Privy Expo app.

## 0. Setup

This guide assumes that you have already integrated Privy into your React native app. If you have not yet set up the basic integration, please first follow the [Privy quickstart](/basics/react-native/quickstart).

## 1. Install required packages

First, make sure you have the necessary dependencies:

```bash
npm install @privy-io/expo @privy-io/expo/connectors
```

## 2. Import the wallet connector hooks

Import the wallet connector hooks in your component:

```tsx
import {
  useDeeplinkWalletConnector,
  usePhantomDeeplinkWalletConnector,
  useBackpackDeeplinkWalletConnector
} from '@privy-io/expo/connectors';
```

Privy Expo provides several hooks for wallet deeplinking:

| Hook                                 | Description                                                                       |
| ------------------------------------ | --------------------------------------------------------------------------------- |
| `useDeeplinkWalletConnector`         | A generic wallet deeplinking connector that you can configure for various wallets |
| `usePhantomDeeplinkWalletConnector`  | A pre-configured connector specifically for Phantom wallet                        |
| `useBackpackDeeplinkWalletConnector` | A pre-configured connector specifically for Backpack wallet                       |

## 3. Set up the wallet connector

<Tabs>
  <Tab title="Phantom">
    To set up the Phantom wallet connector, use the `usePhantomDeeplinkWalletConnector` hook in your component:

    ```tsx
    export default function LoginScreen() {
      const {
        address,
        connect,
        disconnect,
        isConnected,
        signMessage,
        signTransaction,
        signAllTransactions,
        signAndSendTransaction
      } = usePhantomDeeplinkWalletConnector({
        appUrl: 'https://yourdapp.com',
        redirectUri: '/sign-in'
      });

      // Your component code here
    }
    ```

    ### Configuration options

    The `usePhantomDeeplinkWalletConnector` hook accepts the following configuration:

    | Parameter     | Type     | Description                                                                                                |
    | ------------- | -------- | ---------------------------------------------------------------------------------------------------------- |
    | `appUrl`      | `string` | The URL of your app that will be displayed in the wallet app as the requesting dapp, for metadata purposes |
    | `redirectUri` | `string` | The path in your app that the wallet should redirect to after completing an action                         |
  </Tab>

  <Tab title="Backpack">
    To set up the Backpack wallet connector, use the `useBackpackDeeplinkWalletConnector` hook in your component:

    ```tsx
    export default function LoginScreen() {
      const {
        address,
        connect,
        disconnect,
        isConnected,
        signMessage,
        signTransaction,
        signAllTransactions,
        signAndSendTransaction
      } = useBackpackDeeplinkWalletConnector({
        appUrl: 'https://yourdapp.com',
        redirectUri: '/sign-in'
      });

      // Your component code here
    }
    ```

    ### Configuration options

    The `useBackpackDeeplinkWalletConnector` hook accepts the following configuration:

    | Parameter     | Type     | Description                                                                                                |
    | ------------- | -------- | ---------------------------------------------------------------------------------------------------------- |
    | `appUrl`      | `string` | The URL of your app that will be displayed in the wallet app as the requesting dapp, for metadata purposes |
    | `redirectUri` | `string` | The path in your app that the wallet should redirect to after completing an action                         |
  </Tab>

  <Tab title="Other wallet providers">
    If you want to integrate with wallets other than Phantom or Backpack, you can use the generic `useDeeplinkWalletConnector` hook and configure it for your specific wallet:

    ```tsx
    export default function LoginScreen() {
      const {
        address,
        connect,
        disconnect,
        isConnected,
        signMessage,
        signTransaction,
        signAllTransactions,
        signAndSendTransaction
      } = useDeeplinkWalletConnector({
        // Base URL for the wallet
        baseUrl: 'https://solflare.com',
        // The name of the public key used for encryption
        encryptionPublicKeyName: 'solflare_encryption_public_key',
        // Other wallet-specific configuration
        appUrl: 'https://yourdapp.com',
        redirectUri: '/sign-in'
      });

      // Your component code here
    }
    ```

    ### Configuration options

    The generic `useDeeplinkWalletConnector` hook accepts the following wallet-specific configuration parameters:

    | Parameter                 | Type     | Description                                                                                                                                                   |
    | ------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `baseUrl`                 | `string` | The base URL for the wallet's deeplink protocol. This is typically the wallet's website URL or a custom URL scheme (e.g., `https://solflare.com`).            |
    | `encryptionPublicKeyName` | `string` | The name of the key in localStorage where the wallet stores its encryption public key. This is used for secure communication between your app and the wallet. |
    | `appUrl`                  | `string` | The URL of your app that will be displayed in the wallet app as the requesting dapp, for metadata purposes                                                    |
    | `redirectUri`             | `string` | The path in your app that the wallet should redirect to after completing an action                                                                            |

    <Info>
      Always refer to the wallet provider's documentation for the specific deeplink protocol
      implementation and required parameters. Each wallet may implement deeplinking differently and
      require specific configuration values.
    </Info>
  </Tab>
</Tabs>

## 4. Using the connector in your UI

Now you can implement UI components to interact with the wallet:

```tsx
return (
  <View>
    <H4>Wallet Deeplinking</H4>
    <Text>Connected: {isConnected ? 'true' : 'false'}</Text>

    {!isConnected && <Button onPress={() => connect()}>Connect Wallet</Button>}

    {isConnected && (
      <>
        <Text>Address: {address}</Text>
        <Button onPress={() => disconnect()}>Disconnect</Button>
        <Button onPress={handleSignMsg}>Sign message</Button>
        <Button onPress={handleSignTx}>Sign transaction</Button>
        <Button onPress={handleSignAndSendTx}>Sign and send transaction</Button>
        <Button onPress={handleSignAllTxs}>Sign all transactions</Button>
      </>
    )}
  </View>
);
```

## 5. Implementing the wallet functions

Here are examples of how to implement the handler functions for various wallet actions:

```tsx
// Function to handle message signing
const handleSignMsg = async () => {
  try {
    const message = 'Hello, Privy Expo!';
    const signature = await signMessage(message);
    console.log('Message signed:', signature);
  } catch (error) {
    console.error('Error signing message:', error);
  }
};

// Function to handle transaction signing
const handleSignTx = async () => {
  try {
    // Create a transaction
    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: new PublicKey(address),
        toPubkey: new PublicKey('DESTINATION_ADDRESS'),
        lamports: LAMPORTS_PER_SOL * 0.01
      })
    );

    const signedTx = await signTransaction(transaction);
    console.log('Transaction signed:', signedTx);
  } catch (error) {
    console.error('Error signing transaction:', error);
  }
};

// Function to handle signing and sending a transaction
const handleSignAndSendTx = async () => {
  try {
    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: new PublicKey(address),
        toPubkey: new PublicKey('DESTINATION_ADDRESS'),
        lamports: LAMPORTS_PER_SOL * 0.01
      })
    );

    const signature = await signAndSendTransaction(transaction);
    console.log('Transaction sent:', signature);
  } catch (error) {
    console.error('Error sending transaction:', error);
  }
};

// Function to handle signing multiple transactions
const handleSignAllTxs = async () => {
  try {
    const transactions = [
      new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: new PublicKey(address),
          toPubkey: new PublicKey('DESTINATION_ADDRESS_1'),
          lamports: LAMPORTS_PER_SOL * 0.01
        })
      ),
      new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: new PublicKey(address),
          toPubkey: new PublicKey('DESTINATION_ADDRESS_2'),
          lamports: LAMPORTS_PER_SOL * 0.01
        })
      )
    ];

    const signedTxs = await signAllTransactions(transactions);
    console.log('Transactions signed:', signedTxs);
  } catch (error) {
    console.error('Error signing transactions:', error);
  }
};
```

<Info>
  The configuration for the generic connector will depend on the specific wallet you're integrating
  with. Refer to each wallet's documentation for their deeplinking protocol.
</Info>

## How deeplinking works

When a user interacts with your app:

1. Your app initiates a connection request using the `connect()` function
2. The user is directed to their installed wallet app
3. The user approves or denies the action in their wallet
4. The wallet redirects back to your app with the result
5. Your app updates its state based on the wallet's response

This flow provides a seamless experience for users, allowing them to interact with your dApp using their preferred wallet without having to switch contexts or manually copy addresses.

**That's it! You've successfully integrated wallet deeplinking in your Privy React Native app 🎉**

<Info>
  For the best user experience, consider implementing fallbacks for when a user doesn't have the
  wallet installed. You might prompt them to install the wallet or offer them an alternative login
  method.
</Info>


# Configure allowed domains
Source: https://docs.privy.io/recipes/react/allowed-domains



**To secure use of your client-side Privy App ID, we *strongly* recommend setting allowed domains for any application in production.** This is a **security best practice** that prevents arbitrary applications from reusing your Privy App ID in their own site.

<Tip>
  You should **always** restrict allowed domains for any **production** application. This step is
  not necessary for the Privy App ID you use in staging, development, or local environments.
</Tip>

<Info>
  Supporting a native mobile app or local test environments? Create an [app
  client](/basics/get-started/dashboard/app-clients) for each environment you want to support.
  **Clients** let you configure different settings while keeping the same users.
</Info>

To configure allowed domains for your app, go to the Privy [**dashboard**](https://dashboard.privy.io/) and select your production app from the dropdown in the left sidebar. Then, navigate to the **Configuration > App settings** page > **Domains** tab.

Under **Allowed Origins**, list the domains that will use your production Privy App ID, separated by commas, spaces, or breaks.

Please note:

* The protocol (`https`) is required.
* Trailing paths (`/path`) are not supported.
* Wildcards (`*`) are only supported as a subdomain (`*.domain.com`), but not as a domain alone (`*.com`).
* Partial wildcards of the form `*-sometext.domain.com` are not supported.
* Localhost (`http://localhost:port`) *is* supported but you *must* specify the `port` number. Though supported, we do **not** recommend listing `localhost` as an allowed domain for production apps. If you need to temporarily list `localhost` as an allowed domain for your production app ID, please take care to remove it when not developing.

<Tip>
  Many hosting providers and their corresponding DNS configurations treat `https://www.example.com`
  and `https://example.com` interchangeably. If these URLs are equivalent for your app setup, we
  recommend adding **both** (with and without the `www` subdomain) domains as allowed origins to the
  dashboard.
</Tip>

<Info>
  Setting allowed domains restricts **client-side access** to your Privy app ID only. Privy's REST
  API endpoints that you would query from your backend are gated by your app secret, which should
  **never** be exposed on a user's client.
</Info>

## Supporting preview URLs

Many hosting providers (e.g. Vercel) support preview deployment URLs to make it easy to test changes, like:

```ts
// Matches the pattern *.netlify.app, which anyone with a free Netlify account can deploy to
deploy-preview-id--yoursitename.netlify.app
```

For security reasons, **we do not allow whitelisting domains with a *generic* pattern** that are commonly used for these preview deployments, such as:

* `https://*.netlify.app` / `https://*.vercel.app`
* `https://*-projectname.netlify.app` / `https://*-projectname.vercel.app`

Any project can deploy to a domain that matches `https://*.netlify.app`, `https://*.vercel.app`, or similar. If you were to whitelist this domain for your production App ID, any actor could set up any arbitrary deployment with your hosting provider and can use your production App ID within their site.

**If you'd like to secure your Privy App ID on preview deployment URLs, please check if your hosting provider allows you to map preview deployments to a stable subdomain that only *you control***, like:

```ts
// Matches the pattern *.yoursitename.netlify.app, which only members of your Netlify account
// (or hosting provider) can deploy to
deploy-preview-42<b>.yoursitename.netlify.app</b>
```

This allows you to list `https://*.yoursitename.netlify.app` under allowed domains, which arbitrary actors cannot deploy to. See instructions to set this up with [Vercel](https://vercel.com/docs/deployments/generated-urls#preview-deployment-suffix) or [Netlify](https://docs.netlify.com/domains-https/custom-domains/automatic-deploy-subdomains/).

<Tip>
  **Allowed domains are primarily recommended for production applications**. If your preview
  deployments use a development Privy app ID, feel free to leave **Allowed Origins** empty to
  support use of your app ID in previews without the setup above.
</Tip>

## App clients and allowed domains

Within an [app client](/basics/get-started/dashboard/app-clients), you can override **Allowed origins** on your app while still sharing the same user base. To add a client, go to the **Configuration > App settings** page > **Clients** tab, and find the **Add app client** button. Create a client and add **Allowed origins**.

## Allowed OAuth redirect URLs

Similar to allowed domains, you can configure **allowed OAuth redirect URLs** to restrict where users can be redirected after they log in with an external OAuth provider. This is a **security best practice** that prevents users from being redirected to malicious sites with their authentication token. To configure allowed OAuth redirect URLs, navigate to **Configuration > App settings** > **Advanced** on the [dashboard](https://dashboard.privy.io?page=settings\&tab=advanced\&setting=advanced). Add the OAuth providers are allowed to redirect to after authentication.

Please note:

* The URL must be an exact match for the redirect URL; query params and trailing slashes will error.
* The URL must be at a domain listed in allowed domains.
* The protocol (`https`) is required.
* Wildcards (`*`) are not supported.
* If no URLs are listed, users can be redirected to any URL.


# Configure allowed OAuth redirect URLs
Source: https://docs.privy.io/recipes/react/allowed-oauth-redirects



Similar to allowed domains, you can configure **allowed OAuth redirect URLs** to restrict where users can be redirected after they log in with an external OAuth provider. This is a **security best practice** that prevents users from being redirected to malicious sites with their authentication token. To configure allowed OAuth redirect URLs, navigate to **Configuration > App settings** > **Advanced** on the [dashboard](https://dashboard.privy.io?page=settings\&tab=advanced\&setting=advanced). Add the OAuth providers are allowed to redirect to after authentication.

Please note:

* The URL must be an exact match for the redirect URL; query params and trailing slashes will error.
* The URL must be at a domain listed in allowed domains.
* The protocol (`https`) is required.
* Wildcards (`*`) are not supported.
* If no URLs are listed, users can be redirected to any URL.


# Configure cookies
Source: https://docs.privy.io/recipes/react/cookies



When a user logs in to your app, Privy issues that user an access token that stores their authenticated session. **You can configure Privy to store a user's access token either with a browser's [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) or as a [`HttpOnly` cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) set on your app's base domain**.

By default, Privy will store the user's access token in local storage. Configuring cookies requires that your app have a stable base domain and that you set a DNS record for this domain. In kind, **cookies are recommended for production applications only**.

While developing your integration, you can use Privy's default setup of local storage to get started.

## Enabling cookies

To configure your app to use cookies, follow the steps below:

### 1. Create separate development and production Privy app IDs

In the [**Privy Dashboard**](https://dashboard.privy.io/), create (at minimum) **two** Privy apps. Concretely, you should create one app for use in **production** environments only, and one app for use in **development** environments only.

This step is critical, as once you enable cookies, your production app ID will **only** work in your production environment, and will error in all other environments.

<Info>
  The development process for all environments (production and development) will be the same on your
  end. The only difference is that you **must** use separate app IDs for each environment.
</Info>

Next, follow the steps below, **only for your production app ID**. Do not complete them for your development app.

### 2. For your production app, register your production domain in the Privy Dashboard

In the [**Privy Dashboard**](https://dashboard.privy.io/), find your **production app** in the App Dropdown of the left sidebar. Then, navigate to the **Configuration > App settings** page > **Domains** tab for that app.

Toggle on **HttpOnly cookies**. You'll be prompted to add an app domain. This is the domain root of your web app (e.g. example.com). Do not include the protocol or [www](http://www).

**Do not list a domain that is not a production domain.** As a general rule, our team will not automatically approve domains that appear to be scoped to a sandbox environment. Example of such unsupported domains include `*.vercel.app`, `*.railway.app`, `*.herokuapp.com`, and `*.amazonaws.com`.

### 3. For your production domain, set the necessary DNS records

Once you've set your app's domain in **Configuration >> App settings >> Domains**, Privy will display any required DNS records you must set for that for that domain. **Go to the admin dashboard of your domain registrar and set the required DNS records.**

Once done, return to the **HttpOnly cookies** section in the **Privy Dashboard** and click the **Refresh** button on your domain. This will force Privy to re-verify if the correct DNS records have been set for that domain or not. Please note that it may take a few hours for DNS records to propagate before Privy can confirm that it is verified.

This allows Privy's servers to set a first-party cookie on your production domain.

**Once you've finished the steps above, Privy will review your request and update servers to begin setting cookies on your production app's domain.**

<Info>
  Once your domain is verified, the corresponding App ID can only be used on that **exact**
  production domain.
</Info>

### App clients and cookies

Each app can only have one **cookie domain**. If you share an app ID across web and mobile environments, you can use app clients to conditionally enforce cookies depending on the environment. For example, you can have an app client that enforces cookies for your web app, and an app client that does not enforce it for your mobile app.

To toggle cookie settings for different app clients, first set your **HttpOnly Cookies** and an app domain. Then, go to the **Configuration > App settings** page > **Clients** tab, and find the **App client** you’d like to enable cookies for. Select “edit”, set the cookies toggle to **Enabled**, and save.

If you enable cookies in an app client, but no base domain is set on your app, no cookies will be set.

<Tip>
  Within an app client, you can choose to enable or disable cookies. If you enable cookies for any
  client, they will be set on the domain that is configured as your app’s **domain**.
</Tip>

### Debugging DNS issues

#### CAA records block issuance

Some providers may require extra configuration in order to set up SSL for your base domain to work with Privy. If you are seeing the error "CAA records block issuance" in the Privy dashboard or you keep trying to set an `acme_challenge` and state resets, you might either:

1. Already have CAA record that does not include one of the CAs Privy uses to issue SSL certs
2. Need to explicitly set a CAA record

To resolve this, go to your provider and create a `CAA` record on your root domain (ie `example.com`, not including any subdomains). If there are already contents in the `CAA` record, append the following, otherwise create a new record containing the following:

```
# Let's Encrypt
0 issue "letsencrypt.org"
0 issuewild "letsencrypt.org"

# Google Trust Services
0 issue "pki.goog; cansignhttpexchanges=yes"
0 issuewild "pki.goog; cansignhttpexchanges=yes"
```

#### The hostname is associated with a held zone

If you use Cloudflare as a DNS provider and have "held" your zone for security reasons, you will need to temporarily [release the hold](https://developers.cloudflare.com/fundamentals/setup/account/account-security/zone-holds/#release-zone-holds).

## Using cookies in development

In **both production and development** (local, preview, staging) environments, Privy will set a cookie with the name `privy-token` to store your user's session. **Your app logic for handling the cookie (e.g. in your authorization middleware) does not need to handle different environments differently.**

The mechanics of *how the cookie is set* is the key difference between production and development environments. This is why you **must only use your production App ID within your production environment**.

Concretely:

* For your **production** app ID, once you have completed the steps above, Privy's **servers** will set a cookie, only on the domain you have verified and any subdomains. Cookies will not be set on localhost.
* For your **development** app ID(s), Privy's **client** will automatically set a cookie on *any* domain you use this App ID on, including localhost. This allows you to use the same app logic around cookies across various environments. As a security precaution, client-set cookies for development have a shorter lifetime (7 days, versus 30 days for server-set cookies).

We recommend maintaining two apps, one for development and one for production. However, if you need to develop with your production App ID in a `localhost` environment, you can do so by using [App Clients](/basics/get-started/dashboard/app-clients).

## Server-side rendering

With cookies, when an authenticated user visits a page of your app, the request to fetch the page from your server will automatically include the user's access token as a **`privy-token`** cookie.

If your app uses **server-side rendering (SSR)**, you can use the presence of this cookie (and other Privy cookies) to determine if the user is authenticated *before* your page is rendered on the client.

### When the `privy-token` is present

Concretely, if the request to your server includes a valid **`privy-token`**, you should consider the user as authenticated and should handle them accordingly.

### When the `privy-token` is absent

If the request to your server does *not* include a valid **`privy-token`**, the user might either:

* be unauthenticated, and will need to **`login`** to become unauthenticated.
* *appear* as unauthenticated, and will need to wait for the page to be rendered in their client before you can determine if they are authenticated.

The latter case generally occurs when an authenticated user steps away from your app for more than an hour, allowing the access token to expire, and returns to your app for the first time. In this case, the request to fetch the page from your server will **not** include a valid **`privy-token`**, as it has expired, but the **`privy-token`** will be refreshed imminently as soon as the page loads in the user's browser.

To handle this case, when the **`privy-token`** is missing in the request, you should **instead wait for your app to load in the client, to allow their user's authentication status to update correctly, before taking any actions based on their authentication status.** This most commonly occurs in middleware setups that perform server-side routing.

One solution for handling this flow is to set up your app and middleware like so:

#### Client-side setup

In your client, add a new page (e.g. **`/refresh`**) that implements the following:

1. Call Privy’s **`getAccessToken`** method when the page loads. This ensures that whenever the user visits this page, their session is refreshed if they are authenticated.
2. If **`getAccessToken`** returns a valid token, redirect the user to the path specified in a **`redirect_uri`** query parameter. Your middleware will populate this query parameter later.
3. If **`getAccessToken`** returns `null`, redirect the user to your login page as they are not authenticated.

#### Middleware setup

In your middleware, when your backend receives a request to fetch a given page:

1. If the request includes a **`privy-token`** that is valid, you can consider the user authenticated and apply your normal middleware.
2. If the request does not include a **`privy-token`** but does include a **`privy-session`** cookie, the user may be authenticated, and you’ll need to refresh their session from the client before applying your middleware.
3. To refresh the user’s session from the client, you can redirect the user to the **`/refresh`** page you set up above. As part of this, you should also pass the original route the user intended to visit as a query param (e.g. **`redirect_url`**) when you redirect them to **`/refresh`**. Per the client-side setup, this allows the user's session to be refreshed and for them to be correctly redirected based on their authentication status.

Make sure to exclude the following from the above redirect middleware:

1. The page at the `/refresh` path you setup: in this case, the user should be allowed to visit the `/refresh` page as their authentication status and redirect will be handled *on that page* in the client. Redirecting away from this page in your middleware may result in an infinite redirecting loop.
2. Any page that includes the query parameter `privy_oauth_code`, `privy_oauth_state`, or `privy_oauth_provider`: these parameters are a required component of Privy's [OAuth login flow](/authentication/user-authentication/login-methods/oauth) and applying a redirect will destructively erase them.

As an example, if you're using NextJS, you might setup your middleware like so:

```tsx
// Replace this array with an array of paths for pages in your app that do not require the
// user to be authenticated, e.g. a login page
const UNAUTHENTICATED_PAGES = [];

export const config = {
  // necessary to ensure that you are redirected to the refresh page
  matcher: '/'
};

export async function middleware(req: NextRequest) {
  const cookieAuthToken = req.cookies.get('privy-token');
  const cookieSession = req.cookies.get('privy-session');

  // Bypass middleware when `privy_oauth_code` is a query parameter, as
  // we are in the middle of an authentication flow
  if (req.nextUrl.searchParams.get('privy_oauth_code')) return NextResponse.next();

  // Bypass middleware when the /refresh page is fetched, otherwise
  // we will enter an infinite loop
  if (req.url.includes('/refresh')) return NextResponse.next();

  // If the user has `privy-token`, they are definitely authenticated
  const definitelyAuthenticated = Boolean(cookieAuthToken);
  // If user has `privy-session`, they also have `privy-refresh-token` and
  // may be authenticated once their session is refreshed in the client
  const maybeAuthenticated = Boolean(cookieSession);

  if (!definitelyAuthenticated && maybeAuthenticated) {
    // If user is not authenticated, but is maybe authenticated
    // redirect them to the `/refresh` page to trigger client-side refresh flow
    return NextResponse.redirect(new URL('/refresh', req.url));
  }

  return NextResponse.next();
}
```

<Info>
  By design, Privy does **not** permit apps to refresh a user's access token from the app's server
  via the user's refresh token. This is a standard security protection to limit the surface area of
  exposure of the refresh token.
</Info>


# null
Source: https://docs.privy.io/recipes/react/custom-fiat-onramp



## Integrating a custom fiat on-ramp into your app

**Privy makes it easy to integrate a fiat on-ramp alongside our SDK, helping your users fund their wallets with the tokens they need to engage with your app.**

If your app involves on-chain actions like sending transactions or calling smart contracts, your users likely need some way to fund their wallet(s) with crypto, in order to pay gas and make purchases. Fiat on-ramps allow your users to purchase crypto via traditional payment methods, such credit/debit cards and ACH transfers.

In this guide, you'll find instructions for:

* how to choose the right fiat on-ramp provider for your app
* how to integrate a fiat on-ramp provider
* a complete demo implementation of a fiat on-ramp integrated alongside Privy

## Choosing a fiat on-ramp provider

**To start, you'll need to choose a fiat on-ramp provider that meets your app's requirements.** Different on-ramp providers vary in their support of:

* different tokens (ETH, USDC, Dai, POL, etc.)
* different networks (Ethereum, Polygon, Optimism, etc.)
* different regions (US, Europe, Brazil, South Korea, India, etc.).
* different payment methods (credit cards, debit cards, ACH, instant ACH, etc. )

You should choose a fiat on-ramp provider based on your needs across the categories listed above. You can check each provider's documentation to determine if it can support the requirements of your app and your user base. Some providers we recommend working with include [Moonpay](https://docs.moonpay.com/moonpay/implementation-guide/on-ramp), [Sardine](https://docs.sardine.ai/docs/payments/2burazgxidfsu-on-ramp#next-steps), [Stripe](https://stripe.com/docs/crypto/quickstart), [Ramp](https://ramp.network/), [Onramper](https://www.onramper.com/), and [Poko](https://www.pokoapp.xyz/).

Once you have chosen an on-ramp provider for your app, **set up an account with that provider and retrieve your sandbox API keys to build an integration**.

Most providers will provision you with a **public API key** that can be exposed to your frontend, and a **secret API key** that should only exist on your server. Some providers may also offer a **webhook API key** so you can subscribe to updates on your users' transactions.

## Integrating the provider

For the remainder of this guide, we will assume **Moonpay** is our chosen fiat on-ramp provider (though you should choose the provider that is best for your app).

The overall integration shape is roughly the same across different providers, and generally looks like:

1. In your **frontend**, collect details about your user (wallet address, email, etc.) and the assets they want to purchase (which tokens, what network, amount, etc.). Make a request to your **backend** with these details.
2. In your **backend**, once you receive the request from step (1), construct a fiat on-ramp URL for your user. Each provider will give you a base URL for a generic on-ramp flow, and you can tailor the flow to be specific to your user by setting the details from step (1) as query parameters. Send this URL back to your **frontend**.
3. In you **frontend**, once you receive the URL from step (2), you can either redirect your user to that URL or embed it in an `iframe` within your site. Within the new page/`iframe`, your user will complete their purchase flow and any required identity verification steps.

Below is a guide of how to implement steps (1)-(3) with Moonpay as a concrete example. For the sake of this demo, assume that, in this app, users are able to login with their email address and are prompted to create a Privy embedded wallet upon logging in (which they will need to fund).

### 1. Collect information about the user's on-ramp flow in your frontend

To start, we'll add a `fundWallet` method to our frontend that collects information about our user and our desired on-ramp flow, and sends it to our backend.

In this example app, users login with their email address and create a Privy embedded wallet upon logging in. Thus, we can get the user's email and wallet address from their [`user`](/user-management/users/the-user-object) object and include it in this request. This ensures the user doesn't have to enter this manually when completing the on-ramp flow later.

```tsx Getting the email and wallet address of the user
const walletAddress = user?.wallet?.address;
const emailAddress = user?.email?.address;
```

In this example app, we also want to *redirect* the user to the on-ramp URL instead of embedding it in an `iframe`. Thus, we can get the URL of the current page (`window.location.href`) and include it in this request. This allows the on-ramp provider to redirect the user back to this page once they have completed their purchase.

```tsx Getting the URL of the current page
const currentUrl = window.location.href;
```

Depending on your app, you can configure more information about the on-ramp flow as well. For instance:

* If users of your app only ever need to pay gas on Ethereum mainnet, you can pre-populate the asset to be purchased to always be 'eth' and the network to always be 'ethereum'.
* If your app is cross-chain and needs users to have different assets on different chains, you can instead surface UI elements to allow the user to select which asset and network they'd like to fund their wallet with.

<Tip>
  When completing the on-ramp flow, your user will have to manually enter/select any information
  that you do not pre-fill here (e.g. wallet address, which asset to purchase, etc.).
</Tip>

We'll now implement the `fundWallet` method to send this data to our backend, [authorizing the request](/authentication/user-authentication/access-tokens) with the user's Privy auth token.

```tsx Requesting the on-ramp URL from the server
const {user, getAccessToken} = usePrivy();

...

const fundWallet = async () => {
    const walletAddress = user?.wallet?.address; // Get user's wallet address
    if (!walletAddress) return; // If user does not have a wallet, no-op
    const emailAddress = user?.email?.address; // Get user's email address
    const currentUrl = window.location.href; // Get URL of current page
    const authToken = await getAccessToken(); // Get Privy auth token

    // Send request to server with these details
    // Feel free to swap out `axios` for `fetch` or your preferred HTTP library
    try {
      const onrampResponse = await axios.post(
        // Replace this with the API route you implement in step (2)
        "/api/onramp",
        // Add any additional on-ramp configurations you'd like, such as network, asset, amount, etc.
        {
          address: user!.wallet!.address,
          email: user?.email?.address,
          redirectUrl: currentUrl,
        },
        {
          headers: {
            Authorization: `Bearer ${authToken}`,
          },
        }
      );
      return onrampResponse.data.url as string;
    } catch (error) {
      console.error(error);
      return undefined;
    }
  };
```

In this example, `fundWallet` parses the response returned by the server (we'll implement this below) and returns the fiat on-ramp URL as a string.

### 2. Construct the on-ramp URL in your backend

Now, we'll implement the logic in our backend to construct the fiat on-ramp URL based on the configuration we collected in step (1). In particular, we'll implement a `POST /api/onramp` handler that receives the request from step (1) and responds with the on-ramp URL.

In our handler, we'll start by parsing the request body for the user's wallet `address`, `email`, and `redirectUrl`. If you included additional information in your request (e.g. asset type, amount), you should parse the request body for those values as well.

```tsx Parsing the request body
const {address, email, redirectUrl} = req.body;
```

Next, we'll construct the fiat on-ramp URL where our user can complete their purchase. We'll start with the base URL given to use by our fiat on-ramp provider (Moonpay):

```tsx Initializing the on-ramp with our base URL
const onrampUrl = https://buy-sandbox.moonpay.com?apiKey=YOUR_MOONPAY_PUBLIC_KEY;
```

This generally is a URL at the provider's domain with your account's public key appended as a query parameter.

We can then pre-populate details about the user's on-ramp flow as URL query parameters, based on what we parsed from the request.

```tsx Configuring our on-ramp via URL query parameters
onrampUrl.searchParams.set('walletAddress', address);
onrampUrl.searchParams.set('redirectURL', redirectUrl);
onrampUrl.searchParams.set('email', email);
onrampUrl.searchParams.set('currencyCode', 'eth');
```

For Moonpay, you can find the exact query parameters that can be pre-populated [here](https://docs.moonpay.com/moonpay/implementation-guide/on-ramp/browser-integration/customize-the-widget).

Lastly, after we've configured the on-ramp URL for our user, we'll authorize the URL using the secret key given to us by our fiat on-ramp provider. For Moonpay, we'll authorize the URL by signing it with the secret key, and appending the signature as a query parameter to the URL:

```tsx Authorizing the on-ramp URL with a signature
import crypto from "crypto";
...
// Produce signature on URL
const urlSignature = crypto
    .createHmac("sha256", YOUR_MOONPAY_SECRET_KEY)
    .update(onrampUrl.search)
    .digest("base64");

// Set signature as URL query parameter
onrampUrl.searchParams.set("signature", urlSignature);
```

Other providers may have other ways of authorizing the URL, such as requesting a client token from their API and appending that token as a query parameter in place of a signature. You should check each provider's documentation to determine the correct mechanism for authorization.

We can finally send the completely configured, authorized on-ramp URL back to our front-end!

```tsx Returning the on-ramp URL to the client
return res.status(200).json({url: onrampUrl.toString()});
```

### 3. Redirect your user to the on-ramp URL in your frontend

With steps (1) and (2) completed, our `fundWallet` method in our front-end should now return a configured, authorized on-ramp URL where our user can complete their purchase.

```tsx Getting the on-ramp URL
const onrampUrl = await fundWallet();
```

In this example, we will *redirect* our user to this URL, so that they can complete their purchase in a new tab:

```tsx Redirecting our user to complete the on-ramp flow
window.open(onrampUrl, '_blank');
```

Once the user completes their purchase, they will be redirected back to the `redirectUrl` we configured in steps (1) and (2). On this redirect, Moonpay will also append a `transactionId` that we can optionally use to monitor the status of the user's transaction.

<Tip>
  If you redirect your user to the fiat on-ramp URL, as we have done here, we suggest that you show
  them some introductory context about the fiat on-ramp (e.g. in a modal) provider and why they need
  to purchase crypto for your app.
</Tip>

Alternatively, if you do not want to redirect the user to a new tab, you can instead surface the on-ramp URL within an `iframe` embedded within your site:

```tsx Embedding the on-ramp URL in an iframe
<iframe
    // These are necessary for proper identity verification
    allow="accelerometer; autoplay; camera; gyroscope; payment"
    frameborder="0"
    height="100%"
    width="100%"
    src={onrampUrl}
>
```

\*\*That's it! Your users can now fund the wallets they've connected/created through Privy and take on-chain actions in your app. 💪 \*\*

## NFT Checkout

If your app needs users to fund their wallets specifically so they can **purchase NFTs**, you should consider integrating an **NFT Checkout** flow in addition to, or instead of, a generic fiat on-ramp flow. NFT checkout flows generally offer a smoother user experience, due to less rigid identity verification requirements, higher payment success rates, and clearer context about what the user gets by purchasing crypto.

Many fiat on-ramp providers, including [Moonpay](https://docs.moonpay.com/moonpay/implementation-guide/nft-checkout) and [Sardine](https://docs.sardine.ai/docs/payments/x8swdo7es7xni-nft-checkout), offer NFT checkout integrations as well. The shape of this integration is much like that of the generic fiat on-ramp (outlined in this guide), but you will have to configure additional information about your NFT sale (contract address, token type, payments) in each provider's dashboard.

See each provider's documentation for more details, or [reach out](https://privy.io/slack) with any questions.

## Demo integration

Check out our **[fiat on-ramp demo app](https://fiat-onramp-demo.privy.io/)** to see an end-to-end integration of a fiat on-ramp alongside Privy. Take a look at the **[source code](https://github.com/privy-io/fiat-onramp-demo)** to see how the code snippets from this guide fit into a real app.

This demo app uses a sandbox instance of Moonpay, and you should use certain test values when completing the purchase flow as a user:

* When entering in payment details, **do not use a real payment method**. Use the test credit card listed [here](https://docs.moonpay.com/moonpay/implementation-guide/on-ramp/browser-integration/sandbox-testing).
* When completing identity verification, you will not be prompted to actually submit identity documents (as you would in production). Instead, you will be able to choose whether you'd like to simulate a successful or failed identity verification.


# Integrating with EIP-7702
Source: https://docs.privy.io/recipes/react/eip-7702



[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) is an upgrade to EVM blockchains that enables externally owned accounts (EOAs) to set their code to that of a smart contract. In practical terms, this means that EOA wallets will gain AA (account abstraction) capabilities such as transaction bundling, gas sponsorship, and custom permissions.

Privy supports all low level interfaces required by 7702 - signing authorizations and sending type 4 transactions, allowing you to use any implementation of EIP-7702. Use the following guides to get started with EIP-7702 in your application:

<Warning>
  EIP-7702 is only available on certain testnets like
  [Odyssey](https://odyssey-explorer.ithaca.xyz/) and [Sepolia](https://sepolia.etherscan.io/)
</Warning>

### Signing EIP-7702 authorizations

Privy provides a `useSignAuthorization` hook that allows you to sign an EIP-7702 authorization using the user's embedded wallet. This authorization is a cryptographic signature that allows an EOA to set its code to that of a smart contract, enabling the EOA to behave like a smart account.

```tsx
import {useSignAuthorization} from '@privy-io/react-auth';

const {signAuthorization} = useSignAuthorization();

const authorization = signAuthorization({
  contractAddress: '0x1234567890abcdef1234567890abcdef12345678', // The address of the smart contract
  chainId: chain.id
});
```

Learn more about using the signed authorization in the guides below!

### Using EIP-7702 capabilities

<Tabs>
  <Tab title="ZeroDev">
    In this guide, we demonstrate using [ZeroDev](https://zerodev.app/), a toolkit for creating smart accounts, together with Privy to enable your users to send gasless (sponsored) transactions.

    <Info>
      Want to see a full end to end example? Check out our starter repo
      [here](https://github.com/privy-io/create-next-app/tree/7702/zerodev)!
    </Info>

    ### 0. Install dependencies

    In your app's repository, install the required dependencies from Privy, ZeroDev and [`viem`](https://www.npmjs.com/package/viem):

    ```sh
    npm i @privy-io/react-auth @zerodev/sdk @zerodev/ecdsa-validator viem
    ```

    ### 1. Sign up for a ZeroDev account and get your project ID

    Visit the [**ZeroDev dashboard**](https://dashboard.zerodev.app/) and sign up for a new account if you do not have one already. Set up a new project for your required chain(s) and retrieve your ZeroDev **paymaster and bundler RPCs** from the dashboard.

    Once you have created a project, set up a [gas sponsorship policy](https://dashboard.zerodev.app/paymasters). This will tell ZeroDev to sponsor gas for your accounts. For this tutorial, you can just set a "Project Policy" like "Sponsor up to 10 requests per minute."

    ### 2. Configure Privy settings

    Configure your app to create embedded wallets for all users. Also configure Privy to not show its default wallet UIs. Instead, we recommend you use your own custom UIs for showing users the user operations they sign.

    Update your `PrivyProvider` configuration to include the following properties:

    ```tsx
    <PrivyProvider
      config={{
        embeddedWallets: {
          showWalletUIs: false, // [!code ++]
          createOnLogin: 'all-users' // [!code ++]
        }
      }}
    >
      ...
    </PrivyProvider>
    ```

    ### 3. Sign a wallet authorization with the embedded wallet

    The `useSignAuthorization` hook from the Privy SDK is used to create a cryptographic signature for an EIP-7702 authorization. This authorization allows an EOA (your user's embedded wallet) to set its code to that of a smart contract (in this case, the Kernel account implementation). According to the EIP-7702 specification, this signature creates a delegation designation that enables the EOA to behave like a smart account, including capabilities for transaction bundling and gas sponsorship.

    Use the code snippet below to generate an authorization signature for the wallet:

    ```tsx
    import {useSignAuthorization} from '@privy-io/react-auth';
    import {
      getEntryPoint,
      KERNEL_V3_3_BETA,
      KernelVersionToAddressesMap,
    } from "@zerodev/sdk/constants";
    import {odysseyTestnet} from "viem/chains";
    ...
    const chain = odysseyTestnet;
    const kernelVersion = KERNEL_V3_3_BETA;
    const entryPoint = getEntryPoint("0.7");

    const {signAuthorization} = useSignAuthorization();
    const authorization = signAuthorization({
        contractAddress: KernelVersionToAddressesMap[kernelVersion].accountImplementationAddress,
        chain
    })
    ```

    ### 4. Create a Kernel account with the ZeroDev SDK

    Use the signed authorization to create a Kernel account. With EIP-7702, this step doesn't actually deploy a new smart contract but instead creates a reference to the Kernel implementation that will be used when transactions are sent from the EOA. This delegation allows the user's EOA to execute transactions as if it were a Kernel smart account, gaining capabilities like gas sponsorship while maintaining the same address as the embedded wallet.

    ```tsx
    import {
      createKernelAccount,
      createKernelAccountClient,
      createZeroDevPaymasterClient
    } from '@zerodev/sdk';
    import {createWalletClient, createPublicClient, custom, http} from 'viem';

    const {wallets} = useWallets();
    const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

    const walletClient = createWalletClient({
      account: embeddedWallet.address as Hex,
      chain,
      transport: http()
    });

    const publicClient = createPublicClient({
      chain,
      transport: custom(await embeddedWallet.getEthereumProvider())
    });

    const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
      signer: walletClient,
      entryPoint,
      kernelVersion
    });

    const account = await createKernelAccount(publicClient, {
      plugins: {
        sudo: ecdsaValidator
      },
      entryPoint,
      kernelVersion,
      address: walletClient.account.address,
      eip7702Auth: authorization
    });
    ```

    ### 5. Configure the ZeroDev client for sponsored transactions

    This client creates and submits UserOperations (compatible with EIP-4337 infrastructure) that execute within the context of the delegated smart account code, enabling your application to provide a gas-free experience for users.

    ```tsx
    import {createKernelAccountClient, createZeroDevPaymasterClient} from '@zerodev/sdk';

    const paymasterRpc = 'YOUR_PAYMASTER_RPC_URL';
    const bundlerRpc = 'YOUR_BUNDLER_RPC_URL';

    const paymasterClient = createZeroDevPaymasterClient({
      chain,
      transport: http(paymasterRpc)
    });

    const kernelClient = createKernelAccountClient({
      account,
      chain,
      bundlerTransport: http(bundlerRpc),
      paymaster: paymasterClient,
      client: publicClient
    });
    ```

    Make sure to replace the `paymasterRpc` and `bundlerRpc` with the RPCs from the ZeroDev dashboard.

    ### 6. Send transactions with the client

    With the Kernel client configured, you can now send gas-sponsored transactions. This example shows how to send a basic transaction and wait for its receipt:

    ```tsx
    // Send a simple transaction
    const userOpHash = await kernelClient.sendTransaction({
      to: zeroAddress,
      value: BigInt(0),
      data: '0x'
    });

    console.log(userOpHash);

    // Wait for the transaction to be processed
    const {receipt} = await kernelClient.waitForUserOperationReceipt({
      hash: userOpHash
    });

    console.log(
      'UserOp completed',
      `${chain.blockExplorers.default.url}/tx/${receipt.transactionHash}`
    );
    ```

    ### Conclusion

    Congratulations! You just sent your first sponsored transaction from a EOA account, with EIP-7702.

    If you want to leverage other smart account capabilities such as transaction bundling and permissions, check out the [ZeroDev docs](https://docs.zerodev.app/).
  </Tab>

  <Tab title="Biconomy">
    In this guide, we demonstrate using [Biconomy's](https://biconomy.io/) Modular Execution Environments, together with Privy to enable your users to send cross chain transactions.

    ### 0. Install dependencies

    In your app's repository, install the required dependencies:

    ```sh
    npm i @privy-io/react-auth @biconomy/abstractjs viem @rhinestone/module-sdk@0.2.7
    ```

    ### 1. Sign up for a Biconomy account and get your project ID

    Visit the [**Biconomy dashboard**](https://dashboard.biconomy.io/) and sign up for a new account if you do not have one already.

    ### 2. Follow Biconomy setup instructions

    Follow the [Biconomy integration guide](https://docs.biconomy.io/eip7702/wallet-guide#eip7702-integration-guide-for-wallets) to set up the rest of your project using Biconomy's AbstractJS SDK!
  </Tab>
</Tabs>


# Configuring wallet confirmation modals
Source: https://docs.privy.io/recipes/react/manage-wallet-UIs



Privy allows you to customize showing wallet confirmation modals globally for your application in the Privy Dashboard or in your `PrivyProvider` configuration.

<Note>This is a guide for configuring wallet confirmation modals for the `react-auth` SDK.</Note>

## Dashboard configuration

To toggle displaying wallet confirmation modals navigate to the [Configuration > Authentication > Advanced](https://dashboard.privy.io/apps?logins=advanced\&page=login-methods) tab for your app.

Here you can toggle the `Disable confirmation modals` option across the entire application.

## `PrivyProvider` configuration

<Tip>The `showWalletUIs` option will override the dashboard configuration if one is set.</Tip>

In your `PrivyProvider` configuration, you can toggle the `showWalletUIs` option to enable or disable wallet confirmation modals across the entire application.

```tsx
<PrivyProvider
  config={{
    embeddedWallets: {
      showWalletUIs: false
    }
    /** ... */
  }}
>
  <App />
</PrivyProvider>
```

## Customizing wallet confirmation modals for individual function calls

<Tip>
  The `uiOptions.showWalletUIs` option will override the `PrivyProvider` configuration if one is
  set.
</Tip>

Privy allows you to further customize showing wallet confirmation modals for individual function calls by passing the `uiOptions.showWalletUIs` option to the respective function. Learn more in the following sections:

* Ethereum
  * [`signMessage`](/wallets/using-wallets/ethereum/sign-a-message#param-ui-options)
  * [`signTransaction`](/wallets/using-wallets/ethereum/sign-a-transaction#param-options-ui-options)
  * [`signTypedData`](/wallets/using-wallets/ethereum/sign-typed-data#param-ui-options)
  * [`sendTransaction`](/wallets/using-wallets/ethereum/send-a-transaction#param-options-ui-options)
* Solana
  * [`sendTransaction`](/wallets/using-wallets/solana/send-a-transaction#param-ui-options)
  * [`signTransaction`](/wallets/using-wallets/solana/sign-a-transaction#param-ui-options)


# Seamless Telegram login
Source: https://docs.privy.io/recipes/react/seamless-telegram



Privy enables developers to quickly integrate Login with Telegram into their applications. With the Privy Telegram integration, users can log in with Telegram and link Telegram accounts.

From a web environment, Privy enables Telegram login via the [Telegram Login widget](https://core.telegram.org/widgets/login). Privy also enables seamless Telegram login directly from within a Telegram bot or within Telegram Mini-Apps!

## Configure Telegram

### Configure Telegram login

Follow [this](https://core.telegram.org/bots/tutorial#obtain-your-bot-token) guide to create a telegram bot. After creating a Telegram bot, you must set your domain using the `/setdomain` command in the `@BotFather` chat. You will need to provide the following to Privy via the Privy Dashboard upon completion:

* Bot token (eg: `1234567890:AzByCxDwEvFuGtHsIr1k2M4o5Q6s7U8w9Y0`)
* Bot handle (eg: `@MyBot_bot`)

Note that when configuring Telegram login:

* Your domain must be configured as your bot's allowed domain.
* If you have CSP enforcement, you’ll need to update these directives:
  * `script-src` must allow `https://telegram.org` in order to be able to download Telegram's widget script.
  * `frame-src` must allow `https://oauth.telegram.org` in order to be able to render Telegram's widget iframe.

<Tip>
  To use your app as a Telegram Mini-App in the Telegram web client, add `http://web.telegram.org`
  and `https://web.telegram.org` to your allowed domains in the dashboard [Configuration > App
  settings > Domains](https://dashboard.privy.io?page=settings) tab.
</Tip>

<Info>
  Since you need to set your bot's allowed domain you'll need to use a tunneling tool for local
  development such as [Cloudflare
  tunnels](https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/) or
  [ngrok](https://ngrok.com/).
</Info>

### Essential: Secure your bot secret

<Warning>
  Telegram login requires developers to create a Telegram bot with a bot secret. This bot secret
  controls the Telegram bot and is also used as a symmetric key for authentication. Control over
  this key enables a developer to sign over authentication data, meaning compromise of this key puts
  your users (and their accounts) at risk.

  **Securing this symmetric key is essential for the security of all of your app’s Telegram logins.**
</Warning>

## Integration interfaces

### \[optional] Enable Telegram in your client-side `loginMethods`

You must enable Telegram in the Privy Dashboard to enable login with Telegram.

If you *additionally* have `loginMethods` configured client-side in your `PrivyProvider` config, make sure you add `"telegram"` to that list as well. Client-side login method configuration is only necessary if you want to restrict logins to a subset of those configured in the Dashboard.

```jsx
  <PrivyProvider
    appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ""}
    config={{
      loginMethods: ["email", "google", "telegram"],
      ...
    }}
  >
```

### Seamless login with Telegram

You can integrate Privy to enable login directly from within a Telegram bot or Telegram mini-app.

* If enabled, Privy will automatically log your user in when your user initiates login from within Telegram. You *do not* have to call `login` from the `usePrivy` hook in this case!
* To enable seamless login, send your website URL using , [InlineKeyboardButton.web\_app](https://core.telegram.org/bots/api#inlinekeyboardbutton) or [InlineKeyboardButton.login\_url](https://core.telegram.org/bots/api#inlinekeyboardbutton) or use a direct link (ex: `t.me/xxx_bot/xxx`)
* For reference, see these docs:
  * [https://core.telegram.org/bots/api#keyboardbutton](https://core.telegram.org/bots/api#keyboardbutton)
  * [https://core.telegram.org/bots/api#inlinekeyboardbutton](https://core.telegram.org/bots/api#inlinekeyboardbutton)

```jsx
bot.send_message(chat_id, 'Log in to demo!', {
  reply_markup: {
    inline_keyboard: [
      [
        {
          text: 'Login',
          login_url: {url: 'https://your-website-url'}
        },
        {
          text: 'Mini App',
          web_app: {url: 'https://your-website-url'}
        }
      ]
    ]
  }
});
```

### Login with Telegram

Once Telegram is enabled, you will *automatically* see Telegram in the Privy login modal. You can also list `'telegram'` when [configuring login methods client-side](/basics/react/advanced/configuring-appearance), in the `PrivyProvider`.

### Link Telegram

You can use the `linkTelegram` and `unlinkTelegram` methods from the `usePrivy` hook to add or remove Telegram accounts from a user. See the SDK reference for more details:

```jsx
const {linkTelegram, unlinkTelegram} = usePrivy();
```

### Link Telegram seamlessly within a Telegram Mini app

You can use the `linkTelegram` methods from the `usePrivy` hook within a Telegram Mini App to add to a user seamlessly by passing `launchParams` as a parameter. See the SDK reference for more details:

```jsx
// Sample library to retrieve launchParams
import {retrieveLaunchParams} from '@telegram-apps/bridge';

const {linkTelegram} = usePrivy();
const launchParams = retrieveLaunchParams();
linkTelegram({launchParams});
```

<Warning>Telegram `launchParams` are treated as expired after five minutes for security.</Warning>

### TelegramAccount type

The `user` object contains information about [all of the accounts](/user-management/users/the-user-object) a user has linked with Privy.

```jsx
Use the fields:
- **`user.linkAccounts`** to get a list of all the user's linked accounts
- **`user.telegram`** to get the user's Telegram account
```

**`TelegramAccount` extends `LinkedAccount`**

| Field              | Type       | Description                                                      |
| ------------------ | ---------- | ---------------------------------------------------------------- |
| type               | 'telegram' | N/A                                                              |
| telegram\_user\_id | string     | ID of a user's telegram account.                                 |
| first\_name        | string     | The first name displayed on a user's telegram account.           |
| last\_name         | string     | (Optional) The last name displayed on a user's telegram account. |
| username           | string     | (Optional) The username displayed on a user's telegram account.  |
| photo\_url         | string     | (Optional) The url of a user's telegram account profile picture. |


# Login with Apple
Source: https://docs.privy.io/recipes/swift/apple



Privy supports native [Apple login](https://developer.apple.com/sign-in-with-apple/) on iOS. Apple is an OAuth2.0 compliant authentication provider, but requires a specific implementation of Apple sign-in within iOS apps.

<Tip>
  Prior to integrating Sign in with Apple, make sure your app's `Bundle ID` rather than the `Service
    ID`, is configured as the `Client ID` within the [Privy
  Dashboard](/basics/get-started/dashboard/app-clients) for the Apple Social login credentials.
</Tip>

## The "Sign in with Apple" button

Apple's [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple) has a clear definition of how the Sign in with Apple button should look.
In order to ensure compliance with Apple's guidelines, we recommend you use the `ASAuthorizationAppleIDButton` class from Apple's `AuthenticationServices` framework.

**Take a look at the snippet below** if you wish to use the `ASAuthorizationAppleIDButton` in SwiftUI.

```swift
struct SignInWithApple: UIViewRepresentable {
  typealias UIViewType = ASAuthorizationAppleIDButton
  func makeUIView(context: Context) -> ASAuthorizationAppleIDButton {
    return ASAuthorizationAppleIDButton()
  }

  func updateUIView(_ uiView: ASAuthorizationAppleIDButton, context: Context) {
  }
}
```

<Warning>
  Apple's `AuthenticationServices` framework also offers the [`SignInWithAppleButton` SwiftUI
  View](https://developer.apple.com/documentation/authenticationservices/signinwithapplebutton/),
  but relying on `ASAuthorizationAppleIDButton` instead allows the PrivySDK to handle the whole
  authentication process for you.
</Warning>

## Initializing Apple login

Privy automatically implements and launches Apple's native `ASAuthorizationController` after calling `privy.oAuth.login(with: OAuthProvider.apple)`. Add the `SignInWithApple` button to your view as described above, and trigger the login method when tapped.

```swift
// Add the SignInWithApple button with your view and register the tap gesture
SignInWithApple()
    .onTapGesture {
        // Ideally this is called in a view model, but showcasing logic here for brevity
        Task {
            do {
                // The `appUrlScheme` param is not necessary for using Sign in with Apple.
                // Privy will use the first valid app URL scheme from your app's info.plist.
                // Ensure your client's url schemes are registered in the Privy dashboard
                let authSession = try await privy.oAuth.login(with: OAuthProvider.apple)
            } catch {
                debugPrint("Error: \(error)")
                // Handle errors
            }
        }
    }
```


# Setting a system theme for the Privy modal
Source: https://docs.privy.io/recipes/system-theme



**With Privy, you can style your login modal to match your user's system preferences for light or dark mode.** Below is a short guide for how to configure your login modal to match your user's system settings.

### 1. Get your user's system preferences

To start, you should determine if your user's system preferences are configured for light mode, or for dark mode.Based on their system preferences, your user's device will automatically set the [`prefers-color-scheme`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme) CSS media feature in your website to indicate their light/dark preference. You can simply query this media feature to determine if your user prefers light or dark mode.

Below is a sample React hook to determine if your user prefers light or dark mode; feel free to use this directly in your app!

```tsx
import {useEffect, useState} from 'react';

// Returns true if the user prefers dark mode, and false otherwise
export default function useDarkMode() {
  const [darkMode, setDarkMode] = useState(false);

  const modeMe = (e: MediaQueryListEvent) => {
    setDarkMode(!!e.matches);
  };

  useEffect(() => {
    // Query the `prefers-color-scheme` media feature
    const matchMedia = window.matchMedia('(prefers-color-scheme: dark)');
    setDarkMode(matchMedia.matches);
    // Listen to changes in the `prefers-color-scheme` media feature
    matchMedia.addEventListener('change', modeMe);
    return () => matchMedia.removeEventListener('change', modeMe);
  }, []);

  return darkMode;
}
```

### 2. Construct a light and dark theme

Next, in your frontend code, [create an `appearance` configuration object](/basics/react/advanced/configuring-appearance) for both light *and* dark mode. You can use the default Privy light and dark themes, e.g.:

<Tabs>
  <Tab title="Light">
    ```tsx
    const lightModeConfig = {
      appearance: {
        theme: 'light',
        logo: 'light-logo-url',
      },
    };
    ```
  </Tab>

  <Tab title="Dark">
    ```tsx
    const darkModeConfig = {
      appearance: {
        theme: 'dark',
        logo: 'dark-logo-url'
      }
    };
    ```
  </Tab>
</Tabs>

Or, you can create custom `lightModeConfig` and `darkModeConfig` objects (with custom [`theme`](/basics/react/advanced/configuring-appearance#theme)s and [`accentColor`](/basics/react/advanced/configuring-appearance#accent-color)s) to match the modal's light and dark modes with your app's branding.

### 3. Conditionally set your theme based on the user's system preferences

Lastly, in your `PrivyProvider`, conditionally pass in the `lightModeConfig` (your light mode configuration object) or `darkModeConfig` (your dark mode configuration object) depending on the user's system preferences from step 1.

```tsx
// 1. Query the user's system preferences for light or dark mode
const darkMode = useDarkMode();

// 2. Construct your light mode and dark mode configuration objects
const lightModeConfig = {
  /* your light mode configuration object */
};
const darkModeConfig = {
  /* your dark mode configuration object */
};

// 3. When you render your `PrivyProvider`, change the `config` property based on the user's system preferences
return (
  <PrivyProvider appId={'your-app-ID'} config={darkMode ? darkModeConfig : lightModeConfig}>
    {children}
  </PrivyProvider>
);
```

**That's it!** Your Privy modal's theme will now automatically match the user's system preference for light or dark mode.


# Integrating with tRPC
Source: https://docs.privy.io/recipes/trpc



**[tRPC](https://trpc.io) is an end-to-end typesafe API built in Typescript.** This guide shows how to integrate Privy into any tRPC application.

There are two steps to enable auth in tRPC with Privy:

* in your [client](./trpc.md#configuring-your-client), include the user's access token on requests
* in your [server](./trpc.md#protecting-routes-on-your-server), secure procedures by validating the token included on requests

<Tip>
  If you're using tRPC with [zod](https://github.com/colinhacks/zod), check out [this transformation
  tool](https://transform.tools/typescript-to-zod) to automatically generate zod schemas from
  Privy's types (e.g. **`user.email`**).
</Tip>

## Configuring your client

**When your client (frontend) makes a request to one of your tRPC procedures, you should include the Privy auth token, so that your server can verify that the user is authenticated.**

<Info>
  The following works for both
  [`createTRPCProxyClient`](https://trpc.io/docs/typedoc/client/functions/createTRPCProxyClient-1)
  (vanilla) or [`createTRPCNextClient`](https://trpc.io/docs/nextjs#createtrpcnext-options)
  (Next.js). Note that while the configuration method signature is different between the two, the
  inner configuration object/strategy will remain the same. The example shown is for NextJS.
</Info>

When [scaffolding the tRPC client](https://trpc.io/docs/vanilla), pass the Privy auth token through the header of every request, via an [`httpBatchLink`](https://trpc.io/docs/links/httpBatchLink) within the `links` configuration. Below is an example:

```tsx
import {httpBatchLink} from '@trpc/client';
import {createTRPCNext} from '@trpc/next';

import {getAccessToken} from '@privy-io/react-auth';

export const api = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: `your_base_url`,
          // apply the privy token to each request
          async headers() {
            return {
              Authorization: `Bearer ${(await getAccessToken()) || ''}`
            };
          }
        })
      ]
    };
  }
});
```

## Protecting routes on your server

**When your server receives a request from the client, it should validate the Privy auth token to confirm included in the request to ensure that it is authenticated.**

First, parse the passed token using jose where you create your tRPC context:

```typescript
import * as trpc from '@trpc/server';
import {inferAsyncReturnType} from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';

import {PrivyClient} from '@privy-io/server-auth';

// configure your privy server auth client

const privy = new PrivyClient(
  process.env.NEXT_PUBLIC_PRIVY_APP_ID || '',
  process.env.PRIVY_APP_SECRET || ''
);

export async function createContext({req, res}: trpcNext.CreateNextContextOptions) {
  const authToken = req.headers.authorization.replace('Bearer ', '');
  let userClaim: string | undefined = undefined;

  if (authToken) {
    try {
      userClaim = await privy.verifyAuthToken(token);
      // the claim contains all details about the validated privy token and can be passed
      // via the context for use in all server routes
      // if you want to pull additional details about the user via your api / db, such as whether the user is an
      // admin, here's your chance!
    } catch (_) {
      // this is an expected error for tRPC procedures that don't need to be authenticated
      // if privy is expected, we will throw a 403 at the middleware level, shown in the next step
    }
  }
  return {
    userClaim
  };
}
export type Context = inferAsyncReturnType<typeof createContext>;
```

Next, create a middleware procedure for protecting routes:

```typescript
const isPrivyAuthed = t.middleware(async ({ctx, next}) => {
  // check to make sure that the token was valid.
  // you can add further logic here, such as checking if the user is an admin,
  // if you added more user context within `createContext` above.
  if (!ctx.userClaim) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'Not authenticated'
    });
  }
  return next({
    ctx
  });
});
export const privyProtectedProcedure = t.procedure.use(isPrivyAuthed);
```

Finally, when defining routes, you can use your procedure middleware to ensure the user is properly authenticated.

```typescript
t.router({
  // this is accessible for everyone
  hello: t.procedure
    .input(z.string().nullish())
    .query(({input, ctx}) => `hello ${input ?? ctx.user?.name ?? 'world'}`),
  admin: t.router({
    // this is accessible only to admins
    secret: privyProtectedProcedure.query(({ctx}) => {
      return {
        secret: 'sauce'
      };
    })
  })
});
```


# null
Source: https://docs.privy.io/recipes/using-test-accounts



Test accounts can be used to build automated tests, for local development, or to reduce friction during Apple's [App Store review](https://developer.apple.com/app-store/review/) process for mobile apps. A new set of credentials are created each time you enable the test account, and the old one is revoked to keep your account secure.

<Info>
  To use these test accounts, your app must support email or SMS login. Testing other login flows
  can either be automated with a library like [Playwright](https://playwright.dev/), or by
  completing the flow manually, as it requires authorization with other APIs *(such as social
  providers)*.
</Info>

## Enabling test accounts

To enable a test account for your app and get its login credentials:

1. Go to the **User management > Authentication > Advanced** tab of the Privy Dashboard
2. Turn on the **Enable test accounts** toggle

Once enabled, you will see the login credentials for your test account that you can use for your app ID.

All test credentials follow the same format, where `XXXX`/`XXXXXX` in the credentials below should be substituted with the values you see in the **User management > Authentication > Advanced** page of the Dashboard. You **cannot** substitute arbitrary values for `XXXX`/`XXXXXX` or use [plus addressing](https://learn.microsoft.com/en-us/exchange/recipients-in-exchange-online/plus-addressing-in-exchange-online); you **must** use the credentials from the Dashboard exactly.

| email                | phone             | OTP *(for either)* |
| -------------------- | ----------------- | ------------------ |
| `test-XXXX@privy.io` | `+1 555 555 XXXX` | `XXXXXX`           |

Once enabled, a test user can log into your app with the provided email or phone number and the provided OTP code to review and test your app.

<Info>
  Depending on when you created your Privy app, you may have a legacy test account enabled with the
  login credentials `test@privy.io` or `+1 555 555 5555`. Please see the **User management >
  Authentication > Advanced** page of the Privy Dashboard to determine if this is the case for your
  app.
</Info>

<Tip>
  Test accounts have a lighter authentication rate limit for apps in development. While all accounts
  in production apps and non-test accounts in development apps are limited to 5 requests every 5
  minutes for email and 5 requests every 10 minutes for SMS, test accounts in development apps are
  limited to 10 requests every 10 seconds for either.
</Tip>

## Getting a test access token programmatically

You can programmatically get an access token for your app's test account using the `getTestAccessToken` method:

```typescript
getTestAccessToken(): Promise<{accessToken: string}>
```

This method returns a `Promise` that resolves to an object containing the `accessToken` string for the test account.

<Warning>
  `getTestAccessToken` will throw an error if:

  * You have not enabled test credentials in the Privy Dashboard
  * Allowed origins or base domain are enabled for your app
</Warning>


# User authorization keys
Source: https://docs.privy.io/security/authentication/authenticated-signers



**User authorization keys** enable users to fully control self-custodial wallets.

[Authorization keys](/security/wallet-infrastructure/policy-and-controls) are the core primitive for control of Privy's [wallet API](/security/wallet-infrastructure/secure-execution-environments/secure-enclave). Authorization key signatures are used to authenticate directly with the Privy wallet API.

They enable a fully configurable control model for wallets, which includes the entire spectrum from user-custodial wallets to powerful service-level controls. If an authorization key is set as a signer on the wallet, than it can transact funds on the wallet.

## Self-custodial wallets

<Tip>All Privy client-side SDKs enable **fully user self-custodial wallets by default**.</Tip>

**Self-custodial** Privy wallets are those owned by an authorization key that the user controls. For example, you can configure fully user self-custodial wallets by:

* Authenticating a user with the **User authorization key API** to issue an authorization key
* Directly adding the user's **passkey** as the authorization key

**User authorization keys** are authorization keys that users control directly via an authentication method. Privy infrastructure manages issuing time-bound authorization keys to users via the **User authorization key API**. This configuration results in cryptographically-enforced user custody of wallets.

### Authentication methods

Privy integrates directly with any OIDC or JWT-based authentication system and also offers [dozens of login methods natively](/security/authentication/user-authentication), including email, SMS, social login, passkeys, and more. The user authorization key API ensures that if a user is logged in, they always have access to their wallet.

### Multi-factor authentication

Privy also enables multi-factor authentication for access to user authorization keys. Supported additional factors include:

* Authenticator apps (TOTP)
* Biometric verification (passkeys)
* SMS confirmation
* Hardware security keys

This means your app can require additional user verification for sensitive wallet operations. [Learn more](/authentication/user-authentication/mfa#mfa)

## Client-side user authorization keys

Client-side **user authorization keys** are time-bound authorization keys available via Privy client SDKs, and issued on the user's device. These authorization keys are managed internally by the Privy SDK and are used to authenticate with Privy's wallet API. User authorization keys are only accessible when the user is authenticated.

Client-side authorization keys are managed within the secure environments directly on user devices. In particular, Privy secures user authorization keys using browser-enforced isolation via iframes. The Privy iframe runs in a separate process with its own isolated memory space, completely separated from your application.

Client-side authorization keys are generated directly on the user's device, secured using distributed key sharding, and persisted with Privy's key management infrastructure. See [user device execution environment](/security/wallet-infrastructure/secure-execution-environments/user-device) for more information about this architecture. Note this core architecture can be used to secure either user authorization keys *or* on-device wallets directly.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/client-signer.png" alt="Client-side user authorization keys" />
</Frame>

## User authorization key API

The User authorization key API enables **time-bound authorization keys to be issued directly via a REST API**. This API can be called from either your app's frontend or backend.

The User authorization key API manages authorization keys from within trusted execution environments (TEEs)—see [TEE architecture](/security/wallet-infrastructure/secure-execution-environments/secure-enclave) for more information. This API integrates with any asymmetric JWT-based authentication system, such as Privy's native authentication system, Auth0, Firebase, or any OIDC or OAuth authentication provider. Authentication is verified within the TEE.

If applicable, first register your JWT verification public key or JWKS.json endpoint via the Privy Dashboard.

1. Make a request to the User authorization key API using the authentication token from your JWT-based authentication system.
2. The TEE issues a time-bound user authorization key in response.
3. Use the user authorization key to authorize requests to the Privy wallet API.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/api-signer.png" alt="Server-side user authorization keys" />
</Frame>

### Encryption

The returned time-bound authorization key is encrypted from the TEE to the client using HPKE (Hybrid Public Key Encryption), using the same method used by our [wallet export API](/api-reference/wallets/export).


# User authentication
Source: https://docs.privy.io/security/authentication/user-authentication



**Privy's embedded wallets are fully compatible with any authentication provider that supports JWT-based, stateless authentication.** If you're looking to add embedded wallets to your app, you can either:

* use Privy as your authentication provider (easy to set up out-of-the-box)
* use a custom authentication provider (easy to integrate alongside your existing stack)

## Integrating with any OIDC/JWT-based authentication system

Privy integrates with any authentication system that relies on asymmetric JWT tokens. This includes popular authentication providers such as Auth0, AWS Cognito, Firebase, as well as **all** OIDC (OAuth) social providers such as Google, Apple, and Twitter.

See the [JWT-based authentication guide](/authentication/user-authentication/jwt-based-auth) for more information.

## Integrating with Privy's native authentication methods

Privy's authentication system provides secure user verification out of the box while maintaining a seamless experience. Privy supports multiple verification methods to accommodate different user needs and security requirements:

* Email and phone verification using one-time passwords (OTPs) [Learn more](/authentication/user-authentication/login-methods/email) {/* spellchecker:disable-line */}
* Social authentication through OAuth2.0 with providers like Google, Apple, Twitter, Discord, Github, TikTok, LinkedIn, Spotify, and Instagram [Learn more](/authentication/user-authentication/login-methods/oauth)
* Sign In With Ethereum (SIWE) and Sign in with Solana (SIWS) for web3-native users [Learn more](/authentication/user-authentication/login-methods/wallet)
* Custom authentication methods to match your specific needs

We do not support regular password-based verification given [users' tendencies to use and reuse easy-to-guess passwords](https://blog.lastpass.com/2021/09/breaking-the-cycle-of-password-reuse/), and the [high incidence of password database breaches](https://haveibeenpwned.com/).

## Token architecture

Upon successful authentication, Privy issues two types of tokens that work together to maintain secure user sessions.

**Access token**

The access token is a [JWT (JSON Web Token)](https://jwt.io/introduction) signed by an asymmetric Privy Ed25519 key specific to your app. This signature cryptographically ensures that only Privy could have produced the token - it cannot be spoofed or tampered with. The token has a **one-hour lifetime**, limiting the impact of potential token exposure and enabling quick session revocation if needed.

Your backend can use this token to [validate authenticated requests](/authentication/user-authentication/access-tokens) from users, and the Privy SDK uses it to determine authentication status in your frontend.

**Refresh token**

To provide longer sessions without compromising security, the refresh token has a **30-day lifetime** but can only be used once. When used to obtain a new access token, it's automatically rotated. This ensures refresh tokens can only renew existing sessions, never create new ones.

<Warning>
  If the Privy SDK detects any token tampering, it immediately invalidates the session and requires
  re-authentication. This destroys the corresponding session in Privy's backend.
</Warning>

## Session security

Our authentication system includes several security enhancements to protect user sessions. When using a verified domain, tokens can be stored in **HttpOnly cookies** for enhanced protection against XSS attacks. All tokens are cryptographically signed and verified on both client and server.

The Privy SDK manages this complexity for you, handling token rotation, renewal, and invalidation automatically. Your backend can easily [validate authenticated requests](/authentication/user-authentication/access-tokens) using the provided access tokens.

<Tip>
  Learn more about configuring secure authentication for your application in our [security
  checklist](/security/implementation-guide/security-checklist).
</Tip>


# Guidance for Content Security Policies (CSPs)
Source: https://docs.privy.io/security/implementation-guide/content-security-policy



<Info>New to CSPs? [Skip to CSP Basics](#csp-basics) for an introduction.</Info>

If you are using Privy in a web client environment, we recommend setting a strict [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) as a defense-in-depth strategy to mitigate XSS, clickjacking, and cross-site leak vulnerabilities.

## Quick start

<Tip>
  Remember to add your own domain to the relevant directives (e.g., add your domain to
  `connect-src`, `script-src`, etc.)
</Tip>

### Base CSP configuration

<Tabs>
  <Tab title="Raw CSP">
    ```
    Content-Security-Policy:
      default-src 'self';
      script-src 'self' https://challenges.cloudflare.com;
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: blob:;
      font-src 'self';
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
      child-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org;
      frame-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org https://challenges.cloudflare.com;
      connect-src 'self' https://auth.privy.io wss://relay.walletconnect.com wss://relay.walletconnect.org wss://www.walletlink.org https://*.rpc.privy.systems https://explorer-api.walletconnect.com;
      worker-src 'self';
      manifest-src 'self'
    ```
  </Tab>

  <Tab title="Next.js">
    ```js
    const nextConfig = {
      async headers() {
        return [
          {
            source: "/:path*",
            headers: [
              {
                key: "Content-Security-Policy",
                value: `
                  default-src 'self';
                  script-src 'self' https://challenges.cloudflare.com;
                  style-src 'self' 'unsafe-inline';
                  img-src 'self' data: blob:;
                  font-src 'self';
                  object-src 'none';
                  base-uri 'self';
                  form-action 'self';
                  frame-ancestors 'none';
                  child-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org;
                  frame-src https://auth.privy.io https://verify.walletconnect.com https://verify.walletconnect.org https://challenges.cloudflare.com;
                  connect-src 'self' https://auth.privy.io wss://relay.walletconnect.com wss://relay.walletconnect.org wss://www.walletlink.org https://*.rpc.privy.systems https://explorer-api.walletconnect.com;
                  worker-src 'self';
                  manifest-src 'self'
                `,
              },
            ],
          },
        ];
      },
    };
    ```
  </Tab>

  <Tab title="Express">
    ```js
    const helmet = require("helmet");

    app.use(
      helmet.contentSecurityPolicy({
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "https://challenges.cloudflare.com"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          imgSrc: ["'self'", "data:", "blob:"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          baseUri: ["'self'"],
          formAction: ["'self'"],
          frameAncestors: ["'none'"],
          childSrc: [
            "https://auth.privy.io",
            "https://verify.walletconnect.com",
            "https://verify.walletconnect.org",
          ],
          frameSrc: [
            "https://auth.privy.io",
            "https://verify.walletconnect.com",
            "https://verify.walletconnect.org",
            "https://challenges.cloudflare.com",
          ],
          connectSrc: [
            "'self'",
            "https://auth.privy.io",
            "wss://relay.walletconnect.com",
            "wss://relay.walletconnect.org",
            "wss://www.walletlink.org",
            "https://*.rpc.privy.systems",
            "https://explorer-api.walletconnect.com",
          ],
          workerSrc: ["'self'"],
          manifestSrc: ["'self'"],
        },
      })
    );
    ```
  </Tab>

  <Tab title="Ruby on Rails">
    ```ruby
    Rails.application.config.content_security_policy do |policy|
      policy.default_src :self
      policy.script_src :self, "https://challenges.cloudflare.com"
      policy.style_src :self, :unsafe_inline
      policy.img_src :self, :data, :blob
      policy.font_src :self
      policy.object_src :none
      policy.base_uri :self
      policy.form_action :self
      policy.frame_ancestors :none
      policy.child_src "https://auth.privy.io",
                      "https://verify.walletconnect.com",
                      "https://verify.walletconnect.org"
      policy.frame_src "https://auth.privy.io",
                      "https://verify.walletconnect.com",
                      "https://verify.walletconnect.org",
                      "https://challenges.cloudflare.com"
      policy.connect_src :self,
                        "https://auth.privy.io",
                        "wss://relay.walletconnect.com",
                        "wss://relay.walletconnect.org",
                        "wss://www.walletlink.org",
                        "https://*.rpc.privy.systems",
                        "https://explorer-api.walletconnect.com"
      policy.worker_src :self
      policy.manifest_src :self
    end
    ```
  </Tab>
</Tabs>

## CSP recommendations

### CSP directives for @privy-io/react-auth

As part of enforcing a CSP, you will need to allow certain trusted resources that your site needs to load as part of normal operation:

<Info>
  If you have a base domain enabled, you must **also** add your domain-specific Privy instance, e.g.
  `https://privy.your-base-domain.com`.
</Info>

#### Required domains

* `child-src`
  * [https://auth.privy.io](https://auth.privy.io) (Privy iframe)
  * [https://verify.walletconnect.com](https://verify.walletconnect.com) (WalletConnect iframe)
  * [https://verify.walletconnect.org](https://verify.walletconnect.org) (WalletConnect fallback iframe)
* `frame-src`
  * [https://auth.privy.io](https://auth.privy.io) (Privy iframe)
  * [https://verify.walletconnect.com](https://verify.walletconnect.com) (WalletConnect iframe)
  * [https://verify.walletconnect.org](https://verify.walletconnect.org) (WalletConnect fallback iframe)
  * [https://challenges.cloudflare.com](https://challenges.cloudflare.com) (Cloudflare Turnstile CAPTCHA iframe)
* `connect-src`
  * [https://auth.privy.io](https://auth.privy.io) (Privy API)
  * wss\://relay.walletconnect.com (WalletConnect API)
  * wss\://relay.walletconnect.org (WalletConnect fallback API)
  * wss\://[www.walletlink.org](http://www.walletlink.org) (Coinbase Wallet API)
  * https\://\*.rpc.privy.systems (Privy RPC provider)
  * [https://explorer-api.walletconnect.com](https://explorer-api.walletconnect.com) (WalletConnect Explorer API)
* `script-src`
  * [https://challenges.cloudflare.com](https://challenges.cloudflare.com) (Cloudflare Turnstile CAPTCHA scripts)

#### Optional features

If your app uses Telegram login or linking, add:

* `frame-src`: [https://oauth.telegram.org](https://oauth.telegram.org) (Telegram OAuth domain)
* `script-src`: [https://telegram.org](https://telegram.org) (Telegram login domain)

If your app uses Privy's [funding kit](/wallets/funding/overview), add:

* `connect-src`:
  * [https://api.relay.link](https://api.relay.link) (Relay Bridging Provider)
  * [https://api.testnets.relay.link](https://api.testnets.relay.link) (Relay Bridging Provider for testnets)

If your app is on Solana, please add the [Solana cluster endpoints](https://solana.com/docs/core/clusters#on-a-high-level) if an override is not provided:

* `connect-src`:
  * [https://api.mainnet-beta.solana.com](https://api.mainnet-beta.solana.com)
  * [https://api.devnet.solana.com](https://api.devnet.solana.com)
  * [https://api.testnet.solana.com](https://api.testnet.solana.com)

## Best practices

1. **Start strict**: Begin with restrictive policies, and loosen only as needed. Document all exceptions.
2. **Test regularly**: Test your CSP after dependency updates and validate during deployments. Check compatibility across different browsers.
3. **Monitor**: Track violation reports and monitor performance impact. Watch for bypass attempts.
4. **Document changes and procedures**: Record all CSP changes and document allowed sources. Document testing procedures for your app.

## Testing and deployment

<Tip>
  We highly recommend testing your CSP thoroughly before deploying and enforcing in production.
</Tip>

### Test your CSP in a staging environment

Run through your standard user flows in a **staging** environment with CSP enforcement. This may mean connecting to browser extension wallets / mobile app wallets, transacting, logging out, etc.

It is possible that directives need to be updated after Privy SDK upgrades. **Whenever upgrading the Privy SDK, always test your CSP again before deploying the update to production.**

Other software you use, such as [MetaMask](https://docs.metamask.io/wallet/how-to/get-started-building/secure-dapp/), may document their own guidance on CSP usage.

### Using Report-Only mode

Most browsers support a [`Content-Security-Policy-Report-Only`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only) header, which sends violation reports without actually enforcing policies. This allows the developer to judge whether a modification to their CSP will impact their site's expected functionality.

If your policy is strict, you will see many reported violations due to extensions trying to inject scripts into the browser. This is completely normal. It's best to filter these out to avoid the noise.

### Deployment

We recommend that you first deploy your CSP in ` report-only` mode with the header `Content-Security-Policy-Report-Only`. Once it has been validated in production, you can migrate to `Content-Security-Policy`, which will enforce directive violations.

Going forward, you can deploy with both `Content-Security-Policy-Report-Only` and `Content-Security-Policy` headers set simultaneously. This will allow you to test on the report only header and A/B test against your existing policy.

### Monitoring

We recommend that you configure the `report-uri` to see violation/enforcement reports and set up a monitoring dashboard so you can review reports.

## CSP basics

A Content Security Policy (CSP) is a set of rules that tell the browser **what sources of content are valid.** CSPs help prevent the browser from executing malicious scripts. They can be used to increase the security of any website.

To enable a CSP, you need to configure your web server or backend application to return the `Content-Security-Policy` HTTP header. In that header, you specify a policy. A policy is described using a set of policy directives, each of which tells the browser what to do with respect to a given resource type.

### Example: `img-src` directive

For example, the `img-src` directive tells the browser sources of images are valid.
If you set this CSP header:

```
Content-Security-Policy: img-src https://my-website.com/
```

Then any `<img>` from other sites will be blocked:

```
<img src="https://bad-website.com/image.jpg"/>   {/* Error! This won't load! */}
```

### Important directives

Policy directives tell the browser what to do for a given resource type.

* Keep `script-src` as locked down as possible to prevent malicious code execution
* Set `frame-ancestors` to `none` unless you expect your website to be embedded
* Keep `connect-src` as locked down as possible to prevent unauthorized data exfiltration
* Use `child-src` and `frame-src` to control iframe loading and execution
* Consider `worker-src` if using web workers
* Implement `default-src` as a fallback for unlisted directives

### Read the following guides to learn more:

* [https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
* [https://cheatsheetseries.owasp.org/cheatsheets/Content\_Security\_Policy\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)


# Security checklist
Source: https://docs.privy.io/security/implementation-guide/security-checklist



Privy is a powerful library that enables you to provision powerful non-custodial embedded wallets in order to create delightful user experiences. Privy protects your users' accounts and wallets via secure account verification, session management, and key sharding cryptography. See the [architecture security documentation](/security/wallet-infrastructure/architecture) for more information.

Before deploying Privy in production, there are several important security configurations to consider. Beyond this, security is a comprehensive topic that touches every part of your stack.

## Secure your client environment

Because your application client provides the context in which users access their accounts, it is an essential environment to keep secure. Follow client-side security best practices, including limiting what is able to inject Javascript into your site. **You should make sure only the code you intend runs in your app.**

### Web integrations

If you use Privy in your web application, including mobile web, we recommend configuring the following security settings.

#### Restrict allowed domains

Configure your allowed domains to prevent unauthorized access to your Privy integration.

* Add your production domain in the [Configuration > App settings page](https://dashboard.privy.io/apps?setting=domains\&page=settings) of the Privy Dashboard. [Learn more](/recipes/dashboard/allowed-domains)
* Remove any test or development domains

<Info>
  Using domains not configured in your allowed domains list will cause your integration to fail.
  This is an important security measure that protects your users.
</Info>

#### Configure HttpOnly cookies

To enable HttpOnly cookies for enhanced security, you can verify your domain ownership through a simple setup process in the Privy dashboard. [Learn more](/recipes/dashboard/allowed-domains)

#### Security headers

Configure proper security headers:

* Implement a strict [Content Security Policy](/security/implementation-guide/content-security-policy)
* Configure appropriate CORS settings
* Set secure cookie attributes when using HttpOnly cookies

### Mobile integrations

If you use Privy in your native mobile application, we recommend configuring the following security settings.

#### Restrict allowed native app IDs

Set your mobile project's bundle identifier as the required native app identifier.

## Set up authentication

If you have integrated user authentication with Privy wallet infrastructure, we recommend the following authentication settings. **Authentication security starts with choosing appropriate methods for your application.** Consider your users' needs and security requirements when configuring these settings. Read more about our [authentication architecture](/security/authentication/user-authentication).

### **Login methods**

For high-value applications, we recommend that you:

* Disable SMS-based authentication to prevent SIM-swapping attacks
* Enable strong [MFA](/authentication/user-authentication/mfa#mfa) options like authenticator apps or passkeys
* Configure appropriate session duration. The default is 30 days. You can do this using [app clients](/basics/get-started/dashboard/app-clients)

<Info>
  These security settings can be configured in your Privy dashboard. The defaults are chosen to
  balance security and user experience, but you may want to adjust them based on your specific
  needs.
</Info>

### **OAuth configuration**

If using social login, ensure proper configuration:

* Set up [allowed OAuth redirect URLs](/recipes/react/allowed-oauth-redirects)
* Review OAuth scopes and permissions
* Enable only necessary social providers
* Monitor OAuth token security

## Protect your wallets

Wallet security requires careful consideration of your specific use case and threat model. Learn more about our [wallet security architecture](/security/wallet-infrastructure/architecture).

### Embedded wallets

For wallets that users interact with directly through your application, we recommend enabling increasingly strict security settings as account value increases.

#### **High-value assets**

When protecting significant value, implement multiple security layers:

* Require [MFA](/authentication/user-authentication/mfa#mfa) for all sensitive operations
* Enable user-managed [recovery](/wallets/advanced-topics/new-devices/provision-new-devices) through password or cloud backup
* Set up emergency contacts and procedures

#### **Standard use cases**

For typical wallet usage:

* Enable users to optionally configure [MFA](/authentication/user-authentication/mfa#mfa)
* Configure automatic recovery with appropriate login methods
* Implement user education about security best practices

### Secure server-controlled wallets

#### Authorization keys

Set an owner on the wallet to add an additional layer of security for transaction signing. This means your transaction requests must be authorized with two factors: 1) your Privy app secret and 2) a signature from an [authorization key](/controls/authorization-keys/overview), which is a cryptographic key that only your service has access to.
Once this is set up, implement key management controls:

* Use a hardware-backed KMS (key management system) such as AWS KMS to secure authorization keys. Hardware-backed KMS systems disallow any export of keys.
* We recommend rotating authorization keys regularly, by updating the owner on wallets to a new key on a regular basis (every 90-180 days).
* You can further segregate wallets by setting different keys as the owner on different wallets. This means a given authorization key may only transact on one or a subset of wallets.
* You can require additional authorization for transactions, by requiring a quorum of authorization keys to approve a transaction. For example, you may set a 2-of-2 key quorum as the owner of a wallet: one key held in a KMS, and one key held by your service.
* We strongly recommend backing up authorization keys for redundancy. Privy does not have access to authorization keys and cannot recover your authorization key if you lose it.

#### Least privilege access

**Recommended Security Practice**: A powerful security control your application can implement is to separate the keys used for transaction signing from the keys used for [policy management](/controls/policies/overview). This ensures that even if your backend is compromised and transaction signing keys are exposed, the attacker cannot modify or remove the policies that constrain the wallet's behavior.

To implement this separation:

1. Create two different signing keys: one for **managing wallets and policies** and one for **transaction signing**

   * The management key should be used rarely and only be accessed in a very restricted environment
   * The transaction signing key will be used frequently and will accessed by your core application

2. When creating a wallet or policy, set the management key as the `owner`, which will make its signature required for any updates

3. On your wallet, set your transaction signing key and the policy it is subject to as an [`additional_signer`](/api-reference/wallets/create#body-additional-signers)

This creates a robust security boundary where:

* Transaction signing keys can only operate within policy constraints
* Policy management keys are rarely used and can be stored with higher security
* A compromise of transaction signing infrastructure cannot escalate to policy modification

<Info>
  The keys above can be quorums (e.g., 2-of-3 keys), providing additional security through
  multi-party authorization requirements.
</Info>

Learn more about implementing policies in our [policy overview documentation](/controls/policies/overview).

#### Other security recommendations

In addition to securing your server-controlled wallets with authorization keys, we also recommend the following:

* Set a [policy](https://docs.privy.io/controls/policies/overview) on the wallet to limit the types of transactions that may be processed.
* Monitor API usage and implement rate limiting
* Set up alerts for unusual activity
* Use separate development and production credentials
* Implement proper logging and audit trails


# Security
Source: https://docs.privy.io/security/overview



**The security of your users' data and digital assets is our top priority at Privy.** We secure over 50 million users' wallets and have facilitated billions of dollars in transaction value through our secure, flexible infrastructure.

<Tip>
  Privy wallets are non-custodial and have a fully programmable control model. Privy's flexible
  configuration enables the full spectrum from user-custodial wallets to powerful service-level
  controls.
</Tip>

## Our security approach

At Privy, we've built our security foundation on unwavering principles. Our systems are non-custodial by design, ensuring that only authorized users can access their keys through sophisticated key splitting and secure execution environments. We implement defense in depth, with multiple independent security boundaries protecting your users' assets—from cryptographic guarantees to hardware-level isolation.

<Info>
  We believe security requires constant vigilance. We maintain continuous validation through regular
  third-party audits, an active bug bounty program, and 24/7 security monitoring to ensure our
  systems remain secure as threats evolve.
</Info>

## Core architecture

The strength of Privy's security comes from our battle-tested approach to protecting sensitive operations and data:

**Key sharding and cryptography**

We use robust, scalable cryptographic techniques to shard private keys, ensuring they are never stored in complete form and can only be accessed by authorized parties.

**Secure execution environments**

Every sensitive operation in our system takes place within strictly isolated environments:

* **Client-side operations** execute on user devices in browser-enforced iframes, which provide the same security boundaries that protect the most sensitive online applications, including identity and banking.
* **Server-side operations** execute in Trusted Execution Environments (TEEs), also known as secure enclaves, offering deep system isolation guaranteed by the processor itself.

<Tip>
  These environments ensure sensitive operations remain protected even if the surrounding system is
  compromised.
</Tip>

## Security validation

We regularly validate our security through comprehensive assessments:

* Multiple independent security audits from firms including Cure53, Zellic, and Doyensec
* SOC2 Type I and Type II certified
* Active bug bounty program on HackerOne
* 24/7 incident response with rapid response SLAs

<Info>
  Our commitment to security extends to transparency—our cryptographic implementations are
  open-source and have undergone dedicated third-party audits, available on our [GitHub
  repository](https://github.com/privy-io/shamir-secret-sharing).
</Info>

## Getting started

Our documentation will guide you through implementing Privy securely in your application. We recommend starting with our [security checklist](/security/implementation-guide/security-checklist) for a complete overview of security best practices, or diving into our [architecture details](/security/wallet-infrastructure/architecture) to learn more about our security model.

<Tip>
  Security researchers can learn more about our vulnerability disclosure program at
  [privy.io/vulnerability-disclosure](https://www.privy.io/vulnerability-disclosure) or reach out to
  [security@privy.io](mailto:security@privy.io).
</Tip>


# Threat models & security FAQ
Source: https://docs.privy.io/security/security-faqs



Threat models are an essential part of building secure systems. Establishing a threat model means understanding the robustness of a system against a given attacker and context. At Privy, we work to communicate these threat models clearly so developers and users can protect themselves and their assets effectively. We break down some threat models below. Please reach out to us at [security@privy.io](mailto:security@privy.io) if you have any questions.

As a reminder, Privy works to secure user assets and data in three main ways:

* **Proactive security**: Privy systems are engineered and built with security in mind. This means resource isolation and [cryptographic architecture](/security/overview) layered with a defense-in-depth approach, designed to protect your wallets. This also means doing cryptographic and infrastructure audits on a quarterly basis, as well as running a Vulnerability Disclosure Program and active Bug Bounty Program.
* **Active monitoring**: Privy systems are instrumented for active monitoring. This means automated alerts triggered by unexpected or abnormal activity and an on-call engineering team on standby 24/7. As our customers deploy apps, we work to monitor activity across the threat landscape online and collaborate with service providers to take down malicious threats.
* **Defensive measures**: Privy is built with failsafes to enable developers and their users to cut off access to key material in the event of an emergency. We work on pre-approved procedures for such instances with our enterprise customers and are always at the ready to protect user assets in the case of attack.

If you're a researcher interested in participating in our Bug Bounty or you believe you've detected a malicious threat relevant to Privy's work, please reach out to [security@privy.io](mailto:security@privy.io).

## Security philosophy

Security is continuous work, not a one-time achievement. We recognize that [wallets are not one size fits all](https://www.privy.io/blog/metrocards-and-bank-vaults), and we build highly configurable, flexible wallet infrastructure so you can configure the system appropriate for your use-case. Moreover, security needs evolve as asset value grows.

We give developers flexibility to build appropriate experiences while guiding them toward security best practices. We support the full spectrum from email-based embedded wallets to hardware-secured cold storage, recognizing the [inherent tradeoffs](https://www.privy.io/blog/embedded-wallet-architecture-breakdown) in any cryptosystem.

## Understanding threat models

The below summarizes some key questions but is not exhaustive. Please reach out for a deeper discussion on threat modeling or other attack strategies.

### Cross-application security

#### Q: Can unauthorized applications access the Privy iframe?

No. The iframe enforces that all frame ancestors must be an [allowed origin](/recipes/dashboard/allowed-domains) set by an application admin within the Privy dashboard. This is enforced by both frame ancestor CSP checks and in-code origin validation.

#### Q: Can unauthorized applications send messages to the Privy iframe?

No. The Privy iframe only accepts messages from its parent frame. The iframe message handler checks the origin of messages received and confirms they are from an approved parent origin. Additionally, the Privy iframe requires a valid access token to authenticate messages received from its parent frame.

#### Q: Can a Privy customer's application interfere with another customer's iframe?

No. Browser controls and authentication controls enforce isolation between applications. Iframe contexts run in separate processes and does not share memory.

### User security

#### Q: Can an unauthorized user access another user's wallet?

No. A valid access token is required to access a wallet. Specifically, the user's access token is required to retrieve the auth share needed to reconstruct the wallet. Access tokens are only granted to authenticated users and are stored as either localStorage or [HttpOnly cookies](/recipes/dashboard/allowed-domains#httponly-cookies) depending on configuration.

#### Q: How are users protected if their browser is compromised?

We implement multiple protections:

* Keys never are persisted in complete form
* MFA can be required for wallet operations
* Transaction approval requires the auth share which is not stored on device
* Emergency controls can immediately disable key reconstruction
* Recovery shares can be secured by user-managed methods

### Browser security

#### Q: Can bookmarklets and browser extensions inject malicious Javascript into the iframe?

In certain cases, yes. There is a CSP nonce on the embedded wallet iframe and the embedded wallet key export page. This means browsers are able to verify the iframe code via a server-set nonce, and additionally reject unauthorized code. We block extensions with CSPs that violate the unsafe eval directive.

However, it's important to understand that bookmarklets and extensions have elevated permissions and may have access to things such as browser requests and responses. According to the W3C CSP standard, browser implementations should allow user-agent features to override policies. Browsers enable bookmarklets and extensions to bypass CSP settings and inject Javascript code onto pages. We recommend educating users to not install untrusted bookmarkets and browser extensions. Furthermore, we recommend enabling wallet MFA which requires the user to MFA to approve transactions.

#### Q: What happens if browser security is compromised?

We maintain multiple layers of protection:

* Emergency kill switches for immediate response
* Access token revocation capabilities
* Geographic access restrictions
* Rapid incident response procedures
* Regular security updates

### Infrastructure security

#### Q: Can a compromised Privy team member access user keys?

No. Keys exist only as encrypted shares distributed across security boundaries. Wallet actions are only accessible within secure execution environments.

#### Q: Can a compromised engineer deploy unauthorized code?

No. Privy maintains a robust deployment security system with multiple independent controls. Code deployed to secure execution environments undergo extensive review and security controls, including strict multi-party approvals.

All code changes require review from multiple designated owners, must pass automated security testing, and go through staged deployments with additional approvals. The Privy CI/CD pipeline ensures build artifacts are deployed directly from protected source code, with branch protection rules and signing requirements. This process is regularly audited and monitored to prevent unauthorized modifications.

<Tip>
  For security questions not covered here or to report a security concern, contact us at
  [security@privy.io](mailto:security@privy.io). If you're a security researcher interested in our Bug Bounty Program, please
  reach out to the same address.
</Tip>


# Security architecture
Source: https://docs.privy.io/security/wallet-infrastructure/architecture



Privy's security architecture combines distributed key sharding with secure execution environments to protect your users' assets. Simply put:

* Keys are only stored as **encrypted shares distributed across separate security boundaries.**
* Keys are only **temporarily reconstructed within secure execution environments** when needed for specific operations, under the wallet owner's control.

## Core security model

Every sensitive cryptographic operation in Privy occurs within a secure execution environment—an isolated context with strict security guarantees. Whether running in a browser-enforced iframe or hardware-secured enclave, these environments ensure private keys are protected throughout their lifecycle.

When a user creates a wallet, the secure execution environment generates strong entropy (128 bits) from a cryptographically secure random number generator (CSPRNG). This is converted to a mnemonic using BIP-39, from which Privy derives the wallet's public key and private key. All Privy wallets are [hierarchical deterministic (HD) wallets](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).

Immediately after creation, the wallet entropy is sharded into key shares, and the key shares are encrypted and distributed across separate security boundaries. This ensures that wallets can never be accessed outside of the secure execution environment.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/key-shares.png" alt="Secure Key Management" />
</Frame>

<Info>
  Private keys only exist in complete form temporarily within secure execution environments during
  signing operations. At all other times, they remain split into encrypted shares stored across
  separate security boundaries.
</Info>

## Concepts

### Secure execution environments

Secure execution environments are processing containers with strong isolation properties. These environments protect sensitive operations even if the host system is compromised.

Privy provides two types of secure execution environments that protect sensitive operations through multiple independent security boundaries. Each environment ensures that private keys are never stored in complete form and are only temporarily reconstructed when needed.

#### Secure environments on user devices

To secure wallets directly on user devices, Privy uses browser-enforced isolation via iframes. This leverages the browser security boundaries that have been battle-tested for decades, securing billions of dollars in daily financial transactions across the modern internet.

When wallets are secured on-device, all key operations happen directly on the user's device, and signature generation is extremely fast (20 ms). [Learn more](/security/wallet-infrastructure/secure-execution-environments/user-device).

#### Trusted execution environments

Privy offers full wallet functionality via a REST API, secured using [trusted execution environments (TEEs)](https://en.wikipedia.org/wiki/Trusted_execution_environment).

TEEs are highly restricted, isolated compute environments that allow for secure code execution in a server environment. This enables API-level flexibility and programmable server-side controls. [Learn more](/security/wallet-infrastructure/secure-execution-environments/secure-enclave).

<Info>
  You can choose which secure execution environment to use to provision wallets. **By default, Privy provisions self-custodial user wallets directly on user devices, secured by browser-enforced isolation.**

  Alternatively, you can integrate Privy's powerful APIs directly to configure TEE-secured wallets with fully flexible controls.
</Info>

### Key share management

Privy's security model is based on distributed key sharding. This means critical key entropy is split into encrypted shares stored across separate security boundaries.

Key sharding enables future-proof flexibility, strict security isolation, and built-in recovery.

* In particular, key sharding enables separate authentication and encryption of each distributed share, enforcing control by wallet owners.
* Beyond this, key sharding makes it possible to configure backups and redundancy so you and your users always have access to their keys, even if Privy is not available.

Key sharding and assembly only ever occur within the secure execution environment. Private keys are split into encrypted shares using a reliable, battle-tested, and fast cryptographic algorithm called [Shamir's secret sharing (SSS)](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing). No share in isolation provides any information or access to the wallet.

<Info>
  Privy's [`shamir-secret-sharing`](https://github.com/privy-io/shamir-secret-sharing) cryptography
  library is open-source, heavily audited, and used to secure millions of user accounts. It is the
  most widely used open-source Typescript library for Shamir's secret sharing.
</Info>

There are three share types, protected by different security boundaries:

* **Device/enclave share**: Encrypted and secured directly by the secure execution environment, on user's device or by the secure enclave (TEE). In client web integrations, this device share is stored in the browser's domain-partitioned local storage, on the user's device. In direct API integrations, the TEE serves as the user's remote device.

* **Auth share**: Encrypted and stored by Privy, accessible only with valid authentication through a secure execution environment.

In the case of on-device secure execution environments, the **recovery share** is used to provision the wallet on new user devices. This share is encrypted and secured either through user-managed methods (password or cloud backup) or Privy's recovery key management system.

Two shares must be present to reconstruct the private key, which only happens temporarily within secure execution environments. By default, a device-specific share and an auth share are provisioned for each device on which a wallet is used.

## Secure operations

Wallet private keys only exist in-memory within the secure execution environment, e.g. the isolated iframe or TEE. The private key does not persist past the secure execution environment's lifetime.

This process ensures:

* Keys exist only as encrypted shares stored across separate security boundaries
* Shares are only combined temporarily within the secure environment for specific operations
* Network access is strictly controlled
* Every operation requires proper authentication

Read more about key reconstitution on [user devices](/security/wallet-infrastructure/secure-execution-environments/user-device) and in [trusted execution environments](/security/wallet-infrastructure/secure-execution-environments/secure-enclave).

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/secure-shares.png" alt="Secure Key Management" />
</Frame>

## Protecting code deployments to secure execution environments

Privy enforces strict controls of the code deployments within these environments. Code deployed to secure execution environments undergo extensive review and security controls, including strict multi-party approvals.

All code changes require review from multiple designated owners, must pass automated security testing, and go through staged deployments with additional approvals. The Privy CI/CD pipeline ensures build artifacts are deployed directly from protected source code, with branch protection rules and signing requirements. This process is regularly audited and monitored to prevent unauthorized modifications.


# Wallet policies and controls
Source: https://docs.privy.io/security/wallet-infrastructure/policy-and-controls



Privy's wallet API is secured with tamper-proof cryptographic authorization and a powerful, intuitive policy engine. This means that the secure enclave will only act on requests issued by authorized parties, and only specific permitted actions may be processed.

<Tip>
  Privy wallets are non-custodial and have a fully programmable control model. Privy's flexible
  configuration enables the full spectrum from user-custodial wallets to powerful service-level
  controls.
</Tip>

## Authentication and authorization

### Authorization keys

Requests to Privy [wallet API](/security/wallet-infrastructure/secure-execution-environments/secure-enclave) endpoints are protected by **authorization keys**. This requires the secure enclave to verify a signature from the required authorization key before executing any requests. [Learn more](/controls/authorization-keys/overview)

Privy uses [P-256](https://neuromancer.sk/std/nist/P-256) (also known as secp256r1) asymmetric keys for authorization keys. When you register a key:

* The private key is generated on your device, and is only ever known to your app. **Neither Privy nor the enclave ever sees the P-256 private key, and cannot sign payloads with it.**
* The public key is registered with the enclave, and is used to verify signatures produced by your servers.

If an authorization key is required for a wallet, the enclave will require that your servers sign the request payload for any wallet action (e.g. signing a message) with the authorization private key for your app. The enclave will verify the signature against the corresponding authorization public key registered for your app before executing any wallet actions.

### Powerful, flexible controls

Authorization keys enable a fully configurable control model for wallets. This includes the full spectrum from user-custodial wallets to powerful service-level controls.

When you create a wallet, you specify its **owner**, which is the key (or key quorum) that controls the wallet. By default, this key is also required to authorize wallet actions, such as generating signatures or transacting funds.

This wallet ownership model is extremely flexible. It enables you to configure, e.g:

* **Fully user self-custodial wallets**, using an [authenticated signer](/security/authentication/authenticated-signers) as the authorization key
* **Fully user self-custodial wallets**, using a user's passkey as the authorization key
* **Service-controlled wallets**, using an authorization key that is held by your service
* **Multi-sig wallets**, using a quorum of authorization keys held by different parties

### Key quorums

Privy enables your app to require quorum approvals on wallet actions, so that signatures from m-of-n authorization keys are required in order to take action using the wallet. Key quorums are defined by a list of authorization public keys and a threshold required for approval. [Learn more](/controls/quorum-approvals/overview)

### Multi-factor authentication

Privy enables native multi-factor authentication for wallet actions. This means your app can require additional verification for sensitive wallet operations using:

* Authenticator apps (TOTP)
* Biometric verification (passkeys)
* SMS confirmation
* Hardware security keys

Multi-factor authentication is enforced via [authenticated signers](/security/authentication/authenticated-signers). Learn more about configuring multi-factor authentication for your app [here](/authentication/user-authentication/mfa).

## Policies

Privy's policy engine allow your application to **restrict the actions that can be taken with wallets**. This is important for features such as payment subscriptions, stop and limit orders, or scheduled transactions.

Policies allows you to configure transfer limits, allow lists and deny lists of transfer recipients, allowlists and denylists of smart contracts and programs, and even constraints around calldata that can be passed to smart contracts.

By default, policies are enforced by the trusted execution environment as part of processing wallet actions, such as signature requests, transactions, and key export. Some policies are enforced at the API level. For example, limiting transfer sizes requires transaction simulation which runs outside the enclave today.

This ensures that wallets can only ever be used to take actions your application intends to take.

Learn more about configuring policies [here](/controls/policies/overview).

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/policy-splash.png" alt="Managing policies in the Privy Dashboard" />
</Frame>


# Trusted execution environments (TEEs)
Source: https://docs.privy.io/security/wallet-infrastructure/secure-execution-environments/secure-enclave



Privy provides two types of secure execution environments that protect sensitive operations through independent security boundaries: 1) on the user's device and 2) via TEEs in the server. Each environment ensures that private keys are never stored in complete form and are only temporarily reconstructed when needed.

For direct API access to wallet infrastructure, Privy enables secure server-side wallet actions via [trusted execution environments (TEEs)](https://en.wikipedia.org/wiki/Trusted_execution_environment).

<Tip>
  Privy wallets are non-custodial and have a fully programmable control model. Privy's flexible
  configuration enables the full spectrum from user-custodial wallets to powerful service-level
  controls.
</Tip>

## About trusted execution environments

Trusted execution environments (TEEs), also known as secure enclaves, are highly restricted, isolated compute environments that allow for secure code execution and cryptographic verification (attestation) of the code being executed. In particular, Privy uses [AWS Nitro Enclaves](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html).

Privy uses TEEs to support private key reconstitution for the following processor-level guarantees:

* Enclaves have no persistent storage, no interactive access, and no network connectivity, and so provide a secure, isolated compute environment for sensitive data. Private keys for wallets are only accessible within the enclave, and can only be used to produce signatures compliant with the policies attached to the wallet.
* Attestations are cryptographic verifications of the computation run on a TEE. They are signed hashes of code on a enclave that can be verified with the corresponding public key, and can be used to verify actions run within the TEE.

## Key shares

Privy's security model is based on distributed key sharding. This means critical key entropy is split into encrypted shares stored across separate security boundaries.

There are two share types, protected by different security boundaries:

1. **Enclave (device) share**, also referred to as the TEE share, which is secured directly by the trusted execution environment. This share is encrypted with the enclave's public key, and can only be decrypted within the TEE.
2. **Auth share**, which is encrypted and stored by Privy. This share is accessible only with valid authentication, and is sent to the enclave whenever an action is requested from the wallet.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/enclave-shares.png" alt="Trusted execution environment key shares" />
</Frame>

This is a **2-of-2** share set, which means that *both* shares are required in order to generate signatures. Neither the auth share nor the enclave share in isolation provide any information or access to the wallet.

<Tip>
  Only the TEE can decrypt the enclave share and combine it with the auth share to reconstitute the
  wallet and execute actions.
</Tip>

## Key management operations

### Creating a wallet

When a user creates a wallet, the secure execution environment generates strong entropy (128 bits) from a cryptographically secure random number generator (CSPRNG). This is converted to a mnemonic using BIP-39, from which Privy derives the wallet's public key and private key. All Privy wallets are [hierarchical deterministic (HD) wallets](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).

Immediately after creation, the wallet entropy is sharded into key shares, and the key shares are encrypted and distributed across separate security boundaries. This ensures that wallets can never be accessed outside of the secure execution environment.

### Signing a transaction

Two shares must be present to reconstruct the private key. During regular operation, Privy reassembles the wallet using a **device share** and **auth share**.

In other words, when signing a transaction:

1. Your app makes a `POST` request to the Privy API with the appropriate bearer token (typically the Privy app secret) and an authorization key signature.
2. Privy's backend authenticates the bearer token. If the request is valid, the request is forwarded to the TEE, along with the auth share.
3. The TEE verifies the authorization signature from your request against the authorization public key.
4. The TEE decrypts its encrypted device share and combines it with the auth share to reconstruct the wallet's private key.
5. The key is used temporarily in-memory for cryptographic signing.
6. The signature is returned to your application.

Privy also supports broadcasting the signed transaction to the blockchain, directly from the API.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/enclave-flow.png" alt="Transaction flow" />
</Frame>


# User device execution environment
Source: https://docs.privy.io/security/wallet-infrastructure/secure-execution-environments/user-device



Privy provides two types of secure execution environments that protect sensitive operations through independent security boundaries: 1) on the user's device and 2) via TEEs in the server. Each environment ensures that private keys are never stored in complete form and are only temporarily reconstructed when needed.

<Tip>
  By default, Privy embedded wallets are secured directly on the user's device and are fully
  self-custodial. Neither Privy nor integrating applications ever access embedded wallet private
  keys.
</Tip>

## About browser-isolated execution environments on user devices

Privy secures wallets directly on user devices using browser-enforced isolation via iframes. This relies on the same browser security boundaries that have been battle-tested for decades, securing billions of dollars in daily financial transactions across the modern internet.

The Privy iframe runs in a separate process with its own isolated memory space, completely separated from your application. This isolation is enforced by:

* Hardware-level memory protection
* Browser process separation
* Strict origin and frame ancestor validation
* Content Security Policy controls that strictly lock down network access

<Info>
  Browser security boundaries have been battle-tested for decades, securing billions of dollars in
  daily financial transactions across the modern internet.
</Info>

## Key shares

Privy's security model is based on distributed key sharding. This means critical key entropy is split into encrypted shares stored across separate security boundaries.

There are three share types, protected by different security boundaries:

* **Device share**, which is persisted on the user's device. In a browser environment, this is stored in the browser's domain-partitioned local storage via the iframe.
* **Auth share**, which is encrypted and stored by Privy. This share is accessible only with valid user authentication.

The **recovery share** is used to provision the wallet on new user devices. This share is encrypted and secured either through user-managed methods (password or cloud backup) or Privy's recovery key management system.

Two shares must be present to reconstruct the private key, which only happens temporarily within secure execution environments. A device-specific share and an auth share are provisioned for each device on which a wallet is used.

### Securing the recovery share

Privy offers two approaches to securing the recovery share:

**Automatic recovery**

Privy's key management system secures the encrypted recovery share, allowing users to provision their wallet on new devices through normal authentication. Privy infrastructure ensures only the user can decrypt their recovery share on their device.

<Warning>
  When using automatic recovery, you are trusting Privy's infrastructure to secure the user's
  recovery share, and the user's authentication token as the sole root of trust for their wallet.
</Warning>

**User-managed recovery**

With user-managed recovery, the recovery share is encrypted via a recovery factor managed by the user. This takes two forms:

* **Passwords**: users can set a strong memorable password to secure the recovery share for their wallet. Privy has no knowledge of the user's password and cannot decrypt the recovery share.
* **Cloud-backup**: the recovery share is secured by a recovery decryption key that is backed up to the user's cloud storage account (e.g. Google Drive or iCloud). Privy cannot access this backup and cannot decrypt the recovery share.

## Key management operations

### Creating a wallet

When a user creates a wallet, the secure execution environment generates strong entropy (128 bits) from a cryptographically secure random number generator (CSPRNG). This is converted to a mnemonic using BIP-39, from which Privy derives the wallet's public key and private key. All Privy wallets are [hierarchical deterministic (HD) wallets](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths).

Immediately after creation, the wallet entropy is sharded into key shares, and the key shares are encrypted and distributed across separate security boundaries. This ensures that wallets can never be accessed outside of the secure execution environment.

### Signing a transaction

Two shares must be present to reconstruct the private key. During regular operation, Privy reassembles the wallet using a **device share** and **auth share**. A device-specific share and an auth share are provisioned for each device on which a wallet is used.

In other words, when signing a transaction:

1. Your application passes the transaction data through the Privy SDK
2. The secure iframe validates authentication and retrieves necessary encrypted shares
3. Key reconstruction occurs only in the iframe's isolated memory
4. The key is used temporarily in-memory for cryptographic signing
5. Only the signature is returned to your application

Because Privy wallets are provisioned directly on user devices, cryptographic signing is extremely fast (20 ms).

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/secure-shares.png" alt="Signing a transaction" />
</Frame>

### Provision new devices

Users provision their wallet on a new device using the **recovery share** and **auth share**. This set of recovery shares is created on initialization of a new wallet.

When a user accesses your app on a new device, the iframe will retrieve the **auth share** for your user during the login process. Then, depending on how you've configured recovery, the iframe will decrypt the **recovery share** for your user by:

* requesting the recovery decryption key using the user's auth token, if using **automatic** recovery
* having the user decrypt the key using their recovery factor (password or cloud account), if using **user-managed** recovery

With the **auth share** and the **recovery share**, the iframe provisions a new **device share** for the new device. This device share allows your user to continue using the wallet on that device.

Learn how to provision new devices in our [docs](/wallets/advanced-topics/new-devices/overview).

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/security/recovery.png" alt="Provision a new device" />
</Frame>

## Key reassembly outside Privy

With Privy's architecture, a user is able to recover their private key even if they lose their device or if they lose access to your app.

* If the user loses access to their device and is unable to retrieve their **device share**, they can combine their **auth share** and decrypt their **recovery share** to reconstitute the full private key.
* If the user loses access to your app and is unable to retrieve their **auth share**, they can combine their **device share** and decrypt their **recovery share** to reconstitute the full private key.

In all of these cases, Privy rotates keys to ensure compromised devices or authentication methods cannot be combined to maliciously reconstitute the private key.


# null
Source: https://docs.privy.io/user-management/migrating-users-to-privy/import-a-batch-of-users



Privy allows you to import your users in batches via REST API to simplify the migration process. To import users, pass in an array of user objects which each represent a new user. You can also create wallets during import with wallet pregeneration.

Once a user has been imported into Privy, if they log in, all of their imported accounts (wallet, email, etc.) will be included in their user object. If the imported user has an embedded wallet, that wallet will be available to the user upon sign in.

<Tabs>
  <Tab title="REST API">
    Make a `POST` request to:

    ```sh
    https://auth.privy.io/api/v1/users/import
    ```

    In the body of the request, include a `users` field with an array of up to 20 user objects.

    Below is a **sample cURL command** for importing multiple new users into Privy:

    ```bash
    $ curl --request POST https://auth.privy.io/api/v1/users/import \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
       "users": [
           {
               "linked_accounts": [
                   {
                       "type": "email",
                       "address": "joker@gmail.com"
                   }
               ]
           },
           {
               "linked_accounts": [
                   {
                       "type": "wallet",
                       "chain_type": "ethereum",
                       "address": "0xd8da6bf26964af9d7eed9e03e53415d37aa96045"
                   }
               ]
           },
           {
               "linked_accounts": [
                   {
                       "type": "email",
                       "address": "robin@gmail.com"
                   }
               ]
           }
       ]
    }'
    ```

    ### Parameters

    <ParamField body="linkedAccounts" type="LinkedAccount[]" required>
      An array including all of the user's linked accounts. These objects are in the same shape as the
      linked accounts returned by [`getUser`](/user-management/users/managing-users/querying-users). For
      each linked account, you must specify the `type` and must not include a `verifiedAt` timestamp.

      <Accordion title="LinkedAccount types">
        <Accordion title="AppleAccount">
          | Field     | Type            | Description                                             |
          | --------- | --------------- | ------------------------------------------------------- |
          | `type`    | `'apple_oauth'` | N/A                                                     |
          | `email`   | `string`        | Email address associated with the user's Apple account. |
          | `subject` | `number`        | ID of user from Apple's user API.                       |
        </Accordion>

        <Accordion title="CustomJwtAccount">
          | Field                                            | Type            | Description                           |
          | ------------------------------------------------ | --------------- | ------------------------------------- |
          | `type`                                           | `'custom_auth'` | N/A                                   |
          | API: `custom_user_id` <br /> SDK: `customUserId` | `string`        | ID of user from custom auth provider. |
        </Accordion>

        <Accordion title="DiscordAccount">
          | Field      | Type              | Description                                                                                         |
          | ---------- | ----------------- | --------------------------------------------------------------------------------------------------- |
          | `type`     | `'discord_oauth'` | N/A                                                                                                 |
          | `subject`  | `string`          | ID of user from Discord user API response.                                                          |
          | `email`    | `string`          | Email of user from Discord user API response                                                        |
          | `username` | `string`          | Username of user from Discord user API response. Include the 4-digit discriminator prefixed by '#'. |

          (See [Discord docs](https://discord.com/developers/docs/resources/user))
        </Accordion>

        <Accordion title="EmailAccount">
          | Field     | Type      | Description                    |
          | --------- | --------- | ------------------------------ |
          | `type`    | `'email'` | N/A                            |
          | `address` | `string`  | Email address of user account. |
        </Accordion>

        <Accordion title="FarcasterAccount">
          | Field                                                      | Type          | Description                                                                                                                                             |
          | ---------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
          | `type`                                                     | `'farcaster'` | N/A                                                                                                                                                     |
          | `fid`                                                      | `number`      | FID of the user from Farcaster user API response.                                                                                                       |
          | API: `owner_address` <br /> SDK: `ownerAddress`            | `string`      | Wallet address of the user from Farcaster user API response. Note that this is the Farcaster wallet address, and not the Privy embedded wallet address. |
          | `username`                                                 | `string`      | (Optional) Username of user from Farcaster user API response. Do not include the '@'.                                                                   |
          | API: `display_name` <br /> SDK: `displayName`              | `string`      | (Optional) Display name of user from Farcaster user API response.                                                                                       |
          | `bio`                                                      | `string`      | (Optional) Bio of user from Farcaster user API response.                                                                                                |
          | API: `profile_picture_url` <br /> SDK: `profilePictureUrl` | `string`      | (Optional) Profile picture URL of the user from Farcaster user API response. Must be a valid image URL.                                                 |
          | API: `homepage_url` <br /> SDK: `homepageUrl`              | `string`      | (Optional) Profile URL of the user from Farcaster user API response.                                                                                    |

          (See [Farcaster docs](https://docs.farcaster.xyz/reference/hubble/httpapi/userdata#userdata-api). Note that the Privy import interface differs slightly from the Farcaster public interface in order to maintain consistency with other Privy **`LinkedAccount`** types.)
        </Accordion>

        <Accordion title="GithubAccount">
          | Field      | Type             | Description                                    |
          | ---------- | ---------------- | ---------------------------------------------- |
          | `type`     | `'github_oauth'` | N/A                                            |
          | `subject`  | `string`         | ID of user from GitHub user API response.      |
          | `email`    | `string`         | Email of user from GitHub user API response    |
          | `name`     | `string`         | Name of user from GitHub user API response     |
          | `username` | `string`         | Username of user from GitHub user API response |

          (See [GitHub docs](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28#get-the-authenticated-user))
        </Accordion>

        <Accordion title="GoogleAccount">
          | Field     | Type             | Description                                                |
          | --------- | ---------------- | ---------------------------------------------------------- |
          | `type`    | `'google_oauth'` | N/A                                                        |
          | `subject` | `string`         | `sub` pulled from Google-provided JWT with "openid" scope. |
          | `email`   | `string`         | `email` from Google-provided JWT with "email" scope.       |
          | `name`    | `string`         | `name` from Google-provided JWT with "profile" scope.      |
        </Accordion>

        <Accordion title="InstagramAccount">
          | Field      | Type                | Description                                                                 |
          | ---------- | ------------------- | --------------------------------------------------------------------------- |
          | `type`     | `'instagram_oauth'` | N/A                                                                         |
          | `subject`  | `string`            | ID of user from Instagram user API response.                                |
          | `username` | `string`            | The name displayed on a user's profile from Instagram's `/me` API response. |

          (See [Instagram docs](https://developers.facebook.com/docs/instagram-basic-display-api/reference/me/))
        </Accordion>

        <Accordion title="LinkedinAccount">
          | Field     | Type               | Description                                                           |
          | --------- | ------------------ | --------------------------------------------------------------------- |
          | `type`    | `'linkedin_oauth'` | N/A                                                                   |
          | `subject` | `string`           | ID of user from LinkedIn user API response.                           |
          | `email`   | `string`           | Email of user from LinkedIn user API response                         |
          | `name`    | `string`           | Name of user from LinkedIn user API response. Do not include the '@'. |

          (See [Linkedin docs](https://learn.microsoft.com/en-us/linkedin/consumer/integrations/self-serve/sign-in-with-linkedin-v2#api-request-to-retreive-member-details))
        </Accordion>

        <Accordion title="PhoneAccount">
          | Field    | Type      | Description                                                             |
          | -------- | --------- | ----------------------------------------------------------------------- |
          | `type`   | `'phone'` | N/A                                                                     |
          | `number` | `string`  | Phone number of user account (non-international numbers default to US). |

          While `number` is accepted as input, `phoneNumber` is returned in the response.
        </Accordion>

        <Accordion title="SpotifyAccount">
          | Field     | Type              | Description                                                                     |
          | --------- | ----------------- | ------------------------------------------------------------------------------- |
          | `type`    | `'spotify_oauth'` | N/A                                                                             |
          | `subject` | `string`          | ID of user from Spotify user API response.                                      |
          | `email`   | `string`          | Email of user from Spotify user API.                                            |
          | `name`    | `string`          | The name displayed on a user's profile from Spotify display\_name API response. |

          (See [Spotify docs](https://developer.spotify.com/documentation/web-api/reference/get-current-users-profile))
        </Accordion>

        <Accordion title="TelegramAccount">
          | Field            | Type         | Description                                                      |
          | ---------------- | ------------ | ---------------------------------------------------------------- |
          | `type`           | `'telegram'` | N/A                                                              |
          | `telegramUserId` | `string`     | ID of a user's telegram account.                                 |
          | `firstName`      | `string`     | The first name displayed on a user's telegram account.           |
          | `lastName`       | `string`     | (Optional) The last name displayed on a user's telegram account. |
          | `username`       | `string`     | (Optional) The username displayed on a user's telegram account.  |
          | `photo_url`      | `string`     | (Optional) The url of a user's telegram account profile picture. |

          (See [Telegram docs](https://core.telegram.org/widgets/login#checking-authorization))
        </Accordion>

        <Accordion title="TwitterAccount">
          | Field                                                   | Type              | Description                                                                                           |
          | ------------------------------------------------------- | ----------------- | ----------------------------------------------------------------------------------------------------- |
          | `type`                                                  | `'twitter_oauth'` | N/A                                                                                                   |
          | `subject`                                               | `string`          | ID of user from Twitter user API response.                                                            |
          | `name`                                                  | `string`          | Name of user from Twitter user API response                                                           |
          | `username`                                              | `string`          | Username of user from Twitter user API response. Do not include the '@'.                              |
          | API: profile\_picture\_url`<br/>`SDK: profilePictureUrl | `string`          | (Optional) Profile picture URL of the user from Twitter user API response. Must be a valid image URL. |

          (See [Twitter docs](https://developer.twitter.com/en/docs/twitter-api/users/lookup/api-reference/get-users-me#tab0))
        </Accordion>

        <Accordion title="SmartWalletAccount">
          | Field               | Type              | Description                                                                                             |
          | ------------------- | ----------------- | ------------------------------------------------------------------------------------------------------- |
          | `type`              | `'smart_wallet'`  | N/A                                                                                                     |
          | `address`           | `string`          | Checksummed smart wallet address.                                                                       |
          | `smart_wallet_type` | `SmartWalletType` | One of `'kernel'`, `'safe'`, `'biconomy'`, `'thirdweb'`, `'light_account'` or `'coinbase_smart_wallet'` |
        </Accordion>

        <Accordion title="WalletAccount">
          | Field                                    | Type                     | Description                                                                                              |
          | ---------------------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------- |
          | `type`                                   | `'wallet'`               | N/A                                                                                                      |
          | API:`chain_type` <br /> SDK: `chainType` | `'ethereum' \| 'solana'` | Type of chain for the wallet. EVM chains (`'ethereum'`) and Solana (`'solana'`) are currently supported. |
          | `address`                                | `string`                 | Checksummed wallet address.                                                                              |
        </Accordion>
      </Accordion>
    </ParamField>

    <ParamField body="createEthereumWallet" type="boolean">
      Whether to pregenerate an embedded Ethereum wallet for the imported user. Defaults to `false`.
    </ParamField>

    <ParamField body="createSolanaWallet" type="boolean">
      Whether to pregenerate an embedded Solana wallet for the imported user. Defaults to `false`.
    </ParamField>

    <ParamField body="createEthereumSmartWallet" type="boolean">
      Whether to pregenerate an embedded Smart wallet for the imported user. Defaults to `false`. If
      `createEthereumSmartWallet` is `true`, you *must* also explicitly set `createEthereumWallet` to
      true as well.
    </ParamField>

    ### Response Format

    A successful response will include a list of results along with details about which imports succeeded and which failed:

    ```json
    {
      "results": [
        {
          "action": "create",
          "index": 0,
          "success": true,
          "id": "did:privy:clfn2wysq01ijykc8gyq2j2t1"
        },
        {
          "action": "create",
          "index": 1,
          "success": false,
          "code": 101,
          "error": "Account conflict caused by an existing user. Multiple users cannot share the same account.",
          "cause": "did:privy:clfmxole300rmykc89nojp3v2"
        },
        {
          "action": "create",
          "index": 2,
          "success": true,
          "id": "did:privy:clfn2wysq01ijykc8gyq2j2t3"
        }
      ]
    }
    ```

    Each result in the response includes:

    <ResponseField name="action" type="string">
      The action taken ("create").
    </ResponseField>

    <ResponseField name="index" type="number">
      The index of the user in the request array.
    </ResponseField>

    <ResponseField name="success" type="boolean">
      Whether the import succeeded.
    </ResponseField>

    <ResponseField name="id" type="string">
      The Privy DID of the created user (if successful).
    </ResponseField>

    <ResponseField name="code" type="number">
      Error code (if unsuccessful).
    </ResponseField>

    <ResponseField name="error" type="string">
      Error message (if unsuccessful).
    </ResponseField>

    <ResponseField name="cause" type="string">
      The conflicting DID (if there was an account conflict).
    </ResponseField>
  </Tab>
</Tabs>

<Info>
  User import endpoints have a rate limit of 240 users per minute. If you are being rate limited,
  responses will have status code 429. We suggest you set up exponential back-offs starting at 1
  second to seamlessly recover.
</Info>


# null
Source: https://docs.privy.io/user-management/migrating-users-to-privy/import-a-user



Privy allows you to import a single user into your Privy app. To import a user, pass their linked accounts (wallet, email, etc.) as part of the import request. You can also create a wallet during import with wallet pregeneration.

When an imported user logs in, all of their imported accounts will be included in their user object. If the imported user has a pregenerated embedded wallet, that wallet will be available to the user upon sign in.

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`importUser`** method to import a single user into your Privy app.

    ```tsx
    const user = await privy.importUser({
      linkedAccounts: [
        {
          type: 'email',
          address: 'batman@privy.io'
        }
      ],
      createEthereumWallet: true,
      createSolanaWallet: true,
      createEthereumSmartWallet: true,
      customMetadata: {
        key: 'value'
      }
    });
    ```

    ### Parameters

    <ParamField body="linkedAccounts" type="LinkedAccount[]" required>
      An array including all of the user's linked accounts. These objects are in the same shape as the
      linked accounts returned by [`getUser`](/user-management/users/managing-users/querying-users). For
      each linked account, you must specify the `type` and must not include a `verifiedAt` timestamp.

      <Accordion title="LinkedAccount types">
        <Accordion title="AppleAccount">
          | Field     | Type            | Description                                             |
          | --------- | --------------- | ------------------------------------------------------- |
          | `type`    | `'apple_oauth'` | N/A                                                     |
          | `email`   | `string`        | Email address associated with the user's Apple account. |
          | `subject` | `number`        | ID of user from Apple's user API.                       |
        </Accordion>

        <Accordion title="CustomJwtAccount">
          | Field                                            | Type            | Description                           |
          | ------------------------------------------------ | --------------- | ------------------------------------- |
          | `type`                                           | `'custom_auth'` | N/A                                   |
          | API: `custom_user_id` <br /> SDK: `customUserId` | `string`        | ID of user from custom auth provider. |
        </Accordion>

        <Accordion title="DiscordAccount">
          | Field      | Type              | Description                                                                                         |
          | ---------- | ----------------- | --------------------------------------------------------------------------------------------------- |
          | `type`     | `'discord_oauth'` | N/A                                                                                                 |
          | `subject`  | `string`          | ID of user from Discord user API response.                                                          |
          | `email`    | `string`          | Email of user from Discord user API response                                                        |
          | `username` | `string`          | Username of user from Discord user API response. Include the 4-digit discriminator prefixed by '#'. |

          (See [Discord docs](https://discord.com/developers/docs/resources/user))
        </Accordion>

        <Accordion title="EmailAccount">
          | Field     | Type      | Description                    |
          | --------- | --------- | ------------------------------ |
          | `type`    | `'email'` | N/A                            |
          | `address` | `string`  | Email address of user account. |
        </Accordion>

        <Accordion title="FarcasterAccount">
          | Field                                                      | Type          | Description                                                                                                                                             |
          | ---------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
          | `type`                                                     | `'farcaster'` | N/A                                                                                                                                                     |
          | `fid`                                                      | `number`      | FID of the user from Farcaster user API response.                                                                                                       |
          | API: `owner_address` <br /> SDK: `ownerAddress`            | `string`      | Wallet address of the user from Farcaster user API response. Note that this is the Farcaster wallet address, and not the Privy embedded wallet address. |
          | `username`                                                 | `string`      | (Optional) Username of user from Farcaster user API response. Do not include the '@'.                                                                   |
          | API: `display_name` <br /> SDK: `displayName`              | `string`      | (Optional) Display name of user from Farcaster user API response.                                                                                       |
          | `bio`                                                      | `string`      | (Optional) Bio of user from Farcaster user API response.                                                                                                |
          | API: `profile_picture_url` <br /> SDK: `profilePictureUrl` | `string`      | (Optional) Profile picture URL of the user from Farcaster user API response. Must be a valid image URL.                                                 |
          | API: `homepage_url` <br /> SDK: `homepageUrl`              | `string`      | (Optional) Profile URL of the user from Farcaster user API response.                                                                                    |

          (See [Farcaster docs](https://docs.farcaster.xyz/reference/hubble/httpapi/userdata#userdata-api). Note that the Privy import interface differs slightly from the Farcaster public interface in order to maintain consistency with other Privy **`LinkedAccount`** types.)
        </Accordion>

        <Accordion title="GithubAccount">
          | Field      | Type             | Description                                    |
          | ---------- | ---------------- | ---------------------------------------------- |
          | `type`     | `'github_oauth'` | N/A                                            |
          | `subject`  | `string`         | ID of user from GitHub user API response.      |
          | `email`    | `string`         | Email of user from GitHub user API response    |
          | `name`     | `string`         | Name of user from GitHub user API response     |
          | `username` | `string`         | Username of user from GitHub user API response |

          (See [GitHub docs](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28#get-the-authenticated-user))
        </Accordion>

        <Accordion title="GoogleAccount">
          | Field     | Type             | Description                                                |
          | --------- | ---------------- | ---------------------------------------------------------- |
          | `type`    | `'google_oauth'` | N/A                                                        |
          | `subject` | `string`         | `sub` pulled from Google-provided JWT with "openid" scope. |
          | `email`   | `string`         | `email` from Google-provided JWT with "email" scope.       |
          | `name`    | `string`         | `name` from Google-provided JWT with "profile" scope.      |
        </Accordion>

        <Accordion title="InstagramAccount">
          | Field      | Type                | Description                                                                 |
          | ---------- | ------------------- | --------------------------------------------------------------------------- |
          | `type`     | `'instagram_oauth'` | N/A                                                                         |
          | `subject`  | `string`            | ID of user from Instagram user API response.                                |
          | `username` | `string`            | The name displayed on a user's profile from Instagram's `/me` API response. |

          (See [Instagram docs](https://developers.facebook.com/docs/instagram-basic-display-api/reference/me/))
        </Accordion>

        <Accordion title="LinkedinAccount">
          | Field     | Type               | Description                                                           |
          | --------- | ------------------ | --------------------------------------------------------------------- |
          | `type`    | `'linkedin_oauth'` | N/A                                                                   |
          | `subject` | `string`           | ID of user from LinkedIn user API response.                           |
          | `email`   | `string`           | Email of user from LinkedIn user API response                         |
          | `name`    | `string`           | Name of user from LinkedIn user API response. Do not include the '@'. |

          (See [Linkedin docs](https://learn.microsoft.com/en-us/linkedin/consumer/integrations/self-serve/sign-in-with-linkedin-v2#api-request-to-retreive-member-details))
        </Accordion>

        <Accordion title="PhoneAccount">
          | Field    | Type      | Description                                                             |
          | -------- | --------- | ----------------------------------------------------------------------- |
          | `type`   | `'phone'` | N/A                                                                     |
          | `number` | `string`  | Phone number of user account (non-international numbers default to US). |

          While `number` is accepted as input, `phoneNumber` is returned in the response.
        </Accordion>

        <Accordion title="SpotifyAccount">
          | Field     | Type              | Description                                                                     |
          | --------- | ----------------- | ------------------------------------------------------------------------------- |
          | `type`    | `'spotify_oauth'` | N/A                                                                             |
          | `subject` | `string`          | ID of user from Spotify user API response.                                      |
          | `email`   | `string`          | Email of user from Spotify user API.                                            |
          | `name`    | `string`          | The name displayed on a user's profile from Spotify display\_name API response. |

          (See [Spotify docs](https://developer.spotify.com/documentation/web-api/reference/get-current-users-profile))
        </Accordion>

        <Accordion title="TelegramAccount">
          | Field            | Type         | Description                                                      |
          | ---------------- | ------------ | ---------------------------------------------------------------- |
          | `type`           | `'telegram'` | N/A                                                              |
          | `telegramUserId` | `string`     | ID of a user's telegram account.                                 |
          | `firstName`      | `string`     | The first name displayed on a user's telegram account.           |
          | `lastName`       | `string`     | (Optional) The last name displayed on a user's telegram account. |
          | `username`       | `string`     | (Optional) The username displayed on a user's telegram account.  |
          | `photo_url`      | `string`     | (Optional) The url of a user's telegram account profile picture. |

          (See [Telegram docs](https://core.telegram.org/widgets/login#checking-authorization))
        </Accordion>

        <Accordion title="TwitterAccount">
          | Field                                                   | Type              | Description                                                                                           |
          | ------------------------------------------------------- | ----------------- | ----------------------------------------------------------------------------------------------------- |
          | `type`                                                  | `'twitter_oauth'` | N/A                                                                                                   |
          | `subject`                                               | `string`          | ID of user from Twitter user API response.                                                            |
          | `name`                                                  | `string`          | Name of user from Twitter user API response                                                           |
          | `username`                                              | `string`          | Username of user from Twitter user API response. Do not include the '@'.                              |
          | API: profile\_picture\_url`<br/>`SDK: profilePictureUrl | `string`          | (Optional) Profile picture URL of the user from Twitter user API response. Must be a valid image URL. |

          (See [Twitter docs](https://developer.twitter.com/en/docs/twitter-api/users/lookup/api-reference/get-users-me#tab0))
        </Accordion>

        <Accordion title="SmartWalletAccount">
          | Field               | Type              | Description                                                                                             |
          | ------------------- | ----------------- | ------------------------------------------------------------------------------------------------------- |
          | `type`              | `'smart_wallet'`  | N/A                                                                                                     |
          | `address`           | `string`          | Checksummed smart wallet address.                                                                       |
          | `smart_wallet_type` | `SmartWalletType` | One of `'kernel'`, `'safe'`, `'biconomy'`, `'thirdweb'`, `'light_account'` or `'coinbase_smart_wallet'` |
        </Accordion>

        <Accordion title="WalletAccount">
          | Field                                    | Type                     | Description                                                                                              |
          | ---------------------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------- |
          | `type`                                   | `'wallet'`               | N/A                                                                                                      |
          | API:`chain_type` <br /> SDK: `chainType` | `'ethereum' \| 'solana'` | Type of chain for the wallet. EVM chains (`'ethereum'`) and Solana (`'solana'`) are currently supported. |
          | `address`                                | `string`                 | Checksummed wallet address.                                                                              |
        </Accordion>
      </Accordion>
    </ParamField>

    <ParamField body="createEthereumWallet" type="boolean">
      Whether to pregenerate an embedded Ethereum wallet for the imported user. Defaults to `false`.
    </ParamField>

    <ParamField body="createSolanaWallet" type="boolean">
      Whether to pregenerate an embedded Solana wallet for the imported user. Defaults to `false`.
    </ParamField>

    <ParamField body="createEthereumSmartWallet" type="boolean">
      Whether to pregenerate an embedded Smart wallet for the imported user. Defaults to `false`. If
      `createEthereumSmartWallet` is `true`, you *must* also explicitly set `createEthereumWallet` to
      true as well.
    </ParamField>

    <ParamField body="customMetadata" type="object">
      An object containing any custom metadata you want to associate with the user. This metadata will
      be returned in the user object when the user logs in.
    </ParamField>
  </Tab>

  <Tab title="REST API">
    Make a `POST` request to:

    ```sh
    https://auth.privy.io/api/v1/users
    ```

    Below is a **sample cURL command** for importing a new user into Privy:

    ```bash
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    -d '{
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email"
        }
      ]
    }'
    ```

    ### Parameters

    <ParamField body="linkedAccounts" type="LinkedAccount[]" required>
      An array including all of the user's linked accounts. These objects are in the same shape as the
      linked accounts returned by [`getUser`](/user-management/users/managing-users/querying-users). For
      each linked account, you must specify the `type` and must not include a `verifiedAt` timestamp.
    </ParamField>

    <ParamField body="createEthereumWallet" type="boolean">
      Whether to pregenerate an embedded Ethereum wallet for the imported user. Defaults to `false`.
    </ParamField>

    <ParamField body="createSolanaWallet" type="boolean">
      Whether to pregenerate an embedded Solana wallet for the imported user. Defaults to `false`.
    </ParamField>

    <ParamField body="createEthereumSmartWallet" type="boolean">
      Whether to pregenerate an embedded Smart wallet for the imported user. Defaults to `false`. If
      `createEthereumSmartWallet` is `true`, you *must* also explicitly set `createEthereumWallet` to
      true as well.
    </ParamField>

    <ParamField body="customMetadata" type="object">
      An object containing any custom metadata you want to associate with the user. This metadata will
      be returned in the user object when the user logs in.
    </ParamField>

    A successful response will include the new user object along with their DID:

    ```json
    {
      "id": "did:privy:clddy332f002tyqpq3b3lv327",
      "created_at": 1674788927,
      "linked_accounts": [
        {
          "address": "batman@privy.io",
          "type": "email",
          "verified_at": 1674788927
        }
      ]
    }
    ```
  </Tab>
</Tabs>

<Info>
  User import endpoints have a rate limit of 240 users in total per minute. If you are being rate
  limited, responses will have status code 429. We suggest you set up exponential back-offs starting
  at 1 second to seamlessly recover.
</Info>


# Migrating existing users to Privy
Source: https://docs.privy.io/user-management/migrating-users-to-privy/overview



Privy makes it easy for you to migrate existing user accounts from your existing auth setup.

At a high-level, your migration workflow involves two key components: **importing existing user accounts** and **ensuring users have continuous ownership over any assets stored in their wallets, including embedded wallets.** From these two pieces, you can easily switch over from a custom provider or add Privy to your existing auth flow.

## Importing user data

**You can easily import users and their accounts to Privy and can even pre-generate Privy embedded wallets for them.**

Privy supports both:

* [just-in-time migration](#just-in-time-migration) so you can map your existing users to Privy users as they log in
* [proactive migration](#proactive-migration) to import user data into Privy all at once

### Just-in-time migration

The simplest option is to "lazily" transfer your existing users to Privy. When an existing user logs in to your app via Privy for the first time, add their Privy DID to your internal users database to create a mapping between your existing user entry and [their Privy user object](/user-management/users/the-user-object).

Namely, we suggest:

1. In your internal users database, add a `PrivyDID` column.
2. In the [**`onComplete`**](/authentication/user-authentication/ui-component) callback from Privy's `useLogin` hook, if the **`isNewUser`** flag is `true`, make a request to your backend with the user's Privy DID (`user.id`) and any account data you need to identify that user from your existing DB.

For example, the request to your backend for a new user might include a body like:

```json
{
  "address": user.wallet?.address,
  "email": user.email?.address,
  "privyDID": user.id
}
```

3. When your backend receives the request from step (2), find the corresponding entry in your internal user database, matching on their wallet address, email address, or any other relevant account data.

<Steps>
  <Step>
    If entry does not have a `PrivyDID`, add the Privy DID from your request to the `PrivyDID`
    column in your database.
  </Step>

  <Step>
    If the entry already has a "Privy DID" in your database, it should match the Privy DID included
    in your request. There is nothing more to do.
  </Step>

  <Step>
    If there is no user matching the account information in the request, you can assume it is a new
    user in your internal database, and create an entry for them with their `PrivyDID`.
  </Step>
</Steps>

In this way, you can maintain a mapping between your existing user data and the corresponding Privy user object.

Your user data will be updated as your users login to your app using Privy.

### Proactive migration

If your existing users database associates multiple linked accounts (e.g. email, wallet, Discord, etc.) to a single user, we recommend that you proactively migrate them to Privy using the [**import users**](/user-management/migrating-users-to-privy/import-a-batch-of-users) endpoint. This ensures you can migrate your users and preserve the links between their different accounts in Privy.

Please see the instructions [here](/user-management/migrating-users-to-privy/import-a-batch-of-users) for more.

## Ensuring continuous asset ownership

Once you've migrated your user data to Privy, you should next migrate user assets if necessary to ensure the transition is seamless for your users. This can be done by transferring over user addresses to Privy (migrating the wallet) or having them transfer assets to their new accounts (migrating the assets).

The best path depends on your current setup and whether you need users to keep their existing wallets. We generally recommend transferring assets if you can.

<Tip>
  In most cases, migrating assets and/or wallets is only necessary if you are coming from another
  **embedded wallet** provider. If your users currently use external wallets to store their assets,
  you can simply import their address to Privy.
</Tip>

### If you are able to transfer assets

<AccordionGroup>
  <Accordion title="Migrating from a custodial system">
    If you are able to submit transactions on behalf of your users, you can set up batch
    transactions on your backend, sponsoring gas on behalf of your users to transfer their assets
    into pregenerated Privy wallets.
  </Accordion>

  <Accordion title="Migrating from a non-custodial system">
    When they next log in, prompt your users to run a one-time transfer to migrate their assets over
    to their new account.
  </Accordion>
</AccordionGroup>

### If you need to transfer wallets instead of transferring assets

<AccordionGroup>
  <Accordion title="Migrating from a custodial system (where you have access to user keys)">
    You can [import user keys to Privy
    easily](/recipes/react/import-wallet#importing-an-embedded-wallet) if you have access to them.
    This enables you to smoothly move your users' keys so they are managed by Privy's non-custodial
    system.
  </Accordion>

  <Accordion title="Migrating from a non-custodial system">
    We recommend you prompt your user to export their keys so they can use them with an external
    wallet (like MetaMask).
  </Accordion>
</AccordionGroup>

<Tip>
  Privy's system is non-custodial. This means neither you nor Privy will have any access to your
  user's private keys after the migration.
</Tip>


# null
Source: https://docs.privy.io/user-management/overview



Understanding your user lifecycle is essential to crafting incredible products. Privy enables user management to help you serve your user throughout their journey.

Privy allows your application to easily manage users from the server and the Privy dashboard. This means letting users connect multiple accounts (e.g. sms, email, social) and wallets (embedded or external) to their account to let you manage onchain and offchain state easily.

## Managing user state

### Webhooks

Privy comes with built in webhooks that will alert your servers whenever a user takes a specified action. Simply configure the events to be notified on, ie when a user is created or logged in, and a destination URL. Privy will send updates every time a user takes that action on your application.

### Dashboard

The Privy Dashboard is the hub to manage your apps, retrieve your API keys, and manage the administrators for your account. From the dashboard, administrators can create new apps, easily configure Privy features, and view key metrics and data about users.

### REST API

Privy supports myriad API endpoints to manage your application from your server. Your application can take actions like search, create, and delete users in a single line API call.


# null
Source: https://docs.privy.io/user-management/users/custom-metadata



Privy allows you to set custom metadata on the `user` object to store any app-specific metadata. This field is a generic JSON object up to 1KB in size. The JSON can contain arbitrary key-value pairs where the key is a `string` and value is a `string`, `integer`, or `boolean` (ie `{username: 'name', isVerified: true, age: 23}`).

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`setCustomMetadata`** method to set the custom metadata field for a user by their DID. As parameters, pass the user's DID as a `string` and the JSON object that you wish to set as custom metadata:

    ```typescript
    const user = await privy.setCustomMetadata('did:privy:XXXXXX', {username: 'name'});
    ```

    If a matching user is found for the DID and the custom metadata object is valid, the method will return the corresponding **`User`** object with updated custom metadata. If no matching user is found, or the custom metadata input is malformed or too large (>1KB), the method will throw an error.

    <Tip>
      When using the **`setCustomMetadata`** function in TypeScript, you can specify a type generic in order to enable type inference on the method like so:

      ```tsx
      // TypeScript will throw a type error if customMetadata is not of type {key1: string}
      const user = await privy.setCustomMetadata<{key1: string}>('did:privy:XXXXXX', customMetadata);
      ```
    </Tip>
  </Tab>

  <Tab title="REST API">
    To set the custom data for a user with a given DID, make a `POST` request to:

    ```bash
    https://auth.privy.io/api/v1/users/<did>/custom_metadata
    ```

    Replace `<did>` with your desired Privy DID. It should have the format `did:privy:XXXXXX`.

    Below is a sample cURL command for this request:

    ```bash
    curl --request POST https://auth.privy.io/api/v1/users/<user-did>/custom_metadata \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    -d '{
      "custom_metadata": {username: "name", isVerified: true, age: 23}
    }'
    ```

    A successful response will include the user object associated with the DID, with updated custom\_metadata, like below:

    ```json
    {
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "created_at": 1667165891,
      "custom_metadata": {"username": "name"},
      "linked_accounts": [
        {
          "type": "email",
          "address": "user@gmail.com",
          "verified_at": 1667350653
        }
      ]
    }
    ```

    If there is no user associated with the provided DID, or the custom metadata input is malformed or too large (>1KB), the API will return an error.
  </Tab>
</Tabs>


# Identity tokens
Source: https://docs.privy.io/user-management/users/identity-tokens

Access user data securely with Privy identity tokens

Identity tokens provide a secure and efficient way to access user data, especially on the server side. These tokens are JSON Web Tokens (JWTs) whose claims contain information about the currently authenticated user, including their linked accounts, metadata, and more.

Privy strongly recommends using identity tokens when you need user-level data on your server. They allow you to easily pass a signed representation of the current user's linked accounts from your frontend to your backend directly, letting you verifiably determine which accounts (wallet address, email address, Farcaster profile, etc.) are associated with the current request.

## Enabling identity tokens

To enable identity tokens for your application:

1. Navigate to your application dashboard's [User management > Authentication > Advanced](https://dashboard.privy.io/apps?logins=advanced\&page=login-methods) section
2. Toggle on **Return user data in an identity token** on the **Basics** page
3. Make sure you're using the latest version of the Privy SDK

## Token format

Privy identity tokens are [JSON Web Tokens (JWT)](https://jwt.io/introduction), signed with the ES256 algorithm. These JWTs include the following claims:

<ParamField query="linked_accounts" type="string">
  A stringified array containing a lightweight version of the current user's `linkedAccounts`
</ParamField>

<ParamField query="custom_metadata" type="string">
  A stringified version of the current user's `customMetadata`
</ParamField>

<ParamField query="sub" type="string">
  The user's Privy DID
</ParamField>

<ParamField query="iss" type="string">
  The token issuer, which should always be `privy.io`
</ParamField>

<ParamField query="aud" type="string">
  Your Privy app ID
</ParamField>

<ParamField query="iat" type="number">
  The timestamp of when the JWT was issued
</ParamField>

<ParamField query="exp" type="number">
  The timestamp of when the JWT will expire (generally 1 hour after issuance)
</ParamField>

## Retrieving identity tokens

<Tabs>
  <Tab title="React">
    Once you've enabled identity tokens, Privy will **automatically** include the identity token as a cookie on every request from your frontend to your server.

    For setups where you cannot use cookies, you can retrieve the identity token using the `useIdentityToken` hook:

    ```tsx
    import { useIdentityToken } from '@privy-io/react-auth';

    function MyComponent() {
      const { identityToken } = useIdentityToken();
      
      // Use the token in your API requests
      const callApi = async () => {
        const response = await fetch('/api/your-endpoint', {
          headers: {
            'privy-id-token': identityToken
          }
        });
      };
      
      return (
        <button onClick={callApi}>Call API</button>
      );
    }
    ```

    <Tip>
      We strongly recommend setting a base domain for your application, so that Privy can set the identity token as a more secure **HttpOnly** cookie.
    </Tip>
  </Tab>

  <Tab title="React Native">
    In React Native applications, you can get the current user's Privy token using the `getIdentityToken` method from the `useIdentityToken` hook:

    ```tsx
    import { useIdentityToken } from '@privy-io/expo';

    function MyComponent() {
      const { getIdentityToken } = useIdentityToken();
      
      const callApi = async () => {
        const idToken = await getIdentityToken();
        
        // For authenticated users, idToken will be a valid token
        // For unauthenticated users, idToken will be null
        
        if (idToken) {
          const response = await fetch('https://your-api.com/endpoint', {
            method: 'POST',
            headers: {
              'privy-id-token': idToken,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ /* your data */ })
          });
        }
      };
      
      return (
        <Button onPress={callApi} title="Call API" />
      );
    }
    ```
  </Tab>

  <Tab title="Swift">
    In Swift applications, the identity token can be accessed directly on the PrivyUser object. It will default to nil if it has not been configured. You can grab it with `privy.user.identityToken`:

    ```swift
    // Check if user is authenticated
    guard let user = privy.user else {
      // If user is nil, user is not authenticated
      return
    }

    // Access the identity token
    if let identityToken = user.identityToken {
      print("Identity token: \(identityToken)")
    } else {
      // Identity token has not been configured, defaults to nil
    }
    ```
  </Tab>

  <Tab title="Android">
    In Android applications, the identity token can be accessed directly on the PrivyUser object. It will default to null if it has not been configured. You can grab it with `privy.user.identityToken`:

    ```kotlin
    // Check if user is authenticated
    val user = privy.user
    if (user != null) {
      // Access the identity token
      val identityToken = user.identityToken
      if (identityToken != null) {
        println("Identity token: $identityToken")
      } else {
        // Identity token has not been configured, defaults to null
      }
    }
    ```
  </Tab>

  <Tab title="Flutter">
    In Flutter applications, the identity token can be accessed directly on the PrivyUser object. It will default to null if it has not been configured. You can grab it with `privy.user.identityToken`:

    ```dart
    // Check if user is authenticated
    final user = privy.user;
    if (user != null) {
      // Access the identity token
      final identityToken = user.identityToken;
      if (identityToken != null) {
        print("Identity token: $identityToken");
      } else {
        // Identity token has not been configured, defaults to null
      }
    }
    ```
  </Tab>
</Tabs>

## Reading identity tokens on your server

On your server, you can retrieve the identity token from incoming requests and use it to identify the user.

<Tabs>
  <Tab title="Next.js (Pages Router)">
    ```tsx
    // pages/api/example.ts
    import type { NextApiRequest, NextApiResponse } from 'next';
    import { getUser } from '@privy-io/server-auth';

    export default async function handler(req: NextApiRequest, res: NextApiResponse) {
      try {
        // Get identity token from cookie
        const idToken = req.cookies['privy-id-token'];
        
        // Or from header if sent that way
        // const idToken = req.headers['privy-id-token'];
        
        if (!idToken) {
          return res.status(401).json({ message: 'Unauthorized' });
        }
        
        // Parse and verify the token
        const user = await getUser({ idToken });
        
        // Now you can use the user data
        return res.status(200).json({ 
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return res.status(401).json({ message: 'Invalid token' });
      }
    }
    ```
  </Tab>

  <Tab title="Next.js (App Router)">
    ```tsx
    // app/api/example/route.ts
    import { cookies, headers } from 'next/headers';
    import { getUser } from '@privy-io/server-auth';
    import { NextResponse } from 'next/server';

    export async function GET() {
      try {
        // Get identity token from cookie
        const cookieStore = cookies();
        const idToken = cookieStore.get('privy-id-token')?.value;
        
        // Or from header if sent that way
        // const headersList = headers();
        // const idToken = headersList.get('privy-id-token');
        
        if (!idToken) {
          return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
        }
        
        // Parse and verify the token
        const user = await getUser({ idToken });
        
        // Now you can use the user data
        return NextResponse.json({ 
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return NextResponse.json({ message: 'Invalid token' }, { status: 401 });
      }
    }
    ```
  </Tab>

  <Tab title="Express">
    ```typescript
    import express from 'express';
    import cookieParser from 'cookie-parser';
    import { getUser } from '@privy-io/server-auth';

    const app = express();
    app.use(cookieParser());

    app.get('/api/protected', async (req, res) => {
      try {
        // Get identity token from cookie
        const idToken = req.cookies['privy-id-token'];

        // Or from header if sent that way
        // const idToken = req.headers['privy-id-token'];

        if (!idToken) {
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // Parse and verify the token
        const user = await getUser({ idToken });

        // Now you can use the user data
        return res.status(200).json({
          userId: user.id,
          // Other user data...
        });
      } catch (error) {
        console.error('Error verifying identity token:', error);
        return res.status(401).json({ message: 'Invalid token' });
      }
    });

    app.listen(3000, () => {
      console.log('Server running on port 3000');
    });
    ```
  </Tab>
</Tabs>

## Accessing custom metadata

Privy allows you to set [custom metadata](/user-management/users/custom-metadata) for a user via backend API requests. This metadata is available in the `custom_metadata` claim of the identity token.

Here's how to parse and access it:

```typescript
import {getUser} from '@privy-io/server-auth';
import * as jose from 'jose';

// Method 1: Using getUser (recommended)
async function getUserWithMetadata(idToken) {
  const user = await getUser({idToken});
  // Custom metadata is already parsed and available
  return user.customMetadata;
}

// Method 2: Manual parsing
async function parseCustomMetadata(idToken) {
  const verificationKey = await jose.importJWK(/* your verification key */);

  try {
    const {payload} = await jose.jwtVerify(idToken, verificationKey, {
      issuer: 'privy.io',
      audience: 'your-privy-app-id'
    });

    if (payload && payload.custom_metadata) {
      return JSON.parse(payload.custom_metadata);
    }

    return {};
  } catch (error) {
    console.error('Error parsing identity token:', error);
    throw error;
  }
}
```

## Refreshing the identity token

A new identity token is automatically issued when a user:

* Authenticates into the application
* Links or unlinks an account
* Refreshes their application page
* Calls `getAccessToken` when the access token is expired

To programmatically refresh the identity token, call `refreshUser` from the `useUser` hook:

```tsx
import {useUser} from '@privy-io/react-auth';

function RefreshButton() {
  const {refreshUser} = useUser();

  return <button onClick={refreshUser}>Refresh User Data</button>;
}
```

## Verifying the identity token

When your server receives a request with an identity token, you should verify the token's signature to authenticate the user. The preferred way is to use the `getUser` method from `@privy-io/server-auth`, which handles verification and parsing:

```typescript
import {getUser} from '@privy-io/server-auth';

async function verifyAndGetUser(idToken) {
  try {
    // This verifies the token signature and parses the payload
    const user = await getUser({idToken});
    return user;
  } catch (error) {
    console.error('Invalid identity token:', error);
    throw new Error('Authentication failed');
  }
}
```

<Info>
  The `verifyAuthToken` method will not work on identity tokens, as it is only used to verify Privy
  access tokens. Always use `getUser({idToken})` when working with identity tokens.
</Info>

For manual verification without using `getUser`, you can use JWT libraries like `jose`:

```typescript
import * as jose from 'jose';

async function verifyIdentityToken(idToken) {
  // Import the public key
  const publicKey = await jose.importJWK({
    // Your public key in JWK format
  });

  try {
    // Verify the token
    const {payload} = await jose.jwtVerify(idToken, publicKey, {
      issuer: 'privy.io',
      audience: 'your-privy-app-id'
    });

    return payload;
  } catch (error) {
    console.error('Token verification failed:', error);
    throw new Error('Authentication failed');
  }
}
```

## Security considerations

For optimal security when working with identity tokens:

1. **Always verify the token signature** before trusting any claims
2. **Check the expiration time** (`exp` claim) to ensure the token is still valid
3. **Set a base domain** for your application to enable HttpOnly cookies for the identity token
4. **Use HTTPS** for all communication between your frontend and backend
5. **Do not store sensitive information** in custom metadata, as it will be included in the identity token

<Info>Read more about Privy's tokens and their security in our [security guide](/security).</Info>


# Linking accounts to users
Source: https://docs.privy.io/user-management/users/linking-accounts



Developers can use Privy to prompt users to link additional accounts (such as a wallet or Discord profile) at *any point* in their user journey, not just during login.

This is key to Privy's **progressive onboarding**: improving conversion and UX by requiring users to complete onboarding steps (e.g. connecting an account) only when necessary.

<Tabs>
  <Tab title="React">
    The React SDK supports linking all supported account types via our modal-guided link methods.
    **To prompt a user to link an account, use the respective method from the **`useLinkAccount`** hook:**

    | Method          | Description             | User Experience  |
    | --------------- | ----------------------- | ---------------- |
    | `linkEmail`     | Links email address     | Opens modal      |
    | `linkPhone`     | Links phone number      | Opens modal      |
    | `linkWallet`    | Links external wallet   | Opens modal      |
    | `linkGoogle`    | Links Google account    | Direct redirect  |
    | `linkApple`     | Links Apple account     | Direct redirect  |
    | `linkTwitter`   | Links Twitter account   | Direct redirect  |
    | `linkDiscord`   | Links Discord account   | Direct redirect  |
    | `linkGithub`    | Links Github account    | Direct redirect  |
    | `linkLinkedIn`  | Links LinkedIn account  | Direct redirect  |
    | `linkTikTok`    | Links TikTok account    | Direct redirect  |
    | `linkSpotify`   | Links Spotify account   | Direct redirect  |
    | `linkInstagram` | Links Instagram account | Direct redirect  |
    | `linkTelegram`  | Links Telegram account  | Direct redirect  |
    | `linkFarcaster` | Links Farcaster account | Displays QR code |
    | `linkPasskey`   | Links passkey           | Opens modal      |

    <Info>
      Users are only permitted to link **a single account** for a given account type, except for wallets and passkeys. Concretely, a user may link at most one email address, but can link as many wallets and passkeys as they'd like.
    </Info>

    <Frame caption="Sample prompt to link a user's email after they have logged in">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/link-email.png" />
    </Frame>

    Below is an example button for prompting a user to link an email to their account:

    ```tsx
    import {useLinkAccount} from '@privy-io/react-auth';

    function LinkOptions() {
        const {linkEmail, linkGoogle, linkWallet} = useLinkAccount();

        return (
            <div className="link-options">
                <button onClick={linkEmail}>Link Email to user</button>
                <button onClick={linkGoogle}>Link Google account to user</button>
                <button onClick={linkWallet}>Link Wallet to user</button>
            </div>
        );
    }
    ```

    ### Callbacks

    You can optionally register an `onSuccess` or `onError` callback on the `useLinkAccount` hook.

    ```tsx
    const {linkGoogle} = useLinkAccount({
        onSuccess: ({user, linkMethod, linkedAccount}) => {
            console.log('Linked account to user ', linkedAccount);
        },
        onError: (error) => {
            console.error('Failed to link account with error ', error)
        }
    })
    ```

    <ParamField path="onSuccess" type="({user: User, linkMethod: string, linkedAccount: linkedAccount}) => void">
      Optional callback to run after a user successfully links an account.
    </ParamField>

    <ParamField path="onError" type="(error: string) => void">
      Optional callback to run after there is an error during account linkage.
    </ParamField>

    <Info>
      **Looking for whitelabel `link` methods?** Our [`useLoginWith<AccountType>`](/authentication/user-authentication/login-methods/email) hooks allow will link an account to a user, provided that the user is already logged in whenever the authentication flow is completed.
    </Info>
  </Tab>

  <Tab title="React Native">
    **To prompt a user to link an account, use the respective hooks:**

    | Account type | Description             | Hook to invoke                       |
    | ------------ | ----------------------- | ------------------------------------ |
    | `Email`      | Links email address     | `useLinkEmail`                       |
    | `Phone`      | Links phone number      | `useLinkSms`                         |
    | `Wallet`     | Links external wallet   | `useLinkWithSiwe`, `useLinkWithSiws` |
    | `Google`     | Links Google account    | `useLinkWithOAuth`                   |
    | `Apple`      | Links Apple account     | `useLinkWithOAuth`                   |
    | `Twitter`    | Links Twitter account   | `useLinkWithOAuth`                   |
    | `Discord`    | Links Discord account   | `useLinkWithOAuth`                   |
    | `Github`     | Links Github account    | `useLinkWithOAuth`                   |
    | `LinkedIn`   | Links LinkedIn account  | `useLinkWithOAuth`                   |
    | `TikTok`     | Links TikTok account    | `useLinkWithOAuth`                   |
    | `Spotify`    | Links Spotify account   | `useLinkWithOAuth`                   |
    | `Instagram`  | Links Instagram account | `useLinkWithOAuth`                   |
    | `Telegram`   | Links Telegram account  | `useLinkWithOAuth`                   |
    | `Farcaster`  | Links Farcaster account | `useLinkWithFarcaster`               |
    | `Passkey`    | Links passkey           | `useLinkPasskey`                     |

    The steps to implementing the link flows are analogous to the [login hooks `useLoginWith<AccountType`](/authentication/user-authentication/login-methods/email).

    <Info>
      Users are only permitted to link **a single account** for a given account type, except for wallets and passkeys. Concretely, a user may link at most one email address, but can link as many wallets and passkeys as they'd like.
    </Info>
  </Tab>

  <Tab title="Android">
    **To prompt a user to link an account, use the respective methods:**

    | Account type   | Description         | Method         |
    | -------------- | ------------------- | -------------- |
    | `EmailAccount` | Links email address | `linkWithCode` |

    The steps to implementing the `linkWithCode` flow are analogous to the [`loginWithCode` flow](/authentication/user-authentication/login-methods/email).

    First, prompt the user for their email address and use the Privy client's `privy.email.sendCode` method to send them a one-time passcode:

    ```kotlin
    sendCode(email: String): Result<Unit>
    ```

    ### Link With Code

    Then, prompt the user for the code they received and use the `linkWithCode` method:

    ```kotlin
    linkWithCode(code: String, email: String? = null): Result<Unit>
    ```

    <ParamField path="code" type="String" required={true}>
      The one-time passcode sent to the user’s email address.
    </ParamField>

    <ParamField path="email" type="String" required={false}>
      (Optional)  The user’s email address. Though this parameter is optional, it is highly recommended that you pass the user’s email address explicitly. If email is omitted, the email from `sendCode` will be used.
    </ParamField>

    ### Returns

    <ResponseField name="Result<Unit>" type="Result<Unit>">
      A Result object that indicates whether the operation was successful. Returns `Result.success` if the email account was linked successfully, or `Result.failure` if there was an error.
    </ResponseField>

    ## Usage

    ```kotlin
    // Send code to user's email
    val sendResult: Result<Unit> = privy.email.sendCode(email = "user_email@gmail.com")

    sendResult.fold(
        onSuccess = {
            // OTP was successfully sent, now prompt user for code
        },
        onFailure = {
            println("Error sending OTP: ${it.message}")
        }
    )

    // Link the email using the code
    val linkResult: Result<Unit> = privy.email.linkWithCode(code = "123456", email = "user_email@gmail.com")

    linkResult.fold(
        onSuccess = {
            println("Email successfully linked!")
            // User linked email
        },
        onFailure = {
            println("Error linking email: ${it.message}")
        }
    )
    ```
  </Tab>

  <Tab title="Swift">
    **To prompt a user to link an account, use the respective methods:**

    | Account type   | Description         | Method         |
    | -------------- | ------------------- | -------------- |
    | `EmailAccount` | Links email address | `linkWithCode` |

    The steps to implementing the `linkWithCode` flow are analogous to the [`loginWithCode` flow](/authentication/user-authentication/login-methods/email).

    First, prompt the user for their email address and use the Privy client's `privy.email.sendCode` method to send them a one-time passcode:

    ```swift
    sendCode(to email: String) async throws
    ```

    ### Link With Code

    Then, prompt the user for the code they received and use the `linkWithCode` method:

    ```swift
    linkWithCode(_ code: String, sentTo email: String) async throws
    ```

    <ParamField path="code" type="String" required={true}>
      The one-time passcode sent to the user’s email address.
    </ParamField>

    <ParamField path="sentTo" type="String" required={true}>
      The user’s email address.
    </ParamField>

    ### Returns

    Nothing, indicating success.

    ### Throws

    An error if linking the account is unsuccessful.

    ## Usage

    ```swift
    // Send code to user's email
    do {
        try await privy.email.sendCode(to: "myuser@privy.io")
        // successfully sent code to users email
    } catch {
        print("error sending code to \(email): \(error)")
    }

    // Link the email using the code
    do {
        try await privy.email.linkWithCode("123456", sentTo: "myuser@privy.io")
        print("Email successfully linked!")
        // user has linked their email!
    } catch {
        print("error linking email: \(error)")
    }
    ```
  </Tab>
</Tabs>


# Allow list
Source: https://docs.privy.io/user-management/users/managing-users/allowlist



**With Privy, you can enable an allow list for your application to gate access to specific email addresses, phone numbers, and/or wallet addresses.** You can use the allow list feature to coordinate a beta launch of your product for early-access users, manage an ongoing waitlist, and more!

When you enable an allow list for your app:

* All existing users will still be permitted to login to your app
* New users must be added to the allow list by their email address, phone number, or wallet address to be permitted to login
* New users who have not been added to your allow list will **not** be permitted to login.

## Enabling the allow list for your app

You can enable an allow list directly from the [Privy developer dashboard](https://dashboard.privy.io). To do so, just navigate to the **Users** page > [Access Control](https://dashboard.privy.io/apps/cm7z7tdvm00oxpsqt25bha0tv/users?tab=access-control) tab of the dashboard and toggle allow lists on.

![images/Allow.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Allow.png)

## Managing the allow list

There are two main ways to manage the allow list for your app:

* Using the API, you can easily [add users](/user-management/users/managing-users/allowlist#adding-to-the-allow-list), [remove users](/user-management/users/managing-users/allowlist#removing-from-the-allow-list), and [get your current allow list](/user-management/users/managing-users/allowlist#getting-the-allow-list).
* Using the developer dashboard, you can easily [add and remove users](/user-management/users/managing-users/allowlist#adding-to-the-allow-list) from your app's invite list page.

<Tip>
  It's easy to use the Privy API to manage your waitlist with a third party-tool. For instance, if you are using [Airtable](https://www.airtable.com/) to manage your waitlist, you can easily integrate it with Privy.

  Check out [this guide](/recipes/dashboard/airtable) for more!
</Tip>

## Adding to the allow list

Privy allows you to easily add a user's email address, phone number, or wallet address to the allow list for your app.

<Tabs>
  <Tab title="NodeJS">
    Use the 's  method to add a user to your allow list.

    ```tsx
    const allowlistEntry = await privy.inviteToAllowlist({
      type: 'email',
      value: 'batman@privy.io'
    });
    ```

    As a parameter to the method, pass an  object with the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to add to the allow list.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to add to the allow list. Should be the corresponding email address,
      phone number, or wallet address.
    </ParamField>

    If the invitation is successful, the method will return an . If the invitation fails, the method will throw an error.
  </Tab>

  <Tab title="REST API">
    ## Using the REST API

    Make a `POST` request to:

    ```sh
    https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist
    ```

    In the body of the request, include the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to add to the allow list.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to add to the allow list. Should be the corresponding email address,
      phone number, or wallet address.
    </ParamField>

    Below is a sample cURL command for adding an email to the allow list:

    ```bash
    curl --request POST 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist' \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    --data-raw '{
        "type": "email",
        "value": "user@email.com"
    }'
    ```

    A successful response will include the new allow list entry, like below

    ```json
    {
      "id": "allowlist-entry-ID",
      "type": "wallet",
      "value": "0xab5801a7d398351b8be11c439e05c5b3259aec9b",
      "appId": "your-privy-app-ID"
    }
    ```
  </Tab>
</Tabs>

## Removing from the allow list

Privy allows you to easily remove a user's email address, phone number, or wallet address to the allow list for your app.

<Tabs>
  <Tab title="NodeJS">
    Use the 's  method to remove a user from your allow list.

    ```tsx
    const removedAllowlistEntry = await privy.removeFromAllowlist({
      type: 'email',
      value: 'batman@privy.io'
    });
    ```

    As a parameter to the method, pass an  object with the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to remove from the allow list.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to remove from the allow list. Should be the corresponding email
      address, phone number, or wallet address.
    </ParamField>

    If the invitation is successful, the method will return an  that represents the now-deleted allow list entry. If the invitation fails, the method will throw an error.
  </Tab>

  <Tab title="REST API">
    Make a `DELETE` request to:

    ```sh
    https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist
    ```

    In the body of the request, include the following fields:

    <ParamField path="type" type="'email' | 'phone' | 'wallet'" required>
      The type of account to remove from the allow list.
    </ParamField>

    <ParamField path="value" type="string" required>
      The identifier of the account to remove from the allow list. Should be the corresponding email
      address, phone number, or wallet address.
    </ParamField>

    Below is a sample cURL command for deleting an email from the allow list:

    ```bash
    curl --request DELETE 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist' \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    --data-raw '{
      "type": "email",
      "value": "user@email.com"
    }'
    ```

    A successful response will include a message, such as:

    ```json
    {
      "message": "Successfully deleted from allowlist"
    }
    ```

    If there is no corresponding allow list entry for the invited account you attempted to delete, the response will include an error.
  </Tab>
</Tabs>

<Info>
  If a user has successfully logged into your application (e.g. after having been added to the allow
  list), you must [delete their user object](/user-management/users/managing-users/deleting-users),
  rather than deleting their allow list entry—to revoke their access.
</Info>

***

# Getting the allow list

Privy allows you to easily get the current allow list for your app.

<Tabs>
  <Tab title="NodeJS">
    Use the 's  method to get your app's current allow list. Pass no parameters to this method.

    ```tsx
    const allowlistEntry = await privy.getAllowlist();
    ```

    If the request is successful, the method will return an array of  objects. These include a `type` describing the type of entry (`'email'`, `'phone'`, or `'wallet'`) and a `value` with the corresponding account identifier (e.g. the email address).
  </Tab>

  <Tab title="REST API">
    Make a `GET` request to:

    ```
    https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist
    ```

    Below is a sample cURL command for getting your current allow list:

    ```bash
    curl --request GET 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/allowlist' \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    A successful response will include an array of your current allow list entries, like below:

    ```json
    [
      {
        "id": "allowlist-entry-ID",
        "type": "wallet",
        "value": "0xab5801a7d398351b8be11c439e05c5b3259aec9b",
        "appId": "your-privy-app-ID"
      },
      {
        "id": "allowlist-entry-ID",
        "type": "email",
        "value": "user@email.com",
        "appId": "your-privy-app-ID"
      }
      // ...
    ]
    ```
  </Tab>
</Tabs>

***

# Customizing allow list rejection

If your app has an allow list enabled, new users who attempt to login with an account not in your allow list will not be permitted to login to your app.

**You can customize the screen shown to the user when they are denied permission to login, to help contextualize the allow list within your app.**

To customize this screen, make a `POST` request to

```
https://auth.privy.io/api/v1/apps/<your-privy-app-id>
```

In the body of the request, include an field that contains a JSON with the following fields. All fields in this object are optional.

<ParamField path="error_title" type="string">
  The primary text for the error message you'd like to show your user. Defaults to "You don't have
  access to this app".
</ParamField>

<ParamField path="error_detail" type="string">
  The secondary text for the error message you'd like to show your user. Defaults to "Have you been
  invited?"
</ParamField>

<ParamField path="cta_text" type="string">
  The text to show on the error confirmation button. Defaults to "Try another account"
</ParamField>

<ParamField path="cta_link" type="string">
  The URL to navigate the user to, when they click the error CTA. Defaults to just closing the
  screen on click, instead of navigating the user to another URL.
</ParamField>

Below is a sample cURL command for updating the allow list config:

```bash
curl --request POST 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>' \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>" \
-H 'Content-Type: application/json' \
--data-raw '{
  "allowlist_config": {
    "error_title": "Insert your error title",
    "error_detail": "Insert your error detail",
    "cta_text": "Insert your error CTA",
    "cta_link": "Insert a URL to navigate the user to when clicking the CTA"
  }
}'
```


# Deleting users
Source: https://docs.privy.io/user-management/users/managing-users/deleting-users



Privy allows you to delete users via their Privy DID. This is an irreversible and destructive action; if the user logs into your app again, they will have a new DID, will have to relink any formerly linked accounts, and will get a new embedded wallet address.

<Warning>
  **Please take extreme care when deleting users.** For security of user assets, Privy does not
  delete the embedded wallet, and instead "soft deletes" it by disassociating it from the deleted
  user. If the user still has access to their login method and their wallet password, if they have
  set one, their wallet can be recovered after deletion.
</Warning>

<Tabs>
  <Tab title="NodeJS">
    Use the **`PrivyClient`**'s **`deleteUser`** method to delete a user. As a parameter, pass the user's Privy DID as a `string`:

    ```ts
    await privy.deleteUser('did:privy:XXXXXX');
    ```

    ### Complete Example

    ```ts
    import { PrivyClient } from '@privy-io/server-auth';

    const privy = new PrivyClient({
      appId: process.env.PRIVY_APP_ID,
      appSecret: process.env.PRIVY_APP_SECRET,
    });

    async function deletePrivyUser(did: string) {
      try {
        await privy.deleteUser(did);
        console.log(`User ${did} successfully deleted`);
        return true;
      } catch (error) {
        console.error(`Failed to delete user: ${error.message}`);
        return false;
      }
    }
    ```

    This method will throw an error if the deletion operation failed (e.g. due to an invalid Privy DID).
  </Tab>

  <Tab title="REST API">
    Make a `DELETE` request to:

    ```sh
    https://auth.privy.io/api/v1/users/<did>
    ```

    Replace `<did>` with your user's Privy DID. It should have the format `did:privy:XXXXXX`.

    ### Request

    <ParamField path="Authentication" type="Basic Auth">
      Use your Privy app ID as the username and your Privy app secret as the password.
    </ParamField>

    <ParamField path="Headers" type="Object">
      <ParamField path="privy-app-id" type="string" required>
        Your Privy app ID.
      </ParamField>
    </ParamField>

    ### Example

    Below is a sample cURL command for deleting the user object associated with a Privy DID:

    ```bash
    curl --request DELETE https://auth.privy.io/api/v1/users/<user-did> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ### Response

    <ResponseField name="Status Code" type="number">
      <ResponseField name="204 No Content">
        The user was successfully deleted.
      </ResponseField>

      <ResponseField name="404 Not Found">
        There is no user associated with the provided Privy DID.
      </ResponseField>
    </ResponseField>
  </Tab>

  <Tab title="Dashboard">
    The Privy Dashboard provides a simple interface to delete users when necessary.

    ## Steps to delete a user

    1. Log in to the [Privy Dashboard](https://dashboard.privy.io/)
    2. Navigate to the **Users** page for your app
    3. Search for the user you wish to delete
    4. Click on the user to open the user drawer
    5. Scroll to the bottom of the user drawer
    6. Click the **Delete User** button
    7. Confirm the deletion in the confirmation dialog

    <Warning>
      This action cannot be undone. Once a user is deleted:

      * If they log in again, they will get a new DID
      * They will need to relink any accounts
      * They will get a new embedded wallet address
      * Any data associated with their previous DID will be inaccessible
    </Warning>
  </Tab>
</Tabs>


# Deny list
Source: https://docs.privy.io/user-management/users/managing-users/denylist



Privy allows your app to enable a **deny list** to block specific users from logging in to your app and creating accounts. You can use the deny list to block users who have previously been malicious in your application or who violate your terms of service.

Currently, Privy deny lists support blocking users based on their **email address, phone number, EVM wallet address or Solana wallet address**. You can choose to either block a specific email address (e.g. `bruce@wayneenterprises.com`) or an email domain (e.g. `@wayneenterprises.com`).

## Enabling the deny list for your app

You can enable an deny list directly from the [Privy developer dashboard](https://dashboard.privy.io). To do so, just navigate to the **Users** page > [Access Control](https://dashboard.privy.io/apps/cm7z7tdvm00oxpsqt25bha0tv/users?tab=access-control) tab of the dashboard and toggle deny lists on.

![images/Deny.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Deny.png)

## Managing the deny list

There are two main ways to manage the allow list for your app:

* Using the API, you can easily [add entries](/user-management/users/managing-users/denylist#adding-to-the-deny-list), [remove entries](/user-management/users/managing-users/denylist#removing-from-the-deny-list), and [get your current deny list](/user-management/users/managing-users/denylist#getting-the-deny-list).
* Using the developer dashboard, you can easily [add and remove entries](/user-management/users/managing-users/denylist#adding-to-the-deny-list) from your app's deny list.

## Adding to the deny list

<Info>If you do not have a deny list enabled for your app, this request will fail.</Info>

Privy allows you to easily add an individual email address, phone number, EVM wallet address or Solana wallet address to your deny list.

To add an entry to the deny list, make a `POST` request to:

```sh
https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist
```

In the body of the request, include the following fields:

<ParamField path="type" type="'email' | 'emailDomain' | 'phoneNumber' | 'ethereumAddress' | 'solanaAddress'" required>
  Specifies that the request adds an email address, email domain, phone number, EVM wallet address
  or Solana wallet address to the deny list.
</ParamField>

<ParamField path="value" type="string" required>
  The email address, email domain, phone number, EVM wallet address or Solana wallet address to add
  to the deny list.
</ParamField>

Below is a sample cURL command for adding an email to the deny list:

```bash
curl --request POST 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist' \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>" \
-H "Content-Type: application/json" \
--data-raw '{
  "type": "email",
  "value": "user@email.com"
}'
```

A successful response will include the new deny list entry, like below

```json
{
  "id": "denylist-entry-ID",
  "rule_type": "email",
  "value": "user@email.com"
}
```

***

# Removing from the deny list

<Info>
  If you do not have a deny list enabled for your app, this request will fail. Please [reach
  out](mailto:sales@privy.io) if you'd like to configure a deny list.
</Info>

To delete an entry from the deny list, make a `DELETE` request to:

```sh
https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist
```

In the body of the request, include the following fields:

<ParamField path="id" type="string" required>
  The ID of the deny list entry to be removed. You can obtain this ID by [getting your current deny
  list](/user-management/users/managing-users/denylist).
</ParamField>

Below is a sample cURL command for deleting an email from the deny list:

```bash
curl --request DELETE 'https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist' \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>" \
-H "Content-Type: application/json" \
--data-raw '{
  "id": "clpa828s4001hl90f6dxoksrg",
}'
```

A successful request will return response code `204`. If there is no corresponding deny list entry, the response will include an error.

***

# Getting the deny list

To get your current deny list, make a `GET` request to:

```sh
https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist
```

This is a paginated query, and the API will return up to 1000 deny list entries for a single request.

## Parameters

In the **request query parameters**, specify the following fields:

<ParamField path="cursor" type="string">
  When you request a batch of deny list entries from Privy, the API will return a cursor for the *next* batch of deny list entries in the `next_cursor` field of the [response](#response). This will be a deny list ID, which is a `string`.

  If you are requesting the *first* batch of deny list entries for your app, do not include a `cursor` in your request parameters.

  If you have already requested a batch of deny list entries and want to request the next batch, set the `cursor` in your request parameters to be the `next_cursor` returned by the API in your previous query. If the provided `cursor` is not a valid deny list ID, the API will return an error.
</ParamField>

<ParamField path="limit" type="number">
  The number of users you would like the API to return. Defaults to 1000.
</ParamField>

As an example, to get the first 1000 deny list entries for your app, you should include *no* URL query parameters:

```sh
curl --request GET https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>"
```

Then, to get the *next* 1000 deny list entries for your app, you should pass the `next_cursor` field of the last response as the `cursor` in your request query parameters:

```sh
# Replace <insert-cursor> below with the `next_cursor` returned by the last query
curl --request GET https://auth.privy.io/api/v1/apps/<your-privy-app-id>/denylist?cursor=<insert-cursor> \
-u "<your-privy-app-id>:<your-privy-app-secret>" \
-H "privy-app-id: <your-privy-app-id>"
```

## Response

A successful response will include:

<ResponseField type="array">The deny list entries as an array</ResponseField>

<ResponseField type="string">The cursor to be used in your next request to this API</ResponseField>

Below is an example:

<Expandable title="child attributes" defaultOpen="true">
  ```json
  {
    "data": [
      {
        "id": "denylist-entry-ID1",
        "rule_type": "email",
        "value": "user@email.com"
      },
      {
        "id": "denylist-entry-ID2",
        "rule_type": "emailDomain",
        "value": "email.com"
      }
      // ...
    ],
    "next_cursor": "denylist-entry-ID2"
  }
  ```
</Expandable>

If you need to [remove an entry](/user-management/users/managing-users/denylist#removing-from-the-deny-list) from your deny list, you will need the `id` field returned in this API response.


# null
Source: https://docs.privy.io/user-management/users/managing-users/querying-users



Privy supports multiple ways to fetch and manage users in your application.

<Tabs>
  <Tab title="NodeJS">
    ## Querying users by identity token

    <Tip>
      Using identity tokens is the recommended way to query user information about authenticated users in your backend. If you need user data about unauthenticated users, you can use the `getUsers` method by passing in a user's DID.
    </Tip>

    Use the `getUser` method to get a single user by their identity token passed from the client, to learn more about identity tokens, see [identity tokens](/user-management/users/identity-tokens).

    ```typescript
    const user = await privy.getUser({idToken: 'your-idToken});
    ```

    ## Other ways to query users

    <Warning>
      Privy rate limits REST API endpoints that you may call from your server. If you're looking to get
      information about an authenticated user, consider using [identity
      tokens](/user-management/users/identity-tokens) as a more secure and efficient way to access user
      data.
    </Warning>

    ### Querying users by ID

    Use the `getUser` method to get a single user by their Privy DID:

    ```typescript
    const user = await privy.getUserById('did:privy:XXXXXX');
    ```

    ### Querying for all users

    Use the `getUsers` method to get a list of all your users:

    ```typescript
    const users = await privy.getUsers();
    ```

    <Note>
      The `getUsers` method automatically handles pagination and includes built-in exponential backoff to manage rate limits.
    </Note>

    ### Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        Use the `getUserByEmail` method to get a user by their email address:

        ```typescript
        const user = await privy.getUserByEmail('user@gmail.com');
        ```
      </Accordion>

      <Accordion title="By phone number">
        Use the `getUserByPhoneNumber` method to get a user by their phone number:

        ```typescript
        const user = await privy.getUserByPhoneNumber('+1 555 555 5555');
        ```
      </Accordion>

      <Accordion title="By wallet address">
        Use the `getUserByWalletAddress` method to get a user by their wallet address:

        ```typescript
        const user = await privy.getUserByWalletAddress('0xABCDEFGHIJKL01234567895C5cAe8B9472c14328');
        ```
      </Accordion>

      <Accordion title="By smart wallet address">
        Use the `getUserBySmartWalletAddress` method to get a user by their smart wallet address:

        ```typescript
        const user = await privy.getUserBySmartWalletAddress('0xABCDEFGHIJKL01234567895C5cAe8B9472c14328');
        ```
      </Accordion>

      <Accordion title="By custom auth ID">
        Use the `getUserByCustomAuthId` method to get a user by their custom auth ID:

        ```typescript
        const user = await privy.getUserByCustomAuthId('123');
        ```
      </Accordion>

      <Accordion title="By Farcaster fid">
        Use the `getUserByFarcasterId` method to get a user by their Farcaster fid:

        ```typescript
        const user = await privy.getUserByFarcasterId(1402);
        ```
      </Accordion>

      <Accordion title="By Twitter subject">
        Use the `getUserByTwitterSubject` method to get a user by their Twitter subject:

        ```typescript
        const user = await privy.getUserByTwitterSubject('456');
        ```
      </Accordion>

      <Accordion title="By Twitter username">
        Use the `getUserByTwitterUsername` method to get a user by their Twitter username:

        ```typescript
        const user = await privy.getUserByTwitterUsername('batman');
        ```
      </Accordion>

      <Accordion title="By Discord username">
        Use the `getUserByDiscordUsername` method to get a user by their Discord username:

        ```typescript
        const user = await privy.getUserByDiscordUsername('batman');
        ```
      </Accordion>

      <Accordion title="By Telegram User ID">
        Use the `getUserByTelegramUserId` method to get a user by their Telegram User ID:

        ```typescript
        const user = await privy.getUserByTelegramUserId('456');
        ```
      </Accordion>

      <Accordion title="By Telegram username">
        Use the `getUserByTelegramUsername` method to get a user by their Telegram username:

        ```typescript
        const user = await privy.getUserByTelegramUsername('batman');
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="REST API">
    ## Querying users by ID

    To get a user by their Privy DID, make a `GET` request to:

    ```bash
    https://auth.privy.io/api/v1/users/<did>
    ```

    ### Parameters

    <ParamField query="did" type="string" required>
      The user's Privy DID (e.g., `did:privy:XXXXXX`).
    </ParamField>

    ### Sample request

    ```bash
    curl --request GET https://auth.privy.io/api/v1/users/<user-did> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ## Querying for all users

    To get all users for your app, make a `GET` request to:

    ```bash
    https://auth.privy.io/api/v1/users
    ```

    ### Parameters

    <ParamField query="cursor" type="string">
      Cursor for pagination. Use the `next_cursor` from the previous response.
    </ParamField>

    <ParamField query="limit" type="number">
      Number of users to return per request. Defaults to 100.
    </ParamField>

    ### Response

    The response will include:

    * `data`: Array of user objects
    * `next_cursor`: Cursor to use for the next batch of users

    ### Sample request

    ```bash
    # First batch of users
    curl --request GET https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"

    # Subsequent batches using cursor
    curl --request GET https://auth.privy.io/api/v1/users?cursor=<next_cursor> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    ## Querying for users by account data

    <AccordionGroup>
      <Accordion title="By email address">
        To get a user by their email address, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/email/address
        ```

        ### Body

        <ParamField body="address" type="string" required>
          Email address of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/email/address" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "address": "user@gmail.com"
        }'
        ```
      </Accordion>

      <Accordion title="By phone number">
        To get a user by their phone number, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/phone/number
        ```

        ### Body

        <ParamField body="number" type="string" required>
          Phone number of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/phone/number" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "number": "1234567890"
        }'
        ```
      </Accordion>

      <Accordion title="By wallet address">
        To get a user by their wallet address, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/wallet/address
        ```

        ### Body

        <ParamField body="address" type="string" required>
          Wallet address of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/wallet/address" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "address": "0xABCDEFGHIJKL01234567895C5cAe8B9472c14328"
        }'
        ```
      </Accordion>

      <Accordion title="By smart wallet address">
        To get a user by their smart wallet address, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/smart_wallet/address
        ```

        ### Body

        <ParamField body="address" type="string" required>
          Smart wallet address of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/smart_wallet/address" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "address": "0xABCDEFGHIJKL01234567895C5cAe8B9472c14328"
        }'
        ```
      </Accordion>

      <Accordion title="By custom auth ID">
        To get a user by their custom auth ID, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/custom_auth/id
        ```

        ### Body

        <ParamField body="custom_user_id" type="string" required>
          Custom user ID provided by your authentication system.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/custom_auth/id" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "custom_user_id": "123"
        }'
        ```
      </Accordion>

      <Accordion title="By Farcaster fid">
        To get a user by their Farcaster fid, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/farcaster/fid
        ```

        ### Body

        <ParamField body="fid" type="string" required>
          Farcaster ID of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/farcaster/fid" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "fid": "789"
        }'
        ```
      </Accordion>

      <Accordion title="By Twitter subject">
        To get a user by their Twitter subject, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/twitter/subject
        ```

        ### Body

        <ParamField body="subject" type="string" required>
          Twitter subject identifier of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/twitter/subject" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "subject": "12345"
        }'
        ```

        <Note>
          Use subject instead of username to get Twitter accounts with faster queries.
        </Note>
      </Accordion>

      <Accordion title="By Twitter username">
        To get a user by their Twitter username, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/twitter/username
        ```

        ### Body

        <ParamField body="username" type="string" required>
          Twitter username of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/twitter/username" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "username": "batman"
        }'
        ```
      </Accordion>

      <Accordion title="By Discord username">
        To get a user by their Discord username, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/discord/username
        ```

        ### Body

        <ParamField body="username" type="string" required>
          Discord username of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/discord/username" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "username": "batman"
        }'
        ```
      </Accordion>

      <Accordion title="By Telegram User ID">
        To get a user by their Telegram User ID, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/telegram/telegram_user_id
        ```

        ### Body

        <ParamField body="telegram_user_id" type="string" required>
          Telegram User ID of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/telegram/telegram_user_id" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "telegram_user_id": "12345"
        }'
        ```

        <Note>
          Use ID instead of username to get Telegram accounts with faster queries.
        </Note>
      </Accordion>

      <Accordion title="By Telegram username">
        To get a user by their Telegram username, make a `POST` request to:

        ```bash
        https://auth.privy.io/api/v1/users/telegram/username
        ```

        ### Body

        <ParamField body="username" type="string" required>
          Telegram username of the user.
        </ParamField>

        ### Sample request

        ```bash
        curl --request POST "https://auth.privy.io/api/v1/users/telegram/username" \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
          "username": "batman"
        }'
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/user-management/users/overview



Privy provides a unified user management system that seamlessly combines traditional authentication methods with web3 capabilities. Each user in your application gets a unique Privy DID (Decentralized Identifier) and can link multiple authentication methods and wallets to their account.

![images/Users2.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Users2.png)

### The user object

At the core of Privy's user management is the user object, which provides a unified view of your user's identity across different authentication methods. Each user object contains:

* A unique Privy DID for consistent identification
* A collection of linked accounts (email, phone, wallets)
* Optional custom metadata for application-specific data
* Creation timestamp and other system metadata

### Linked accounts

Privy supports a comprehensive range of authentication methods that can be connected to a user's account. Users can authenticate using traditional methods like email, phone, and passkeys, or through popular social accounts including Google, Apple, and Discord. All of these methods are unified under a single user object, enabling seamless multi-method login while maintaining a consistent user identity.

### Account management

Managing user accounts with Privy is straightforward and flexible. You can dynamically link new authentication methods to existing accounts or remove them when needed. The platform provides powerful tools for:

* Adding custom metadata to enrich user profiles
* Controlling access through allow lists and deny lists
* Managing user data and deletion requests
* Monitoring account activity and changes

### Identity verification

Privy's identity token system provides robust security and verification capabilities. These tokens securely represent user identity and can be verified on your backend. They include custom metadata and feature automatic refresh functionality to maintain session state without interruption.

### User events

Monitor user activity through Privy's webhook system, which notifies your backend when important events occur, such as:

* New account creation
* Authentication method changes
* Custom metadata updates
* Other significant account modifications

### UI components

Privy streamlines implementation by providing ready-to-use UI components for all essential user management tasks. These include authentication flows, account linking interfaces, profile management tools, and wallet connection experiences - all designed to work seamlessly with your application.

## Next steps

* Learn about [the user object](./the-user-object)
* Understand how to [link accounts](./linking-accounts)
* Implement [custom metadata](./custom-metadata)
* Set up [user webhooks](./webhooks)


# Handling the user object
Source: https://docs.privy.io/user-management/users/the-user-object



All of Privy's login methods result in a unified JSON representation of your user.

<Tabs>
  <Tab title="React">
    **To get the current user, inspect the [`user`](/user-management/users/the-user-object) object returned by the `usePrivy` hook:**

    ```tsx
    const { user } = usePrivy();
    ```

    ### Unauthenticated users

    For **unauthenticated** users, the [**`user`**](/user-management/users/the-user-object) object will be `null`.

    ### Authenticated users

    For **authenticated** users, you can use the following fields:

    <Expandable title="User" defaultOpen={true}>
      <ParamField body="id" type="string" required>
        The Privy-issued DID for the user. If you need to store additional information about a user, you
        can use this DID to reference them.
      </ParamField>

      <ParamField body="createdAt" type="string" required>
        The datetime of when the user was created, in ISO 8601 format.
      </ParamField>

      <ParamField body="linkedAccounts" type="array" required>
        The list of accounts associated with this user. Each account contains additional metadata that may
        be helpful for advanced use cases.

        <Expandable title="Properties">
          <Expandable title="Wallet">
            <ParamField body="type" type="'wallet'" required>
              Denotes that this is a wallet account
            </ParamField>

            <ParamField body="id" type="string | null" required>
              The server wallet ID of the wallet. Null if the wallet is not delegated. Only applies to
              embedded wallets (walletClientType === 'privy')
            </ParamField>

            <ParamField body="address" type="string" required>
              The wallet address
            </ParamField>

            <ParamField body="chainType" type="'ethereum' | 'solana'" required>
              Chain type of the wallet address
            </ParamField>

            <ParamField body="walletClientType" type="string" required>
              The wallet client used for this wallet during the most recent verification. If the value is
              'privy', then this is a privy embedded wallet
            </ParamField>

            <ParamField body="connectorType" type="string" required>
              The connector type used for this wallet during the most recent verification
            </ParamField>

            <ParamField body="recoveryMethod" type="'privy' | UserRecoveryMethod" required>
              If this is a 'privy' embedded wallet, stores the recovery method
            </ParamField>

            <ParamField body="imported" type="boolean" required>
              Whether the wallet is imported. Only applies to embedded wallets (walletClientType === 'privy')
            </ParamField>

            <ParamField body="delegated" type="boolean" required>
              Whether the wallet is delegated. Only applies to embedded wallets (walletClientType === 'privy')
            </ParamField>

            <ParamField body="walletIndex" type="number | null" required>
              HD index for the wallet. Only applies to embedded wallets (walletClientType === 'privy')
            </ParamField>
          </Expandable>

          <Expandable title="SmartWallet">
            <ParamField body="type" type="'smart_wallet'" required>
              Denotes that this is a smart wallet account
            </ParamField>

            <ParamField body="address" type="string" required>
              The wallet address
            </ParamField>

            <ParamField body="smartWalletType" type="SmartWalletType" required>
              The provider of the smart wallet
            </ParamField>
          </Expandable>

          <Expandable title="Email">
            <ParamField body="type" type="'email'" required>
              Denotes that this is an email account
            </ParamField>

            <ParamField body="address" type="string" required>
              The email address
            </ParamField>
          </Expandable>

          <Expandable title="Phone">
            <ParamField body="type" type="'phone'" required>
              Denotes that this is a phone account
            </ParamField>

            <ParamField body="number" type="string" required>
              The phone number
            </ParamField>
          </Expandable>

          <Expandable title="Google">
            <ParamField body="type" type="'google_oauth'" required>
              Denotes that this is a Google account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Google-issued JWT for this account
            </ParamField>

            <ParamField body="email" type="string" required>
              The email associated with the Google account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Google account
            </ParamField>
          </Expandable>

          <Expandable title="Twitter">
            <ParamField body="type" type="'twitter_oauth'" required>
              Denotes that this is a Twitter account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Twitter-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Twitter account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Twitter account
            </ParamField>

            <ParamField body="profilePictureUrl" type="string | null" required>
              The profile picture URL associated with the Twitter account
            </ParamField>
          </Expandable>

          <Expandable title="Discord">
            <ParamField body="type" type="'discord_oauth'" required>
              Denotes that this is a Discord account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Discord-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Discord account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Discord account
            </ParamField>
          </Expandable>

          <Expandable title="Github">
            <ParamField body="type" type="'github_oauth'" required>
              Denotes that this is a Github account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Github-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Github account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the Github account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Github account
            </ParamField>
          </Expandable>

          <Expandable title="Spotify">
            <ParamField body="type" type="'spotify_oauth'" required>
              Denotes that this is a Spotify account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The user id associated with the Spotify account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the Spotify account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The display name associated with the Spotify account
            </ParamField>
          </Expandable>

          <Expandable title="Instagram">
            <ParamField body="type" type="'instagram_oauth'" required>
              Denotes that this is an Instagram account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The user id associated with the Instagram account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Instagram account
            </ParamField>
          </Expandable>

          <Expandable title="Tiktok">
            <ParamField body="type" type="'tiktok_oauth'" required>
              Denotes that this is a Tiktok account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Tiktok-issued JWT for this account
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Tiktok account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The display name associated with the Tiktok account
            </ParamField>
          </Expandable>

          <Expandable title="LinkedIn">
            <ParamField body="type" type="'linkedin_oauth'" required>
              Denotes that this is a LinkedIn account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the LinkedIn-issued JWT for this account
            </ParamField>

            <ParamField body="name" type="string | null" required>
              The name associated with the LinkedIn account
            </ParamField>

            <ParamField body="email" type="string | null" required>
              The email associated with the LinkedIn account
            </ParamField>

            <ParamField body="vanityName" type="string | null" required>
              The vanityName/profile URL associated with the LinkedIn account
            </ParamField>
          </Expandable>

          <Expandable title="Apple">
            <ParamField body="type" type="'apple_oauth'" required>
              Denotes that this is an Apple account
            </ParamField>

            <ParamField body="subject" type="string" required>
              The 'sub' claim from the Apple-issued JWT for this account
            </ParamField>

            <ParamField body="email" type="string" required>
              The email associated with the Apple account
            </ParamField>
          </Expandable>

          <Expandable title="CustomJwt">
            <ParamField body="type" type="'custom_auth'" required>
              Denotes that this is a custom account
            </ParamField>

            <ParamField body="customUserId" type="string" required>
              The user ID given by the custom auth provider
            </ParamField>
          </Expandable>

          <Expandable title="Farcaster">
            <ParamField body="type" type="'farcaster'" required>
              Denotes that this is a Farcaster account
            </ParamField>

            <ParamField body="fid" type="number | null" required>
              The Farcaster on-chain FID
            </ParamField>

            <ParamField body="ownerAddress" type="string" required>
              The Farcaster ethereum address that owns the FID
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The Farcaster protocol username
            </ParamField>

            <ParamField body="displayName" type="string | null" required>
              The Farcaster protocol display name
            </ParamField>

            <ParamField body="bio" type="string | null" required>
              The Farcaster protocol bio
            </ParamField>

            <ParamField body="pfp" type="string | null" required>
              The Farcaster protocol profile picture
            </ParamField>

            <ParamField body="url" type="string | null" required>
              The Farcaster protocol profile url
            </ParamField>

            <ParamField body="signerPublicKey" type="string | null" required>
              The public key of the signer, if set. This is not guaranteed to be valid, as the user can revoke
              the key at any time
            </ParamField>
          </Expandable>

          <Expandable title="Passkey">
            <ParamField body="type" type="'passkey'" required>
              Denotes that this is a Passkey account
            </ParamField>

            <ParamField body="credentialId" type="string" required>
              The passkey credential ID
            </ParamField>

            <ParamField body="enrolledInMfa" type="boolean" required>
              Whether or not this passkey can be used for MFA
            </ParamField>

            <ParamField body="authenticatorName" type="string" required>
              The type of authenticator holding the passkey
            </ParamField>

            <ParamField body="createdWithDevice" type="string" required>
              Metadata about the device that registered the passkey
            </ParamField>

            <ParamField body="createdWithOs" type="string" required>
              Metadata about the OS that registered the passkey
            </ParamField>

            <ParamField body="createdWithBrowser" type="string" required>
              Metadata about the browser that registered the passkey
            </ParamField>
          </Expandable>

          <Expandable title="Telegram">
            <ParamField body="type" type="'telegram'" required>
              Denotes that this is a Telegram account
            </ParamField>

            <ParamField body="telegramUserId" type="string" required>
              The user ID that owns this Telegram account
            </ParamField>

            <ParamField body="firstName" type="string | null" required>
              The first name of the user
            </ParamField>

            <ParamField body="lastName" type="string | null" required>
              The last name of the user
            </ParamField>

            <ParamField body="username" type="string | null" required>
              The username associated with the Telegram account
            </ParamField>

            <ParamField body="photoUrl" type="string | null" required>
              The url of the user's profile picture
            </ParamField>
          </Expandable>

          <Expandable title="CrossApp">
            <ParamField body="type" type="'cross_app'" required>
              Denotes that this is a cross-app account
            </ParamField>

            <ParamField body="embeddedWallets" type="{ address: string }[]" required>
              The user's embedded wallet address(es) from the provider app
            </ParamField>

            <ParamField body="smartWallets" type="{ address: string }[]" required>
              The user's smart wallet address(es) from the provider app
            </ParamField>

            <ParamField body="providerApp" type="ProviderAppMetadata" required>
              Metadata about the provider app
            </ParamField>

            <ParamField body="subject" type="string" required>
              The subject identifier for this cross-app account
            </ParamField>
          </Expandable>

          {/* prettier-ignore */}

          {/*

            <Expandable title="AuthorizationKey">

            <ParamField body="type" type="'authorization_key'" required>
              Denotes that this is an authorization key
            </ParamField>
            <ParamField body="publicKey" type="string" required>
              The public key of the authorization key
            </ParamField>
            </Expandable> 
            */}

          <br />
        </Expandable>
      </ParamField>

      <ParamField body="mfaMethods" type="array" required>
        The list of MFA Methods associated with this user.
      </ParamField>

      <ParamField body="hasAcceptedTerms" type="boolean" required>
        Whether or not the user has explicitly accepted the Terms and Conditions and/or Privacy Policy
      </ParamField>

      <ParamField body="isGuest" type="boolean" required>
        Whether or not the user is a guest
      </ParamField>

      <Expandable title="Optional fields">
        <ParamField body="email" type="object">
          The user's email address, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="address" type="string">
              The email address.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="phone" type="object">
          The user's phone number, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="number" type="string">
              The phone number.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="wallet" type="object">
          The user's first verified wallet, if they have linked at least one wallet. It cannot be linked to
          another user.
        </ParamField>

        <ParamField body="smartWallet" type="object">
          The user's smart wallet, if they have set up through the Privy Smart Wallet SDK.

          <Expandable title="Properties">
            <ParamField body="address" type="string">
              The wallet address.
            </ParamField>

            <ParamField body="smartWalletType" type="string">
              The provider of the smart wallet.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="google" type="object">
          The user's Google account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Google-issued JWT for this account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Google account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Google account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="twitter" type="object">
          The user's Twitter account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Twitter-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Twitter account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Twitter account.
            </ParamField>

            <ParamField body="profilePictureUrl" type="string">
              The profile picture URL associated with the Twitter account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="discord" type="object">
          The user's Discord account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Discord-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Discord account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Discord account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="github" type="object">
          The user's Github account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Github-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Github account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the Github account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Github account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="spotify" type="object">
          The user's Spotify account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The user id associated with the Spotify account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Spotify account.
            </ParamField>

            <ParamField body="name" type="string">
              The display name associated with the Spotify account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="instagram" type="object">
          The user's Instagram account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The user id associated with the Instagram account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Instagram account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="tiktok" type="object">
          The user's Tiktok account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Tiktok-issued JWT for this account.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Tiktok account.
            </ParamField>

            <ParamField body="name" type="string">
              The display name associated with the Tiktok account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="linkedin" type="object">
          The user's LinkedIn account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the LinkedIn-issued JWT for this account.
            </ParamField>

            <ParamField body="name" type="string">
              The name associated with the LinkedIn account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the LinkedIn account.
            </ParamField>

            <ParamField body="vanityName" type="string">
              The vanityName/profile URL associated with the LinkedIn account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="apple" type="object">
          The user's Apple account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="subject" type="string">
              The `sub` claim from the Apple-issued JWT for this account.
            </ParamField>

            <ParamField body="email" type="string">
              The email associated with the Apple account.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="farcaster" type="object">
          The user's Farcaster account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="fid" type="number">
              The Farcaster on-chain FID
            </ParamField>

            <ParamField body="ownerAddress" type="string">
              The Farcaster ethereum address that owns the FID
            </ParamField>

            <ParamField body="username" type="string">
              The Farcaster protocol username
            </ParamField>

            <ParamField body="displayName" type="string">
              The Farcaster protocol display name
            </ParamField>

            <ParamField body="bio" type="string">
              The Farcaster protocol bio
            </ParamField>

            <ParamField body="pfp" type="string">
              The Farcaster protocol profile picture
            </ParamField>

            <ParamField body="url" type="string">
              The Farcaster protocol profile url
            </ParamField>

            <ParamField body="signerPublicKey" type="string">
              The public key of the signer, if set. This is not guaranteed to be valid, as the user can
              revoke the key at any time
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="telegram" type="object">
          The user's Telegram account, if they have linked one. It cannot be linked to another user.

          <Expandable title="Properties">
            <ParamField body="telegramUserId" type="string">
              The user ID that owns this Telegram account.
            </ParamField>

            <ParamField body="firstName" type="string">
              The first name of the user.
            </ParamField>

            <ParamField body="lastName" type="string">
              The last name of the user.
            </ParamField>

            <ParamField body="username" type="string">
              The username associated with the Telegram account.
            </ParamField>

            <ParamField body="photoUrl" type="string">
              The url of the user's profile picture.
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="customMetadata" type="object">
          Custom metadata field for a given user account
        </ParamField>
      </Expandable>

      <br />
    </Expandable>

    <Tip>
      You can set custom metadata for a user via Privy's backend [server SDK and/or
      API endpoints](/user-management/users/custom-metadata).
    </Tip>

    If a user has not linked an account of a given type, the corresponding field on the [`user`](/user-management/users/the-user-object) object will be undefined.

    <Tip>
      Users can have multiple passkeys linked to their account. To find all linked
      passkeys, use the `linkedAccounts` list and filter by `passkey` account type.
    </Tip>

    Below is an example of how you might use the [**`user`**](/user-management/users/the-user-object) object in a minimal user profile:

    ```tsx Example User Profile
    import { usePrivy } from "@privy-io/react-auth";

    function User() {
    const { ready, authenticated, user } = usePrivy();

    // Show nothing if user is not authenticated or data is still loading
    if (!(ready && authenticated) || !user) {
        return null;
    }

    return (
        <div>
        <p>User {user.id} has linked the following accounts:</p>
        <ul>
            <li>Apple: {user.apple ? user.apple.email : "None"}</li>
            <li>Discord: {user.discord ? user.discord.username : "None"}</li>
            <li>Email: {user.email ? user.email.address : "None"}</li>
            <li>Farcaster: {user.farcaster ? user.farcaster.username : "None"}</li>
            <li>GitHub: {user.github ? user.github.username : "None"}</li>
            <li>Google: {user.google ? user.google.email : "None"}</li>
            <li>Instagram: {user.instagram ? user.instagram.username : "None"}</li>
            <li>LinkedIn: {user.linkedin ? user.linkedin.email : "None"}</li>
            <li>Phone: {user.phone ? user.phone.number : "None"}</li>
            <li>Spotify: {user.spotify ? user.spotify.email : "None"}</li>
            <li>Telegram: {user.telegram ? user.telegram.username : "None"}</li>
            <li>TikTok: {user.tiktok ? user.tiktok.username : "None"}</li>
            <li>Twitter: {user.twitter ? user.twitter.username : "None"}</li>
            <li>Wallet: {user.wallet ? user.wallet.address : "None"}</li>
        </ul>
        </div>
    );
    }
    ```

    ### Refreshing the `user` object

    In order to update a `user` object after any type of backend update, (i.e. [unlinking an account](/user-management/users/unlinking-accounts) or setting [custom metadata](/user-management/users/custom-metadata)) you can ensure the user object in the application is up-to-date by invoking the **`refreshUser`** method from the **`useUser`** hook:

    ```tsx Example refresh User
    import { useUser } from "@privy-io/react-auth";

    const { user, refreshUser } = useUser();

    const updateMetadata = async (value: string) => {
    // Make API request to update custom metadata for a user from the backend
    const response = await updateUserMetadata({ value });
    await refreshUser();
    // `user` object should be updated
    console.log(user);
    };
    ```
  </Tab>

  <Tab title="React Native">
    **You can get information about the current user from the `user` object in the `usePrivy` hook:**

    ```tsx
    const {user} = usePrivy();
    ```

    **For unauthenticated users, the `user` object will be null. For authenticated users, you can use:**

    * **`user.id`** to get their Privy DID, which you may use to identify your user on your backend
    * **`user.created_at`** to get a UNIX timestamp of when the user was created.
    * **`user.linked_accounts`** to get an array of the user's linked accounts

    ## Parsing linked accounts

    Each entry in the `linked_accounts` array has different fields depending on the user data associated with that account type.

    See the dropdowns below to see the specific fields associated with each account type.

    <Expandable title="Wallet">
      <ParamField body="type" type="'wallet'" required>
        Denotes that this is a wallet account
      </ParamField>

      <ParamField body="id" type="string | null" required>
        The server wallet ID of the wallet. Null if the wallet is not delegated. Only applies to
        embedded wallets (walletClientType === 'privy')
      </ParamField>

      <ParamField body="address" type="string" required>
        The wallet address
      </ParamField>

      <ParamField body="chainType" type="'ethereum' | 'solana'" required>
        Chain type of the wallet address
      </ParamField>

      <ParamField body="walletClientType" type="string" required>
        The wallet client used for this wallet during the most recent verification. If the value is
        'privy', then this is a privy embedded wallet
      </ParamField>

      <ParamField body="connectorType" type="string" required>
        The connector type used for this wallet during the most recent verification
      </ParamField>

      <ParamField body="recoveryMethod" type="'privy' | UserRecoveryMethod" required>
        If this is a 'privy' embedded wallet, stores the recovery method
      </ParamField>

      <ParamField body="imported" type="boolean" required>
        Whether the wallet is imported. Only applies to embedded wallets (walletClientType === 'privy')
      </ParamField>

      <ParamField body="delegated" type="boolean" required>
        Whether the wallet is delegated. Only applies to embedded wallets (walletClientType === 'privy')
      </ParamField>

      <ParamField body="walletIndex" type="number | null" required>
        HD index for the wallet. Only applies to embedded wallets (walletClientType === 'privy')
      </ParamField>
    </Expandable>

    <Expandable title="SmartWallet">
      <ParamField body="type" type="'smart_wallet'" required>
        Denotes that this is a smart wallet account
      </ParamField>

      <ParamField body="address" type="string" required>
        The wallet address
      </ParamField>

      <ParamField body="smartWalletType" type="SmartWalletType" required>
        The provider of the smart wallet
      </ParamField>
    </Expandable>

    <Expandable title="Email">
      <ParamField body="type" type="'email'" required>
        Denotes that this is an email account
      </ParamField>

      <ParamField body="address" type="string" required>
        The email address
      </ParamField>
    </Expandable>

    <Expandable title="Phone">
      <ParamField body="type" type="'phone'" required>
        Denotes that this is a phone account
      </ParamField>

      <ParamField body="number" type="string" required>
        The phone number
      </ParamField>
    </Expandable>

    <Expandable title="Google">
      <ParamField body="type" type="'google_oauth'" required>
        Denotes that this is a Google account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Google-issued JWT for this account
      </ParamField>

      <ParamField body="email" type="string" required>
        The email associated with the Google account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Google account
      </ParamField>
    </Expandable>

    <Expandable title="Twitter">
      <ParamField body="type" type="'twitter_oauth'" required>
        Denotes that this is a Twitter account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Twitter-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Twitter account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Twitter account
      </ParamField>

      <ParamField body="profilePictureUrl" type="string | null" required>
        The profile picture URL associated with the Twitter account
      </ParamField>
    </Expandable>

    <Expandable title="Discord">
      <ParamField body="type" type="'discord_oauth'" required>
        Denotes that this is a Discord account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Discord-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Discord account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Discord account
      </ParamField>
    </Expandable>

    <Expandable title="Github">
      <ParamField body="type" type="'github_oauth'" required>
        Denotes that this is a Github account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Github-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Github account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the Github account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Github account
      </ParamField>
    </Expandable>

    <Expandable title="Spotify">
      <ParamField body="type" type="'spotify_oauth'" required>
        Denotes that this is a Spotify account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The user id associated with the Spotify account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the Spotify account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The display name associated with the Spotify account
      </ParamField>
    </Expandable>

    <Expandable title="Instagram">
      <ParamField body="type" type="'instagram_oauth'" required>
        Denotes that this is an Instagram account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The user id associated with the Instagram account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Instagram account
      </ParamField>
    </Expandable>

    <Expandable title="Tiktok">
      <ParamField body="type" type="'tiktok_oauth'" required>
        Denotes that this is a Tiktok account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Tiktok-issued JWT for this account
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Tiktok account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The display name associated with the Tiktok account
      </ParamField>
    </Expandable>

    <Expandable title="LinkedIn">
      <ParamField body="type" type="'linkedin_oauth'" required>
        Denotes that this is a LinkedIn account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the LinkedIn-issued JWT for this account
      </ParamField>

      <ParamField body="name" type="string | null" required>
        The name associated with the LinkedIn account
      </ParamField>

      <ParamField body="email" type="string | null" required>
        The email associated with the LinkedIn account
      </ParamField>

      <ParamField body="vanityName" type="string | null" required>
        The vanityName/profile URL associated with the LinkedIn account
      </ParamField>
    </Expandable>

    <Expandable title="Apple">
      <ParamField body="type" type="'apple_oauth'" required>
        Denotes that this is an Apple account
      </ParamField>

      <ParamField body="subject" type="string" required>
        The 'sub' claim from the Apple-issued JWT for this account
      </ParamField>

      <ParamField body="email" type="string" required>
        The email associated with the Apple account
      </ParamField>
    </Expandable>

    <Expandable title="CustomJwt">
      <ParamField body="type" type="'custom_auth'" required>
        Denotes that this is a custom account
      </ParamField>

      <ParamField body="customUserId" type="string" required>
        The user ID given by the custom auth provider
      </ParamField>
    </Expandable>

    <Expandable title="Farcaster">
      <ParamField body="type" type="'farcaster'" required>
        Denotes that this is a Farcaster account
      </ParamField>

      <ParamField body="fid" type="number | null" required>
        The Farcaster on-chain FID
      </ParamField>

      <ParamField body="ownerAddress" type="string" required>
        The Farcaster ethereum address that owns the FID
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The Farcaster protocol username
      </ParamField>

      <ParamField body="displayName" type="string | null" required>
        The Farcaster protocol display name
      </ParamField>

      <ParamField body="bio" type="string | null" required>
        The Farcaster protocol bio
      </ParamField>

      <ParamField body="pfp" type="string | null" required>
        The Farcaster protocol profile picture
      </ParamField>

      <ParamField body="url" type="string | null" required>
        The Farcaster protocol profile url
      </ParamField>

      <ParamField body="signerPublicKey" type="string | null" required>
        The public key of the signer, if set. This is not guaranteed to be valid, as the user can revoke
        the key at any time
      </ParamField>
    </Expandable>

    <Expandable title="Passkey">
      <ParamField body="type" type="'passkey'" required>
        Denotes that this is a Passkey account
      </ParamField>

      <ParamField body="credentialId" type="string" required>
        The passkey credential ID
      </ParamField>

      <ParamField body="enrolledInMfa" type="boolean" required>
        Whether or not this passkey can be used for MFA
      </ParamField>

      <ParamField body="authenticatorName" type="string" required>
        The type of authenticator holding the passkey
      </ParamField>

      <ParamField body="createdWithDevice" type="string" required>
        Metadata about the device that registered the passkey
      </ParamField>

      <ParamField body="createdWithOs" type="string" required>
        Metadata about the OS that registered the passkey
      </ParamField>

      <ParamField body="createdWithBrowser" type="string" required>
        Metadata about the browser that registered the passkey
      </ParamField>
    </Expandable>

    <Expandable title="Telegram">
      <ParamField body="type" type="'telegram'" required>
        Denotes that this is a Telegram account
      </ParamField>

      <ParamField body="telegramUserId" type="string" required>
        The user ID that owns this Telegram account
      </ParamField>

      <ParamField body="firstName" type="string | null" required>
        The first name of the user
      </ParamField>

      <ParamField body="lastName" type="string | null" required>
        The last name of the user
      </ParamField>

      <ParamField body="username" type="string | null" required>
        The username associated with the Telegram account
      </ParamField>

      <ParamField body="photoUrl" type="string | null" required>
        The url of the user's profile picture
      </ParamField>
    </Expandable>

    <Expandable title="CrossApp">
      <ParamField body="type" type="'cross_app'" required>
        Denotes that this is a cross-app account
      </ParamField>

      <ParamField body="embeddedWallets" type="{ address: string }[]" required>
        The user's embedded wallet address(es) from the provider app
      </ParamField>

      <ParamField body="smartWallets" type="{ address: string }[]" required>
        The user's smart wallet address(es) from the provider app
      </ParamField>

      <ParamField body="providerApp" type="ProviderAppMetadata" required>
        Metadata about the provider app
      </ParamField>

      <ParamField body="subject" type="string" required>
        The subject identifier for this cross-app account
      </ParamField>
    </Expandable>

    {/* prettier-ignore */}

    {/*

      <Expandable title="AuthorizationKey">

      <ParamField body="type" type="'authorization_key'" required>
        Denotes that this is an authorization key
      </ParamField>
      <ParamField body="publicKey" type="string" required>
        The public key of the authorization key
      </ParamField>
      </Expandable> 
      */}

    <br />
  </Tab>

  <Tab title="Flutter">
    Once a user has authenticated with Privy, you will have access to the `PrivyUser` object. This will be the main entry point for all user actions.

    ```dart
    abstract class PrivyUser {
      /// Unique identifier for the user.
      String get id;

      /// List of linked accounts associated with the user.
      List<LinkedAccounts> get linkedAccounts;

      /// List of embedded Ethereum wallets associated with the user.
      List<EmbeddedEthereumWallet> get embeddedEthereumWallets;

      /// List of embedded Solana wallets associated with the user.
      List<EmbeddedSolanaWallet> get embeddedSolanaWallets;

      /// Creates an Ethereum embedded wallet for the user.
      Future<Result<EmbeddedEthereumWallet>> createEthereumWallet(
          {bool allowAdditional = false});

      /// Creates a Solana embedded wallet for the user.
      Future<Result<EmbeddedSolanaWallet>> createSolanaWallet();
    }
    ```

    ## Linked accounts

    A user contains a list of LinkedAccounts, which are all account types associated with the user.

    ```dart
    /// A sealed class representing different types of linked accounts.
    sealed class LinkedAccount {}

    /// Represents a phone number-based linked account.
    class PhoneAccount extends LinkedAccount {}

    /// Represents an email-based linked account.
    class EmailAccount extends LinkedAccount {}

    /// Represents a custom authentication-linked account.
    class CustomAuth extends LinkedAccount {}

    /// Represents an Ethereum embedded wallet linked account.
    class EmbeddedEthereumWalletAccount extends LinkedAccount {}

    /// Represents a Solana embedded wallet linked account.
    class EmbeddedSolanaWalletAccount extends LinkedAccount {}
    ```
  </Tab>

  <Tab title="Android">
    Once a user has authenticated with Privy, you will have access to the `PrivyUser` object. This will be the main entry point for all user actions.

    ```kotlin
    public data class PrivyUser(
        // The user's Privy ID
        val id: String,

        // A list of all linked accounts - can be authentication methods or embedded wallets
        val linkedAccounts: List<LinkedAccount>,

        // A list of user's ethereum wallets
        val ethereumWallets: List<EmbeddedEthereumWallet>,

        // A list of the user's solana wallets
        val solanaWallets: List<EmbeddedSolanaWallet>

        // Refresh the user
        public suspend fun refresh(): Result<Unit>

        // Other user methods
    )

    public sealed interface LinkedAccount {
        public data class PhoneAccount(/* Account specific data */) : LinkedAccount

        public data class EmailAccount(/* Account specific data */) : LinkedAccount

        public data class CustomAuth(/* Account specific data */) : LinkedAccount

        public data class EmbeddedEthereumWalletAccount(/* Account specific data */) : LinkedAccount

        public data class EmbeddedSolanaWalletAccount(/* Account specific data */) : LinkedAccount

        // Other linked account types
    }
    ```
  </Tab>

  <Tab title="Swift">
    Once a user has authenticated with Privy, you will have access to the `PrivyUser` object. This will be the main entry point for all user actions.

    ```swift
    public protocol PrivyUser {
        /// The user's Privy ID
        var id: String { get }

        /// The user's ID token
        var identityToken: String? { get }

        /// The point in time at which the logged in user was created.
        /// Value will only be nil if there is no user currently logged in.
        var createdAt: Date? { get }

        // A list of all linked accounts - can be authentication methods or embedded wallets
        var linkedAccounts: [LinkedAccount] { get }

        // A list of user's ethereum wallets
        var embeddedEthereumWallets: [EmbeddedEthereumWallet] { get }

        // A list of the user's solana wallets
        var embeddedSolanaWallets: [EmbeddedSolanaWallet] { get }

        // Refresh the user
        func refresh() async throws

        // Returns the user's access token, but will first refresh the user session if needed.
        func getAccessToken() async throws -> String

        // Other user methods
    }

    public enum LinkedAccount {
        case phone(PhoneNumberAccount)
        case email(EmailAccount)
        case customAuth(CustomAuth)
        case embeddedEthereumWallet(EmbeddedEthereumWalletAccount)
        case embeddedSolanaWallet(EmbeddedSolanaWalletAccount)

    // Other linked account types
    }
    ```
  </Tab>

  <Tab title="Unity">
    Once your user has successfully authenticated, you can get a `PrivyUser` object containing their account data via:

    ```csharp
    // User will be null if no user is authenticated
    PrivyUser user = PrivyManager.Instance.User;
    ```

    The `PrivyUser` implements the interface below:

    ```csharp
    public interface IPrivyUser
    {
        // The user's ID
        string Id { get; }

        // List of the User's linked accounts
        PrivyLinkedAccount[] LinkedAccounts { get; }

        // A list of the user's embedded ethereum wallets
        IEmbeddedEthereumWallet[] EmbeddedWallets { get; }

        // A list of the user's embedded solana wallets
        IEmbeddedSolanaWallet[] EmbeddedSolanaWallets { get; }

        // Creates an embedded ethereum wallet for the user
        Task<IEmbeddedEthereumWallet> CreateWallet(bool allowAdditional = false);

        // Creates an embedded ethereum wallet for the user at the given HD index
        Task<IEmbeddedEthereumWallet> CreateWalletAtHdIndex(int hdWalletIndex);

        // Creates an embedded solana wallet for the user
        Task<IEmbeddedSolanaWallet> CreateSolanaWallet(bool allowAdditional = false);

        // Custom user metadata, stored as a set of key-value pairs.
        // This custom metadata is set server-side.
        Dictionary<string, string> CustomMetadata { get; }
    }
    ```

    <Warning>
      Make sure you subscribe to the [Authentication State Updates](/authentication/user-authentication/authentication-state) and avoid calling the `IPrivyUser` object without being Authenticated, as properties will return a default value otherwise.

      <Accordion title="See the default values for the PrivyUser when the user is not authenticated:">
        * `user.Id = ""`
        * `user.LinkedAccounts = []`
        * `user.EmbeddedWallets = []`
        * `user.CustomMetadata = new Dictionary()`
      </Accordion>
    </Warning>

    <Tip>
      You can set custom metadata for a user via Privy's backend [server SDK and/or API endpoints](/user-management/users/custom-metadata).
    </Tip>
  </Tab>
</Tabs>


# UI components
Source: https://docs.privy.io/user-management/users/ui-components



<Tabs>
  <Tab title="React">
    Privy provides a `UserPill` component to easily embed in your application. Users can login or connect their wallet from the user pill. Once authenticated, users can interact with the pill to quickly view their account information and use their wallets.

    ![images/Userpill2.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Userpill2.png)

    ## Usage

    To use the user pill component, import from the `@privy-io/react-auth` package:

    ```tsx
    import {UserPill} from '@privy-io/react-auth/ui';
    ```

    Then, embed the user pill within any component wrapped by your `PrivyProvider`:

    ```tsx {8}
    import {UserPill} from '@privy-io/react-auth/ui';

    function Page() {
      return (
        <div>
          <h1>Dashboard</h1>
          ...
          <UserPill />
          ...
        </div>
      );
    }
    ```

    You can also customize the user pill by passing the props describing the desired action, label, and size for the component. See more on these props below.

    ```tsx {18-22}
    import {UserPill} from '@privy-io/react-auth/ui';

    const logoImageElement = (
      <Image
        className="h-8 w-8 rounded-full"
        src="/images/logo.png"
        alt="logo placeholder"
        height={32}
        width={32}
      />
    );

    function Page() {
      return (
        <div>
          <h1>Dashboard</h1>
          ...
          <UserPill
            action={{type: 'login', options: {loginMethods: ['email']}}}
            label={logoImageElement}
            size={32}
          />
          ...
        </div>
      );
    }
    ```

    ## Customizing via props

    Privy allows you to easily customize the user pill within your app by passing `action`, `label`, and/or `size` props on the component.

    | Prop | Type      | Description                               |
    | ---- | --------- | ----------------------------------------- |
    |      | See below | The action users take from the user pill. |
    |      |           |                                           |
    |      |           | The size (in pixels) of the pill button.  |
    |      |           |                                           |

    ### Action prop

    The action prop describes the action the user can take from the `UserPill` component. This prop is an object with a `type` and `options` field.

    You can set the `type` to:

    * `'connectWallet'` to guide the user to connect their wallet. If `type: 'connectWallet'` is set, you may set `options: {suggestedAddress?: string}` to suggest a specific address for the user to connect.
    * `'login'` to guide the user to login to your application with any of your configured login methods. If `type: 'login'` is set, you may set `options` to an object containing `loginMethods` and/or `prefill`. The `loginMethods` field contains an array of the login methods to use in the pill and the `prefill` field contains an email address or phone number to prefill into the Privy login modal.

    Concretely, this type looks like

    ```tsx
    type Action =
      | {
          type: 'login';
          // Prompt the user to login
          options?: {
            loginMethods?: [string];
            prefill?: {
              type: 'email' | 'phone';
              value: string;
            };
          };
        }
      | {
          type: 'connectWallet';
          // Prompt the user to connect their wallet
          options?: {suggestedAddress?: string};
        };
    ```
  </Tab>
</Tabs>


# Unlinking accounts from users
Source: https://docs.privy.io/user-management/users/unlinking-accounts



Developers can use Privy to prompt users to unlink their linked accounts (such as a wallet or Discord profile) at *any point* in their user journey. This might be useful whenever the user has either created a new external account (such as a new Twitter profile or email address) and want to remove the old linked account from their user.

<Tabs>
  <Tab title="React">
    The React SDK supports unlinking all supported account types via our modal-guided link methods.
    **To prompt a user to unlink an account, use the respective method from the **`usePrivy`** hook:**

    | Method            | Description               |
    | ----------------- | ------------------------- |
    | `unlinkEmail`     | unlinks email address     |
    | `unlinkPhone`     | unlinks phone number      |
    | `unlinkWallet`    | unlinks external wallet   |
    | `unlinkGoogle`    | unlinks Google account    |
    | `unlinkApple`     | unlinks Apple account     |
    | `unlinkTwitter`   | unlinks Twitter account   |
    | `unlinkDiscord`   | unlinks Discord account   |
    | `unlinkGithub`    | unlinks Github account    |
    | `unlinklinkedIn`  | unlinks LinkedIn account  |
    | `unlinkTikTok`    | unlinks TikTok account    |
    | `unlinkSpotify`   | unlinks Spotify account   |
    | `unlinkInstagram` | unlinks Instagram account |
    | `unlinkTelegram`  | unlinks Telegram account  |
    | `unlinkFarcaster` | unlinks Farcaster account |
    | `unlinkPasskey`   | unlinks passkey           |

    <Info>
      Users are only permitted to unlink **an account** so long as they have at least one more linked account.
    </Info>

    Below is an example button for prompting a user to unlink certain linked accounts:

    ```tsx
    import {usePrivy} from '@privy-io/react-auth';

    function LinkOptions() {
    const {unlinkEmail, unlinkGoogle, unlinkWallet} = usePrivy();

    return (
    <div className="unlink-options">
    <button onClick={unlinkEmail}>Unlink Email to user</button>
    <button onClick={unlinkGoogle}>Unlink Google account to user</button>
    <button onClick={unlinkWallet}>Unlink Wallet to user</button>
    </div>
    );
    }
    ```
  </Tab>

  <Tab title="React Native">
    **To prompt a user to unlink an account, use the respective functions and hooks:**

    | Account type | Description               | Hook to invoke       |
    | ------------ | ------------------------- | -------------------- |
    | `Wallet`     | Unlinks external wallet   | `useUnlinkWallet`    |
    | `Google`     | Unlinks Google account    | `useUnlinkOAuth`     |
    | `Apple`      | Unlinks Apple account     | `useUnlinkOAuth`     |
    | `Twitter`    | Unlinks Twitter account   | `useUnlinkOAuth`     |
    | `Discord`    | Unlinks Discord account   | `useUnlinkOAuth`     |
    | `Github`     | Unlinks Github account    | `useUnlinkOAuth`     |
    | `LinkedIn`   | Unlinks LinkedIn account  | `useUnlinkOAuth`     |
    | `TikTok`     | Unlinks TikTok account    | `useUnlinkOAuth`     |
    | `Spotify`    | Unlinks Spotify account   | `useUnlinkOAuth`     |
    | `Instagram`  | Unlinks Instagram account | `useUnlinkOAuth`     |
    | `Farcaster`  | Unlinks Farcaster account | `useUnlinkFarcaster` |

    <Info>
      Users are only permitted to unlink **an account** so long as they have at least one more linked account.
    </Info>

    Below is an example button for prompting a user to unlink an email from their account:

    ```tsx
    import {useUnlinkWallet} from '@privy-io/expo';

    function LinkOptions() {
    const {unlinkWallet} = useUnlinkAccount();

    return (
    <div className="unlink-options">
    <button onClick={unlinkWallet}>Unlink Wallet to user</button>
    </div>
    );
    }
    ```

    <Info>
      We are actively working on building out other unlink methods for Expo! If there is an unsupported unlink method that is needed for your application, please make use of the REST API or dashboard to programmatically unlink accounts for your users.
    </Info>
  </Tab>

  <Tab title="REST API">
    Make a `POST` request to:

    ```bash
    https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink
    ```

    Replace `<privy-app-id>` with your Privy app ID and pass in the following parameters:

    | Parameter  | Type     | Description                                                                                 |
    | ---------- | -------- | ------------------------------------------------------------------------------------------- |
    | `user_id`  | `string` | Privy DID of the user                                                                       |
    | `type`     | `string` | Linked account type (see supported types below)                                             |
    | `handle`   | `string` | The identifier for the account (e.g., email address, wallet address)                        |
    | `provider` | `string` | (Only required for cross app unlinking) The cross app provider id, prefixed with `'privy:'` |

    ### Supported Account Types

    The following account types can be unlinked via the API:

    * `email` - Email accounts
    * `phone` - Phone number accounts
    * `wallet` - Externally connected wallets (Ethereum or Solana)
    * `smart_wallet` - Smart contract wallets
    * `farcaster` - Farcaster accounts
    * `telegram` - Telegram accounts
    * `cross_app` - Cross app accounts
    * OAuth providers:
      * `google_oauth`
      * `discord_oauth`
      * `twitter_oauth`
      * `github_oauth`
      * `linkedin_oauth`
      * `apple_oauth`
      * `spotify_oauth`
      * `instagram_oauth`
      * `tiktok_oauth`

    <Note>
      The API does not support unlinking `passkey`, `custom_auth`, `cross_app`, or `guest` account
      types.
    </Note>

    ### Example Requests

    <CodeGroup>
      ```bash Email account
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "email",
        "handle": "test@privy.io"
      }'
      ```

      ```bash Wallet account
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "wallet",
        "handle": "0x1234...5678"
      }'
      ```

      ```bash OAuth account
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "google_oauth",
        "handle": "<subject-identifier>"
      }'
      ```

      ```bash Cross app account
      curl --request POST "https://auth.privy.io/api/v1/apps/<privy-app-id>/users/unlink" \
      -u "<your-privy-app-id>:<your-privy-app-secret>" \
      -H "privy-app-id: <your-privy-app-id>" \
      -H 'Content-Type: application/json' \
      -d '{
        "user_id": "<user-did>",
        "type": "cross_app",
        "handle": "<subject-identifier>",
        "provider": "privy:<cross-app-provider-id>"
      }'
      ```
    </CodeGroup>

    ### Response

    If the unlinking is successful, the API will return a 200 status code.

    If there's no account associated with the Privy DID that matches the type and handle, the API will return a 400 status code.
  </Tab>

  <Tab title="Dashboard">
    To unlink via the dashboard:

    1. Navigate to the [Users page](https://dashboard.privy.io/?page=users\&tab=all-users)
    2. Select the user
    3. Click the button beside the account you want to unlink
    4. Click `Unlink account`

    <Note>
      The unlink option won't appear if unlinking is not available for the account.
    </Note>

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/users-unlink.png" alt="Unlinking an account in the Privy Dashboard" />
    </Frame>
  </Tab>
</Tabs>


# Updating user accounts
Source: https://docs.privy.io/user-management/users/updating-accounts



<Tabs>
  <Tab title="React">
    <Tabs>
      <Tab title="Email">
        To prompt users to change their email, you can use the `updateEmail` method from the `usePrivy` hook:

        ```tsx
        updateEmail: () => void
        ```

        ### Usage

        ```tsx
        import {usePrivy} from '@privy-io/react-auth';
        const {updateEmail} = usePrivy();
        ```

        When invoked, the method will open the Privy modal and guide the user through updating their existing email to a new one. If a user does not already have an email account and attempts to update it, Privy will throw an error indicating such.

        ### Example

        ```tsx
        import {usePrivy} from '@privy-io/react-auth';

        function Page() {
          const {ready, authenticated, user, updateEmail} = usePrivy();

          return (
            <button onClick={updateEmail} disabled={!ready || !authenticated || !user.email}>
              Update your email
            </button>
          );
        }
        ```

        <Info>
          In the event that a user encounters an error through the flow, their existing account will be maintained.
        </Info>
      </Tab>

      <Tab title="Phone Number">
        To prompt users to change their phone number, you can use the `updatePhone` method from the `usePrivy` hook:

        ```tsx
        updatePhone: () => void
        ```

        ### Usage

        ```tsx
        import {usePrivy} from '@privy-io/react-auth';
        const {updatePhone} = usePrivy();
        ```

        When invoked, the method will open the Privy modal and guide the user through updating their existing phone number to a new one. If a user does not already have a phone account and attempts to update it, Privy will throw an error indicating such.

        ### Example

        ```tsx
        import {usePrivy} from '@privy-io/react-auth';

        function Page() {
          const {ready, authenticated, user, updatePhone} = usePrivy();

          return (
            <button onClick={updatePhone} disabled={!ready || !authenticated || !user.phone}>
              Update your phone number
            </button>
          );
        }
        ```

        <Info>
          In the event that a user encounters an error through the flow, their existing account will be maintained.
        </Info>
      </Tab>
    </Tabs>

    ### Callbacks

    To configure callbacks for Privy's `updateEmail` and `updatePhone` methods, use the `useUpdateAccount` hook:

    ```tsx
    useUpdateAccount: ({
      onSuccess?: ({user, updateMethod, updatedAccount}) => void,
      onError?: (error, details) => void
    }) => {updateEmail: () => void, updatePhone: () => void}
    ```

    ### Usage

    ```tsx
    import {useUpdateAccount} from '@privy-io/react-auth';

    const {updateEmail, updatePhone} = useUpdateAccount({
      onSuccess: ({user, updateMethod, updatedAccount}) => {
        console.log(user, updateMethod, updatedAccount);
        // Any logic you'd like to execute if the user successfully updates an account
      },
      onError: (error, details) => {
        console.log(error, details);
        // Any logic you'd like to execute after a user exits the updateAccount flow or there is an error
      }
    });

    // Then call one of the update methods in your code, which will invoke these callbacks on completion
    ```

    ### Parameters

    The `useUpdateAccount` hook accepts an options object with the following fields:

    <ParamField path="onSuccess" type="({user: User, updateMethod: string, updatedAccount: LinkedAccountType}) => void">
      Optional callback to run after a user successfully updates an account.
    </ParamField>

    <ParamField path="onError" type="(error: string, details: {updateMethod: string}) => void">
      Optional callback to run if there is an error during the update account flow, or if the user exits the flow prematurely.
    </ParamField>

    ### Callback Details

    #### onSuccess

    If set, the `onSuccess` callback will execute after a user has successfully updated either their phone or email on their Privy account.

    Within this callback, you can access:

    <ResponseField name="user" type="User">
      The user object with the user's DID, linked accounts, and more.
    </ResponseField>

    <ResponseField name="updateMethod" type="string">
      A string indicating the type of update flow just executed for the authenticated user.
      Possible values are `'email'` or `'sms'`.
    </ResponseField>

    <ResponseField name="updatedAccount" type="LinkedAccountType">
      An object representing the account that was just updated on the authenticated user.
    </ResponseField>

    <details>
      <summary><b>See an example of using the onSuccess callback for updating an account!</b></summary>

      As an example, you might configure an `onSuccess` callback to support the following behavior:

      * If the user updates an email to their account, add the new updated email to your own Users DB.

      Below is a template for implementing the above with `onSuccess`:

      ```tsx
      const {updateEmail, updatePhone} = useUpdateAccount({
        onSuccess: ({user, updatedAccount}) => {
          if (updatedAccount === 'email') {
            // show a toast, send analytics event, etc...
          } else if (updatedAccount === 'sms') {
            // show a toast, send analytics event, etc...
          }
        }
      });
      ```
    </details>

    #### onError

    If set, the `onError` callback will execute after a user initiates an update account attempt and there is an error, or if the user exits the update account flow prematurely.

    Within this callback, you can access:

    <ResponseField name="error" type="string">
      The error code with more information about the error.
    </ResponseField>

    <ResponseField name="details.updateMethod" type="string">
      A string indicating the type of update account flow just attempted for the authenticated user.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Email">
        To update a user's email, use the `useUpdateEmail` hook:

        ```tsx
        const {sendCode, updateEmail} = useUpdateEmail();
        ```

        ### Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new email address:

        ```tsx
        sendCode: ({newEmailAddress: string}) => Promise<void>
        ```

        ### Usage

        ```tsx
        import {useUpdateEmail} from '@privy-io/expo';
        const {sendCode} = useUpdateEmail();
        ```

        ### Parameters

        <ParamField path="newEmailAddress" type="string">
          The new email address to be validated.
        </ParamField>

        This will send a one-time passcode to the new email address, which the user will need to enter to verify it and confirm the update.
        The method returns a `Promise` that resolves if the code was sent successfully, and rejects otherwise.

        ### Example

        ```tsx
        import {useUpdateEmail} from '@privy-io/expo';

        function UpdateEmailForm() {
          const {sendCode} = useUpdateEmail();

          const [newEmailAddress, setNewEmailAddress] = useState('');

          return (
            <View>
              <Input value={newEmailAddress} onChangeText={setNewEmailAddress} />
              <Button onPress={() => sendCode({newEmailAddress})}>Send code</Button>
            </View>
          );
        }
        ```

        ### Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by passing it to the `updateEmail` method:

        ```tsx
        updateEmail: ({newEmailAddress: string, code: string}) => Promise<User>
        ```

        ### Usage

        ```tsx
        import {useUpdateEmail} from '@privy-io/expo';
        const {updateEmail} = useUpdateEmail();
        ```

        ### Parameters

        <ParamField path="newEmailAddress" type="string">
          The new email address to set.
        </ParamField>

        <ParamField path="code" type="string">
          The one time code received on the new email address.
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<User>">
          A `Promise` that resolves with the updated user object if the update was successful, and rejects otherwise.
        </ResponseField>

        ### Example

        ```tsx
        import {useUpdateEmail} from '@privy-io/expo';

        function ConfirmEmailUpdateForm() {
          const {updateEmail} = useUpdateEmail();

          const [code, setCode] = useState('');

          return (
            <View>
              <Input value={code} onChangeText={setCode} />
              <Button onPress={() => updateEmail({code, newEmailAddress})}>Confirm</Button>
            </View>
          );
        }
        ```
      </Tab>

      <Tab title="Phone Number">
        To update a user's phone number, use the `useUpdatePhone` hook:

        ```tsx
        const {sendCode, updatePhone} = useUpdatePhone();
        ```

        ### Send an OTP

        First, use the `sendCode` method to send an OTP verification code to the user's new phone number:

        ```tsx
        sendCode: ({newPhoneNumber: string}) => Promise<void>
        ```

        ### Usage

        ```tsx
        import {useUpdatePhone} from '@privy-io/expo';
        const {sendCode} = useUpdatePhone();
        ```

        ### Parameters

        <ParamField path="newPhoneNumber" type="string">
          The new phone number to be validated.
        </ParamField>

        This will send a one-time passcode to the new phone number, which the user will need to enter to verify it and confirm the update.
        The method returns a `Promise` that resolves if the code was sent successfully, and rejects otherwise.

        ### Example

        ```tsx
        import {useUpdatePhone} from '@privy-io/expo';

        function UpdatePhoneForm() {
          const {sendCode} = useUpdatePhone();

          const [newPhoneNumber, setNewPhoneNumber] = useState('');

          return (
            <View>
              <Input value={newPhoneNumber} onChangeText={setNewPhoneNumber} />
              <Button onPress={() => sendCode({newPhoneNumber})}>Send code</Button>
            </View>
          );
        }
        ```

        ### Verify the OTP

        Prompt the user for the OTP they received and verify the OTP by passing it to the `updatePhone` method:

        ```tsx
        updatePhone: ({newPhoneNumber: string, code: string}) => Promise<User>
        ```

        ### Usage

        ```tsx
        import {useUpdatePhone} from '@privy-io/expo';
        const {updatePhone} = useUpdatePhone();
        ```

        ### Parameters

        <ParamField path="newPhoneNumber" type="string">
          The new phone number to set.
        </ParamField>

        <ParamField path="code" type="string">
          The one time code received on the new phone number.
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<User>">
          A `Promise` that resolves with the updated user object if the update was successful, and rejects otherwise.
        </ResponseField>

        ### Example

        ```tsx
        import {useUpdatePhone} from '@privy-io/expo';

        function ConfirmPhoneUpdateForm() {
          const {updatePhone} = useUpdatePhone();

          const [code, setCode] = useState('');

          return (
            <View>
              <Input value={code} onChangeText={setCode} />
              <Button onPress={() => updatePhone({code, newPhoneNumber})}>Confirm</Button>
            </View>
          );
        }
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Handling Events
Source: https://docs.privy.io/user-management/users/webhooks/handling-events



When a user makes an action in your application, Privy will emit a webhooks payload with the following fields:

## Webhook example payloads

Webhook payloads generally have two different formats. Both formats include a `user` object that is the same structure as what [the user REST API](/user-management/users/the-user-object) returns. For webhook events that involve an account change, we will include an `account` object that represents the changed account. For example, in a `user.unlinked_account` event, the `account` value will be the account that was just removed, so it will no longer exist on the `user`.

Example payload for different webhook events:

<CodeGroup>
  ```json user.created
  {
    "type": "user.created",
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.authenticated
  {
    "type": "user.authenticated",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.linked_account
  {
    "type": "user.linked_account",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.unlinked_account
  {
    "type": "user.unlinked_account",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.updated_account
  {
    "type": "user.updated_account",
    "account": {
      "address": "bilbo@privy.io",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "email",
      "verified_at": 969628260
    },
    "user": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        }
      ],
      "mfa_methods": []
    }
  }
  ```

  ```json user.transferred_account
  {
    "type": "user.transferred_account",
    "fromUser": {
      "id": "did:privy:clu2wsin402h9h9kt6ae7dfuh"
    },
    "toUser": {
      "created_at": 969628260,
      "has_accepted_terms": false,
      "id": "did:privy:cfbsvtqo2c22202mo08847jdux2z",
      "is_guest": false,
      "linked_accounts": [
        {
          "address": "bilbo@privy.io",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "email",
          "verified_at": 969628260
        },
        {
          "address": "+1234567890",
          "first_verified_at": 969628260,
          "latest_verified_at": 969628260,
          "type": "phone",
          "verified_at": 969628260
        }
      ]
    },
    "account": {
      "address": "+1234567890",
      "first_verified_at": 969628260,
      "latest_verified_at": 969628260,
      "type": "phone",
      "verified_at": 969628260
    },
    "deletedUser": true
  }
  ```

  ```json mfa.enabled
  {
    "type": "mfa.enabled",
    "user_id": "user_123",
    "method": "sms"
  }
  ```

  ```json mfa.disabled
  {
    "type": "mfa.disabled",
    "user_id": "user_123",
    "method": "sms"
  }
  ```

  ```json private_key.exported
  {
    "type": "private_key.exported",
    "user_id": "user_123",
    "wallet_id": "wallet_123",
    "wallet_address": "0x123...",
  }
  ```

  ```json wallet.recovery_setup
  {
    "type": "wallet.recovery_setup",
    "user_id": "user_123",
    "wallet_id": "wallet_123",
    "wallet_address": "0x123...",
    "method": "passkey"
  }
  ```

  ```json wallet.recovered
  {
    "type": "wallet.recovered",
    "user_id": "user_123",
    "wallet_id": "wallet_123",
    "wallet_address": "0x123...",
  }
  ```

  ```json privy.test
  {
    "type": "privy.test",
    "message": "Hello, World!"
  }
  ```
</CodeGroup>

## Webhook signing key

The webhook signing key is necessary to verify that the payloads sent to your endpoint are from Privy. Follow the steps below in order to set up webhook verification in your backend.

<Accordion title="Verifying a webhook payload">
  Webhook payloads must be verified before they are trusted and used on your server. This is done by verifying a signature sent with your webhook. Privy uses [`svix`](https://www.svix.com/) for webhooks infrastructure.

  <Tip>
    Your endpoint must return a 2xx (status code 200-299) response for the webhook to be marked as
    delivered. Any other statuses (including 3xx) are considered failed deliveries. Your endpoint will
    be automatically disabled after 5 consecutive days of delivery failures
  </Tip>

  ## Using `@privy-io/server-auth`

  Use the **`PrivyClient`**'s **`verifyWebhook`** method to verify an incoming webhook. Pass in the request body, headers, and signing key (from the Privy Dashboard). As an example, for a NextJS API request, you can verify a webhook using the code below:

  ```tsx
  // req is an input of type `NextApiRequest`

  const privy = new PrivyClient(
    process.env.PRIVY_APP_ID as string,
    process.env.PRIVY_APP_SECRET as string
  );

  // Get the request's `id`, `timestamp`, and `signature`
  // These are sent in the `'svix-id'`, `'svix-timestamp'`, and `'svix-signature'` headers respectively
  const id = req.headers['svix-id'] ?? '';
  const timestamp = req.headers['svix-timestamp'] ?? '';
  const signature = req.headers['svix-signature'] ?? '';

  const verifiedPayload = await privy.verifyWebhook(
    req.body,
    {id, timestamp, signature},
    'insert-your-webhook-signing-key-from-the-dashboard'
  );
  ```

  If the webhook payload is valid, the method will return the payload back. If the webhook payload is invalid, the method will throw an error.

  ## Manual verification

  In order to verify an incoming webhook, please refer to svix's [manual verification guide](https://docs.svix.com/receiving/verifying-payloads/how-manual) or [library verification guide](https://docs.svix.com/receiving/verifying-payloads/how).
</Accordion>


# null
Source: https://docs.privy.io/user-management/users/webhooks/overview



Webhooks allow you to specify a backend endpoint that Privy will call with a signed payload whenever a user makes an action in your application, such as logging in, or linking a new account. As soon as you register an endpoint, Privy will start sending subscribed events in near real-time.

<Info>
  Webhooks is currently a pro feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

![images/Webhooks.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Webhooks.png)

## Registering an endpoint

1. In your backend, create a new endpoint that will accept **POST** requests from Privy

   <Tip>
     When creating your endpoint to receive webhook events, always verify the payload signature by
     following our [@privy-io/server-auth webhook
     documentation](/user-management/users/webhooks/handling-events#webhook-signing-key`).
   </Tip>

2. In the dashboard, go to the **Configuration > Webhooks** page

3. Add your new endpoint as the destination URL and select any event types you'd like to be notified for

You can specify which user events your webhook endpoint will be notified about. The options are as follows:

| Event Name               | Type                      | Action                                                                         |
| ------------------------ | ------------------------- | ------------------------------------------------------------------------------ |
| User created             | user.created              | A user was created in the application.                                         |
| User authenticated       | user.authenticated        | A user successfully logged into the application.                               |
| User linked account      | user.linked\_account      | A user successfully linked a new login method.                                 |
| User unlinked account    | user.unlinked\_account    | A user successfully unlinked an existing login method.                         |
| User updated account     | user.updated\_account     | A user successfully updates the email or phone number linked to their account. |
| User transferred account | user.transferred\_account | A user successfully transferred their account to a new account.                |
| Wallet created for user  | user.wallet\_created      | A wallet (embedded or smart wallet) was successfully created for a user.       |
| MFA enabled              | mfa.enabled               | A user has enabled MFA for their account.                                      |
| MFA disabled             | mfa.disabled              | A user has disabled MFA for their account.                                     |
| Private key exported     | private\_key.exported     | A user has exported their private key from an embedded wallet.                 |
| Wallet recovery setup    | wallet.recovery\_setup    | A user has set up wallet recovery for their embedded wallet.                   |
| Wallet recovered         | wallet.recovered          | A user has successfully recovered their embedded wallet.                       |

**That's it! You've successfully configured webhooks for your app.** 🎉

### Testing the webhook endpoint

Clicking the button once webhooks are configured for your application will trigger a test webhook (`privy.test`) to be sent to your endpoint of type with a string payload. You can use this to verify that your webhook endpoint is successfully receiving payloads from Privy.

## Retry behavior

Your endpoint must return a 2xx response for the webhook delivery to be considered successful. Anything else is considered an error response, and will be retried based on the following schedule, where each period is started following the failure of the preceding attempt:

* Immediately
* 5 seconds
* 5 minutes
* 30 minutes
* 2 hours
* 5 hours
* 10 hours
* 10 hours (in addition to the previous)

After the final attempt, the message will be marked as a failure, and must be manually retried from the dashboard. If all attempts to your endpoint fail for 5 consecutive days, your endpoint will be automatically disabled.

## Static IPs

Webhooks will be delivered from the following list of IP addresses:

```
44.228.126.217
50.112.21.217
52.24.126.164
54.148.139.208
2600:1f24:64:8000::/52
```


# Prompt users to auth new devices
Source: https://docs.privy.io/wallets/advanced-topics/new-devices/auth



<Tabs>
  <Tab title="React">
    The React SDK will automatically prompt users for their auth factor on new devices when they use their wallet. There is no additional logic your application must implement to handle this.
  </Tab>

  <Tab title="React Native">
    When a user uses their embedded wallet on a new device for the first time, the wallet must first be recovered on that device

    By default, wallets created for your users will be [automatically provisioned](/wallets/overview) and should never need recovery. For these wallets, you can skip these steps and directly request a signature or transaction.

    <Info>
      For wallets where the `recovery_method` is `'privy'` the wallet will be automatically recovered
      and should never need recovery. For these wallets, you can skip these steps and directly request a
      signature or transaction.
    </Info>

    ### Setting up your recovery listener

    The wallet must be recovered before you can request signatures or transact with the embedded wallet.
    The React Native SDK will try to recover the user's wallet once you start interacting with it.
    We recommend that you set up a global listener on your application to handle manual recovery in a single place.

    To set up this configuration, use Privy's `useOnNeedsRecovery` hook.
    AS a parameter, you must pass in an object defining the the `onNeedsRecovery` callback.

    `onNeedsRecovery` will receive two parameters to drive what recovery looks like:

    | Parameter        | Type                                                                                    | Description                                                                                          |
    | ---------------- | --------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
    | `recoveryMethod` | `"privy" \| "user-passcode" \| "google-drive" \| "icloud" \| "recovery-encryption-key"` | An enum representing the recovery method used for this user.                                         |
    | `onRecovered`    | `() => void`                                                                            | This is a callback function you should call once recovery has been completed. It takes no arguments. |

    ```ts
    // This could live in a different screen,
    // e.g. if you navigate to a recovery screen when the listener is triggered
    const {recover} = useRecoverEmbeddedWallet();

    useOnNeedsRecovery({
      onNeedsRecovery: async ({recoveryMethod, onRecovered}) => {
        if (recoveryMethod === 'user-passcode') {
          // Get the passcode from the user, e.g. by prompting some UI
          const password = 'user-provided-passcode';
          await recover({recoveryMethod, password});
          // Remember to call this after recovery has been completed.
          onRecovered();
        }
      }
    });
    ```

    ### Recovering the wallet

    **To recover an embedded wallet for your user, use the `recover` function returned by the Privy React Native SDK's `useRecoverEmbeddedWallet` hook.**

    You can determine the proper arguments for `recover` via the `account.recovery_method` property on the embedded wallet account:

    * `user-passcode`, call `recover` with `recoveryMethod: 'user-passcode'` and the user input `password`.
    * `google-drive`, call recover with `recoveryMethod: 'google-drive'`.
    * `icloud`, call recover with `recoveryMethod: 'icloud'`. *Note: this is only supported on iOS devices*.

     
  </Tab>
</Tabs>


# Configure cloud recovery of embedded wallets on new devices
Source: https://docs.privy.io/wallets/advanced-topics/new-devices/cloud-recovery



Follow this guide to configure **cloud-based recovery** of embedded wallets in the Privy Dashboard.

## Google Drive

To enable Google Drive recovery for your app, you must also enable Google as a social login method. To do so, follow the guidance [here](/basics/get-started/dashboard/configure-login-methods).

When enabling Google as a login method, we strongly recommend that you configure your own OAuth credentials, as these credentials cannot be changed once Google Drive recovery is enabled. We **strongly** recommend that you configure your own credentials before enabling Google Drive as a login method.

<Tip>
  After creating your own Google OAuth credentials, you must enable the [Google Drive
  API](https://console.cloud.google.com/apis/library/drive.googleapis.com) on your OAuth app to use
  Google Drive-based recovery.
</Tip>

After setting up Google as a login method and configure your own OAuth credentials, visit the **User management > Authentication > MFA** tab of the Privy Dashboard. In the **Enable user-managed recovery** section, enable **Google Drive** as a user-managed recovery option.

### FAQ

**Do I need to bring my own Google OAuth credentials in order to enable recovery?**

No, however once you’ve enabled recovery, you cannot update your credentials so consider setting your own before you enable it.

**Does auth have to be enabled to enable to the recovery method?**

Yes, in order to enable Google Drive recovery, you must enable Google as a login method in your Privy dashboard.

**Should I implement recovery in my app or enable it in the Dashboard first?**

You should enable Google Drive as a recovery method for your app before beginning implementation, so it will work properly while you integrate and test. There are no negative side effects if you enable Google Drive recovery in the dashboard but do not have it implemented.

## iCloud

iCloud recovery uses [CloudKit](https://developer.apple.com/icloud/cloudkit/) in order to store a recovery secret to iCloud (via a CloudKit database). This is a separate authentication mechanism from using Apple as a social login method, and does not share the same configuration. This discrepancy is invisible to the end user, who will log into their standard iCloud account to authorize recovery.

<Info>
  iCloud recovery is supported in both React and Expo (iOS). Other SDKs, as well as Expo (Android)
  are not supported.
</Info>

<Info>
  iCloud recovery with Privy *always* uses the production CloudKit environment. This does not
  interfere with you using the development environment for non-Privy CloudKit testing, and does not
  stop you from testing Privy recovery in any of your application environments.
</Info>

<Warning>
  Only a singular Allowed App URL Scheme (i.e. `myapp://`) is permitted when using iCloud recovery
  with Expo. If you need to support multiple URL schemes, such as for multiple environments, you
  will need to have distinct Privy app IDs.
</Warning>

### 1. Set up a CloudKit container

If you do not have a CloudKit container already setup, you will need to scaffold one (if you do, you can use your existing!). This can be done via Xcode (in the **iCloud** section of the **Signing & Capabilities** Target menu) or by connecting a CloudKit container to your app's bundle identifier (via the [Apple Developer Portal](https://developer.apple.com/)). See [Apple's documentation](https://developer.apple.com/icloud/cloudkit/) for detail.

### 2. Add the Privy wallet schema

To start, configure your CloudKit schema.

Privy stores user recovery secrets to a specific private CloudKit schema that must be imported. The schema (shown below) can be copied into a local `.ckdb` file.

```
DEFINE SCHEMA

    RECORD TYPE PrivyWallets (
        "___createTime" TIMESTAMP,
        "___createdBy"  REFERENCE,
        "___etag"       STRING,
        "___modTime"    TIMESTAMP,
        "___modifiedBy" REFERENCE,
        "___recordID"   REFERENCE QUERYABLE,
        app_id          STRING,
        recovery_secret STRING,
        user_id         STRING,
        wallet_address  STRING
    );
```

This file can the be imported into CloudKit using the `Import Schema` link in the CloudKit dashboard sidebar.

Once imported, deploy the added schema to Production. You should **only** use this production CloudKit deployment going forward, including for your development or staging Privy app IDs.

### 3. Add tokens to CloudKit

Next, add tokens to your production CloudKit deployment to allow Privy's API to interface with it.

Due to platform implementation requirements, Expo and Web have distinct token types. If targeting both platforms, you will need to configure tokens for each.

<Warning>Ensure that you are adding tokens to your CloudKit **production** deployment.</Warning>

#### Expo

* Create a new **API Token** with a descriptive name such as `Privy Recovery - Expo`
* Set **Sign in Callback** to `auth.privy.io/api/v1/recovery/oauth/callback_icloud/YOUR_APP_ID/expo_ios`, where `YOUR_APP_ID` is the ID of your Privy app. Apple will automatically prefix your URL with the protocol `https://`, so you should not set it yourself.
* Leave the rest of the fields as their default values

#### Web

* Create a new **API Token** with a descriptive name such as `Privy Recovery - Web`
* Set **Sign in Callback** to **Post Message**
* Leave the rest of the fields as their default values

### 4. Enter your CloudKit details in the Privy Dashboard

After setting up CloudKit, visit the **User management > Authentication > MFA** tab of the [Privy Dashboard](https://dashboard.privy.io). In the **Recovery** tab, enable **iCloud** as a user-managed recovery option.

Enter your **container ID** and appropriate **API token(s)**.

**That's it!** If you've configured your CloudKit production deployment with Privy correctly, you should be able to start using iCloud as a user-managed recovery method for embedded wallets.

### FAQ

**Should I implement recovery in my app or enable it in the Dashboard first?**

You should enable iCloud as a recovery method for your app before beginning implementation, so it will work properly while you integrate and test. There are no negative side effects if you enable iCloud recovery in the dashboard but do not have it implemented.

**Does my native iOS app need to be deployed to production to use CloudKit?**

No, you're able to deploy a CloudKit container to Production out of band with the native app it was created from.

**Will I have access to my user's recovery secrets?**

No, *only your users* will have access to their stored recovery secrets. Even the CloudKit database is created by you, only a successfully authorized iCloud user can access their data.

**Do I need to bring my own CloudKit configuration order to enable recovery?**

Yes, there's no way to use an out-of-the-box Privy configuration for iCloud recovery.

**Does Apple auth have to be enabled to enable to the recovery method?**

No, they are decoupled.


# Enroll auth factors for new devices
Source: https://docs.privy.io/wallets/advanced-topics/new-devices/enroll



Set user-controlled recovery on the embedded wallet, and to attach callbacks to the wallet's recovery events.

<Tabs>
  <Tab title="React">
    To prompt users to enroll an auth factor for new devices for their wallet, use the `setWalletRecovery` method from the `useSetWalletRecovery` hook:

    ```tsx
    setWalletRecovery: async () => Promise<void>
    ```

    When invoked, this method will open a modal where the user can enroll an auth factor for new devices from the options (password, iCloud, Google Drive) you configured in the Dashboard.

    ### Usage

    ```tsx
    import {useSetWalletRecovery} from '@privy-io/react-auth';
    const {setWalletRecovery} = useSetWalletRecovery();
    ```

    ### Parameters

    This method takes no parameters.

    ### Returns

    This method returns a `Promise` that resolves if the user successfully enrolls an auth factor, and rejects if there is an error.

    ### Callbacks

    You can optionally register an onSuccess or onError callback on the useSetWalletRecovery hook.

    ### Usage

    ```tsx
    const {setWalletRecovery} = useSetWalletRecovery({
        onSuccess: (params: {
            method: UserRecoveryMethod;
            wallet: Wallet;
        }) => {
            console.log('Successfully enrolled auth factor');
        },
        onError: (error) => {
            console.error('Failed to enroll auth factor with error ', error)
        }
    })
    ```

    <ParamField path="onSuccess" type="({method: UserRecoveryMethod, wallet: Wallet}) => void">
      Optional callback to run after a user successfully enrolls an auth factor.
    </ParamField>

    <ParamField path="onError" type="(error: string) => void">
      Optional callback to run after there is an error during wallet recovery.
    </ParamField>
  </Tab>

  <Tab title="React Native">
    To prompt users to enroll an auth factor for new devices for their wallet, use the `setEmbeddedWalletRecovery` method from the `useSetWalletRecovery` hook:

    ```tsx
    setEmbeddedWalletRecovery: async () => Promise<void>
    ```

    ### Usage

    ```tsx
    import {useSetEmbeddedWalletRecovery} from '@privy-io/expo';
    const {setEmbeddedWalletRecovery} = useSetEmbeddedWalletRecovery();
    ```

    ### Parameters

    This method accepts an object as a parameter with the following fields.

    <ParamField path="recoveryMethod" type="'password' | 'google-drive' | 'icloud'" required>
      The recovery method (auth factor) to enroll for the wallet.
    </ParamField>

    <ParamField path="password" type="string">
      Password to set on the wallet. Only valid if `recoveryMethod` is `'password'`.
    </ParamField>

    ### Returns

    This method returns a `Promise` that resolves if the user successfully enrolls an auth factor, and rejects if there is an error.
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/wallets/advanced-topics/new-devices/overview



Once a user has created a embedded wallet, when they attempt to use the wallet on a *new* device, the key material for their wallet must be provisioned on that device.

In most cases, once a user authenticates on a new device, Privy automatically orchestrates reconstitution of the key material for their wallet on that device. This requires no additional action from the user and allows them to seamlessly use their wallet on any device where they are authenticated.

In self-custodial setups, you can also require users to input a password or authenticate with their cloud account (iCloud, Google Drive) in order to reconstitute their wallet on a new device. Follow the steps below to enable this setting.

<Warning>
  Additional authentication factors for device provisioning can be reset on a provisioned device, but **if a user loses all provisioned devices and their additional factor, they will be locked out of their account.**

  Read more [more about Privy's self-custodial architecture](/security/wallet-infrastructure/architecture).
</Warning>

<Steps>
  <Step title="Configure authentication factors for new devices.">
    Visit the **Authentication** page for your app in the Privy Dashboard and navigate to the
    **MFA** tab. Then, select the authentication factors (password, Google Drive backup, or iCloud
    backup) you'd like to offer users for new devices. [Learn
    more](/wallets/advanced-topics/new-devices/cloud-recovery)
  </Step>

  <Step title="Prompt users to enroll authentication factors for new devices.">
    Once users have created a wallet, prompt your users to enroll authentication factors for new
    devices per [this guide](/wallets/advanced-topics/new-devices/enroll). Alternatively, to
    automatically prompt users to enroll authentication factors for new devices, toggle the
    **Require additional authentication for new devices** setting on.
  </Step>

  <Step title="Prompt users to authenticate when using the wallet on a new device.">
    When users log in on a new device, prompt them to authenticate with their additional factor per
    [this guide](/wallets/advanced-topics/new-devices/auth).
  </Step>
</Steps>


# null
Source: https://docs.privy.io/wallets/connectors/ethereum/ethereum-provider



## Getting an EIP-1193 provider

All of Privy's **`ConnectedWallet`** objects export a standard [EIP-1193 provider](https://eips.ethereum.org/EIPS/eip-1193) object. This allows your app to request signatures and transactions from the wallet, using familiar JSON-RPC requests like `personal_sign` or `eth_sendTransaction`.

<Info>
  [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193), also known as the Ethereum JavaScript API, is
  a standardized interface for how applications can request information, signatures, and
  transactions from a connected wallet.
</Info>

To request signatures or transactions from a connected wallet, you can either:

* use the wallet's EIP-1193 provider to send JSON-RPC requests to the wallet directly
* pass the wallet to a library like `viem`, `ethers`, or `wagmi`
* for the embedded wallet specifically, use Privy's native **`signMessage`** and **`sendTransaction`** methods to customize the signature and transaction prompts for users

To get a wallet's EIP-1193 provider, use the **`ConnectedWallet`** object's **`getEthereumProvider`** method:

```tsx
const provider = await wallet.getEthereumProvider();
```

When requesting signatures and transactions from the wallet, you can either choose to interface with the EIP1193 provider directly, or to pass it to a library like `wagmi` or `viem`.


# Integrating with ethers
Source: https://docs.privy.io/wallets/connectors/ethereum/integrations/ethers



## Ethers

Privy is fully compatible with ethers.js. To get an ethers provider for a user's connected wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and switch it to your desired network, using the wallet's **`switchChain`** method:

### Ethers v5

```tsx
const privyProvider = await wallet.getEthereumProvider();
const provider = new ethers.providers.Web3Provider(privyProvider);
```

### Ethers v6

```tsx
const provider = await wallet.getEthereumProvider();
const ethersProvider = new ethers.BrowserProvider(provider);
const signer = ethersProvider.getSigner();
```


# Integrating with viem
Source: https://docs.privy.io/wallets/connectors/ethereum/integrations/viem



Viem represents connected wallets as a [**wallet client**](https://viem.sh/docs/clients/wallet.html) object, which you can use to get information about the current wallet or the request signatures and transactions.

To get a viem wallet client for a user's connected wallet, first import your desired network from the **`viem/chains`** package and import the **`createWalletClient`** method and **`custom`** transport from **`viem`**:

```tsx
import {createWalletClient, custom} from 'viem';
// Replace `sepolia` with your desired network
import {sepolia} from 'viem/chains';
```

Then, find your desired wallet from the **`wallets`** array and switch its network to the chain you imported, using the wallet's **`switchChain`** method:

```tsx
const {wallets} = useWallets();
const wallet = wallets[0]; // Replace this with your desired wallet
await wallet.switchChain(sepolia.id);
```

Lastly, get the wallet's EIP1193 provider using the wallet's **`getEthereumProvider`** method and pass it to viem's **`createWalletClient`** method like so:

```tsx
const provider = await wallet.getEthereumProvider();
const walletClient = createWalletClient({
    account: wallet.address as Hex,
    chain: sepolia,
    transport: custom(provider),
});
```

You can then use the [**wallet client**](https://viem.sh/docs/clients/wallet) to get information about the wallet or request signatures and transactions.


# Integrating with wagmi
Source: https://docs.privy.io/wallets/connectors/ethereum/integrations/wagmi



[Wagmi](https://wagmi.sh/) is a set of React hooks for interfacing with Ethereum wallets, allowing you read wallet state, request signatures or transactions, and take read and write actions on the blockchain.

**Privy is fully compatible with [wagmi](https://wagmi.sh/), and you can use [wagmi](https://wagmi.sh/)'s React hooks to interface with external and embedded wallets from Privy.** Just follow the steps below!

## Integration steps

This guide assumes you have already integrated Privy into your app. If not, please begin with the Privy [Quickstart](/basics/react/quickstart).

### 1. Install dependencies

Install the latest versions of [**`wagmi`**](https://www.npmjs.com/package/wagmi), [**`@tanstack/react-query`**](https://www.npmjs.com/package/@tanstack/react-query), [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth), and [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi):

```sh
npm i wagmi @privy-io/react-auth @privy-io/wagmi @tanstack/react-query
```

### 2. Setup TanStack Query

To start, set up your app with the [TanStack Query's React Provider](https://tanstack.com/query/v5/docs/framework/react/overview). Wagmi uses TanStack Query under the hood to power its data fetching and caching of wallet and blockchain data.

To set up your app with TanStack Query, in the component where you render your **`PrivyProvider`**, import the [**`QueryClient`**](https://tanstack.com/query/v4/docs/reference/QueryClient) class and the [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) component from [**`@tanstack/react-query`**](https://www.npmjs.com/package/@tanstack/react-query):

```tsx
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
```

Next, create a new instance of the [**`QueryClient`**](https://tanstack.com/query/v4/docs/reference/QueryClient):

```tsx
const queryClient = new QueryClient();
```

Then, like the **`PrivyProvider`**, wrap your app's components with the [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider). This must be rendered *inside* the **`PrivyProvider`** component.

```tsx providers.tsx
<PrivyProvider appId="your-privy-app-id" config={insertYourPrivyConfig}>
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
</PrivyProvider>
```

For the [**`client`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) property of the [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider), pass the [**`queryClient`**](https://tanstack.com/query/v4/docs/reference/QueryClient) instance you created.

### 3. Setup wagmi

Next, setup wagmi. This involves creating your wagmi **`config`** and wrapping your app with the **`WagmiProvider`**.

<Warning>
  While completing the wagmi setup, make sure to import `createConfig` and `WagmiProvider` from
  `@privy-io/wagmi`. Do not import these from `wagmi` directly.
</Warning>

#### Build your wagmi config

To build your [**`wagmi`**](https://wagmi.sh) config, import the `createConfig` method from [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi):

```tsx wagmiConfig.ts
import {createConfig} from '@privy-io/wagmi';
```

This is a drop-in replacement for [wagmi's native **`createConfig`**](https://wagmi.sh/react/getting-started#create-config), but ensures that the appropriate configuration options are set for the Privy integration. Specifically, it allows Privy to drive wagmi's connectors state, enabling the two libraries to stay in sync.

Next, import your app's required chains from [**`viem/chains`**](https://viem.sh/docs/chains/introduction.html) and the [**`http`**](https://wagmi.sh/core/api/transports/http#http) transport from [**`wagmi`**](https://www.npmjs.com/package/wagmi). Your app's required chains should match whatever you configure as [**`supportedChains`**](/basics/react/advanced/configuring-evm-networks#supported-chains) for Privy.

```tsx
import {mainnet, sepolia} from 'viem/chains';
import {http} from 'wagmi';

// Replace this with your app's required chains
```

Lastly, call `createConfig` with your imported chains and the [**`http`**](https://wagmi.sh/core/api/transports/http#http) transport like so:

```tsx wagmiConfig.ts
// Make sure to import `createConfig` from `@privy-io/wagmi`, not `wagmi`
import {createConfig} from '@privy-io/wagmi';
...
export const config = createConfig({
  chains: [mainnet, sepolia], // Pass your required chains as an array
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
    // For each of your required chains, add an entry to `transports` with
    // a key of the chain's `id` and a value of `http()`
  },
});
```

#### Wrap your app with the `WagmiProvider`

Once you've built your wagmi `config`, in the same component where you render your **`PrivyProvider`**, import the `WagmiProvider` component from [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi).

```tsx
import {WagmiProvider} from '@privy-io/wagmi';
```

This is a drop-in replacement for [wagmi's native **`WagmiProvider`**](https://wagmi.sh/react/api/WagmiProvider#wagmiprovider), but ensures the necessary configuration properties for Privy are set. Specifically, it ensures that the [**`reconnectOnMount`**](https://wagmi.sh/react/api/WagmiProvider#reconnectonmount) prop is set to false, which is required for handling the embedded wallet. Wallets will still be automatically reconnected on mount.

Then, like the **`PrivyProvider`**, wrap your app's components with the `WagmiProvider`. This must be rendered *inside* both the **`PrivyProvider`** and [**`QueryClientProvider`**](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider) components.

```tsx providers.tsx
import {PrivyProvider} from '@privy-io/react-auth';
// Make sure to import `WagmiProvider` from `@privy-io/wagmi`, not `wagmi`
import {WagmiProvider} from '@privy-io/wagmi';
import {QueryClientProvider} from '@tanstack/react-query';
...
<PrivyProvider appId='insert-your-privy-app-id' config={insertYourPrivyConfig}>
  <QueryClientProvider client={queryClient}>
    <WagmiProvider config={config}>
      {children}
    </WagmiProvider>
  </QueryClientProvider>
</PrivyProvider>
```

For the `config` property of the `WagmiProvider`, pass the `config` you created earlier.

#### Complete example

Altogether, this should look like:

<Tabs>
  <Tab title="providers.tsx">
    ```tsx
    import {QueryClient, QueryClientProvider} from '@tanstack/react-query';

    import {PrivyProvider} from '@privy-io/react-auth';
    // Make sure to import these from `@privy-io/wagmi`, not `wagmi`
    import {WagmiProvider, createConfig} from '@privy-io/wagmi';

    import {privyConfig} from './privyConfig';
    import {wagmiConfig} from './wagmiConfig';

    const queryClient = new QueryClient();

    export default function Providers({children}: {children: React.ReactNode}) {
      return (
        <PrivyProvider appId="insert-your-privy-app-id" config={privyConfig}>
          <QueryClientProvider client={queryClient}>
            <WagmiProvider config={wagmiConfig}>{children}</WagmiProvider>
          </QueryClientProvider>
        </PrivyProvider>
      );
    }
    ```
  </Tab>

  <Tab title="wagmiConfig.ts">
    ```tsx
    import {mainnet, sepolia} from 'viem/chains';
    import {http} from 'wagmi';

    import {createConfig} from '@privy-io/wagmi';

    // Replace these with your app's chains

    export const config = createConfig({
      chains: [mainnet, sepolia],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
      },
    });
    ```
  </Tab>

  <Tab title="privyConfig.ts">
    ```tsx
    import type {PrivyClientConfig} from '@privy-io/react-auth';

    // Replace this with your Privy config
    export const privyConfig: PrivyClientConfig = {
      embeddedWallets: {
        createOnLogin: 'users-without-wallets',
        requireUserPasswordOnCreate: true,
        showWalletUIs: true
      },
      loginMethods: ['wallet', 'email', 'sms'],
      appearance: {
        showWalletLoginFirst: true
      }
    };
    ```
  </Tab>
</Tabs>

**That's it! You've successfully integrated Privy alongside [`wagmi`](https://wagmi.sh) in your app! 🎉**

### 4. Use `wagmi` throughout your app

Once you've completed the setup above, you can use [**`wagmi`**](https://wagmi.sh)'s React hooks throughout your app to interface with wallets and take read and write actions on the blockchain.

#### Using `wagmi` hooks

To use [**`wagmi`**](https://wagmi.sh) hooks, like [**`useAccount`**](https://wagmi.sh/react/api/hooks/useAccount#useaccount), in your components, import the hook directly from [**`wagmi`**](https://wagmi.sh) and call it as usual:

```tsx
import {useAccount} from 'wagmi';

export default const WalletAddress = () => {
  const {address} = useAccount();
  return <p>Wallet address: {address}</p>;
}
```

<Info>
  Injected wallets, like the MetaMask browser extension, cannot be programmatically disconnected from your site; they can only be manually disconnected. In kind, Privy does not currently support programmatically disconnecting a wallet via wagmi's [`useDisconnect`](https://wagmi.sh/react/api/hooks/useDisconnect) hook. This hook "shims" a disconnection, which can create discrepancies between what wallets are connected to an app vs. wagmi.

  Instead of disconnecting a given wallet, you can always prompt a user to connect a different wallet via the [`connectWallet`](/wallets/connectors/usage/connecting-external-wallets) method.
</Info>

#### When to use Privy vs. `wagmi`

Both Privy's out-of-the-box interfaces and wagmi's React hooks enable you to interface with wallets and to request signatures and transactions.

If your app integrates Privy alongside wagmi, you should:

* use Privy to connect external wallets and create embedded wallets
* use [**`wagmi`**](https://wagmi.sh) to take read or write actions from a connected wallet

#### Updating the active wallet

With Privy, users may have multiple wallets connected to your app, but [**`wagmi`**](https://wagmi.sh)'s React hooks return information for only *one* connected wallet at a time. This is referred to as the **active wallet**.

To update [**`wagmi`**](https://wagmi.sh) to return information for a *different* connected wallet, first import the **`useWallets`** hook from [**`@privy-io/react-auth`**](https://www.npmjs.com/package/@privy-io/react-auth) and the `useSetActiveWallet` hook from [**`@privy-io/wagmi`**](https://www.npmjs.com/package/@privy-io/wagmi):

```tsx
import {useWallets} from '@privy-io/react-auth';
import {useSetActiveWallet} from '@privy-io/wagmi';
```

Then, find your desired active wallet from the **`wallets`** array returned by **`useWallets`**

```tsx
const {wallets} = useWallets();
// Replace this logic to find your desired wallet
const newActiveWallet = wallets.find((wallet) => wallet.address === 'insert-your-desired-address');
```

Lastly, pass your desired active wallet to the `setActiveWallet` method returned by the `useSetActiveWallet` hook:

```tsx
await setActiveWallet(newActiveWallet);
```

## Demo app

Check out our [wagmi demo app](https://wagmi-app.vercel.app) to see the hooks listed above in action.

Feel free to take a look at the [app's source code](https://github.com/privy-io/wagmi-demo/tree/main) to see an end-to-end implementation of Privy with wagmi.


# null
Source: https://docs.privy.io/wallets/connectors/ethereum/send-a-transaction



<Tabs>
  <Tab title="React">
    To request a transaction from a wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and get its EIP-1193 provider via its **`getEthereumProvider`** method:

    ```tsx
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    const provider = await wallet.getEthereumProvider();
    ```

    Then, using the provider's **`request`** method, send a [**`eth_sendTransaction`**](https://docs.metamask.io/wallet/reference/eth_sendtransaction/) JSON-RPC to the wallet. In the **`params`** array, include as the first entry an object containing the transaction's parameters, such as `to`, `value`, `data`, `gasLimit`, `maxPriorityFeePerGas`, `maxFeePerGas`, and `gasPrice`.

    ```tsx
    const transactionRequest = {
      to: '0xTheRecipientAddress',
      value: 100000
    };
    const transactionHash = await provider.request({
      method: 'eth_sendTransaction',
      params: [transactionRequest]
    });
    ```

    See [these docs](https://docs.metamask.io/wallet/reference/eth_sendtransaction/) for the parameters that can be passed in **`eth_sendTransaction`**.

    <Info>
      You do not need to specify `from` as we populate it from the user's connected wallet, and you can pass either a `number`, `bigint`, or a hexadecimal `string` into the `value` parameter.
    </Info>

    If you've integrated Privy with another web3 library, you can also use that library's syntax for requesting a transaction from the wallet:

    | Library                                                    | Method                                                                                                          |
    | ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
    | [Viem](/wallets/connectors/ethereum/integrations/viem)     | Use the wallet client's [**`sendTransaction`** method](https://viem.sh/docs/actions/wallet/sendTransaction).    |
    | [Ethers](/wallets/connectors/ethereum/integrations/ethers) | Use the signer's [**`sendTransaction`** method](https://docs.ethers.org/v5/api/signer/#Signer-sendTransaction). |
    | [Wagmi](/wallets/connectors/ethereum/integrations/wagmi)   | Use the [**`useSendTransaction`** hook](https://wagmi.sh/react/api/hooks/useSendTransaction).                   |

    <Info>
      When requesting a transaction from an embedded wallet, you can customize the transaction prompt by using Privy's native [sendTransaction](/wallets/using-wallets/ethereum/send-a-transaction) method.
    </Info>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/connectors/ethereum/sign-a-message



<Tabs>
  <Tab title="React">
    To request a signature from a wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and get its EIP-1193 provider via its **`getEthereumProvider`** method:

    ```tsx
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    const provider = await wallet.getEthereumProvider();
    ```

    Then, using the provider's **`request`** method, send a **`personal_sign`** JSON-RPC to the wallet. In the **`params`** array, include the message to sign as the first entry, and the wallet's address as the second entry.

    ```tsx
    const address = wallet.address;
    const message = 'This is the message I am signing';
    const signature = await provider.request({
      method: 'personal_sign',
      params: [message, address]
    });
    ```

    If you've integrated Privy with another web3 library, you can also use that library's syntax for requesting a signature from the wallet:

    | Library                                                    | Method                                                                                                  |
    | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
    | [Viem](/wallets/connectors/ethereum/integrations/viem)     | Use the wallet client's [**`signMessage`** method](https://viem.sh/docs/actions/wallet/signMessage).    |
    | [Ethers](/wallets/connectors/ethereum/integrations/ethers) | Use the signer's [**`signMessage`** method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage). |
    | [Wagmi](/wallets/connectors/ethereum/integrations/wagmi)   | Use the [**`useSignMessage`** hook](https://wagmi.sh/react/api/hooks/useSignMessage).                   |

    <Info>
      When requesting a signature from an embedded wallet, you can customize the signature prompt by using Privy's native [signMessage](/wallets/using-wallets/ethereum/sign-a-message) method.
    </Info>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/connectors/ethereum/sign-typed-data



<Tabs>
  <Tab title="React">
    To request a typed data signature from a wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and get its EIP-1193 provider via its **`getEthereumProvider`** method:

    ```tsx
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    const provider = await wallet.getEthereumProvider();
    ```

    Then, using the provider's **`request`** method, send an **`eth_signTypedData_v4`** JSON-RPC to the wallet. In the **`params`** array, include the wallet's address as the first entry, and the typed data as the second entry.

    ```tsx
    const address = wallet.address;
    // https://viem.sh/docs/actions/wallet/signTypedData#signtypeddata
    const typedData = typedDataRequestParams, // Your typed data request params

    const signature = await provider.request({
      method: 'eth_signTypedData_v4',
      params: [address, typedData]
    });
    ```

    If you've integrated Privy with another web3 library, you can also use that library's syntax for requesting a typed data signature from the wallet:

    | Library                                                    | Method                                                                                                      |
    | ---------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
    | [Viem](/wallets/connectors/ethereum/integrations/viem)     | Use the wallet client's [**`signTypedData`** method](https://viem.sh/docs/actions/wallet/signTypedData).    |
    | [Ethers](/wallets/connectors/ethereum/integrations/ethers) | Use the signer's [**`signTypedData`** method](https://docs.ethers.org/v5/api/signer/#Signer-signTypedData). |
    | [Wagmi](/wallets/connectors/ethereum/integrations/wagmi)   | Use the [**`useSignTypedData`** hook](https://wagmi.sh/react/api/hooks/useSignTypedData).                   |

    <Info>
      When requesting a signature from an embedded wallet, you can customize the signature prompt by using Privy's native [signTypedData](/wallets/using-wallets/ethereum/sign-typed-data) method.
    </Info>
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/wallets/connectors/overview



Privy can be integrated with all popular wallet connectors so your application can easily interface with your users wallets. Privy is built to connect with all external wallets, including those on browser and mobile devices, so that users can bring their existing wallets and assets into your app.

You can integrate Wagmi, Viem, Ethers, @solana/web3.js, and web3swift to manage embedded or external wallets on your app. This compatibility allows your application to interface with all of your user’s wallets in your existing web3 stack.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Connectors3.png" alt="Connectors3" />
</Frame>


# Configure external connector chains
Source: https://docs.privy.io/wallets/connectors/setup/configuring-external-connector-chains



Privy supports connecting wallets on both EVM networks and Solana to your application. To configure your app for the wallet types you need, follow the steps below.

## Configuring EVM/Solana external connectors

<Tabs>
  <Tab title="EVM and Solana">
    <Tip>
      If you are connecting to Solana wallets, you must also initialize Solana connectors using Privy's `toSolanaWalletConnectors` method and pass them to the `config.externalWallets.solana.connectors` field.
    </Tip>

    In your `PrivyProvider`, set the `config.appearance.walletChainType` to `'ethereum-and-solana'`.

    ```tsx
    import {PrivyProvider} from '@privy-io/react-auth';
    import {toSolanaWalletConnectors} from "@privy-io/react-auth/solana";

    <PrivyProvider
      config={{
        appearance: {walletChainType: 'ethereum-and-solana'},
        externalWallets: {solana: {connectors: toSolanaWalletConnectors()}}
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="EVM">
    In your `PrivyProvider`, set the `config.appearance.walletChainType` to `'ethereum-only'`.

    ```tsx
    import {PrivyProvider} from '@privy-io/react-auth';

    <PrivyProvider
      config={{
        appearance: {walletChainType: 'ethereum-only'}
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>

  <Tab title="Solana">
    <Tip>
      If you are connecting to Solana wallets, you must also initialize Solana connectors using Privy's `toSolanaWalletConnectors` method and pass them to the `config.externalWallets.solana.connectors` field.
    </Tip>

    In your `PrivyProvider`, set the `config.appearance.walletChainType` to `'solana-only'`.

    ```tsx
    import {PrivyProvider} from '@privy-io/react-auth';
    import {toSolanaWalletConnectors} from "@privy-io/react-auth/solana";

    <PrivyProvider
      config={{
        appearance: {walletChainType: 'solana-only'},
        externalWallets: {
          solana: {connectors: toSolanaWalletConnectors()}
        }
      }}
    >
      {children}
    </PrivyProvider>
    ```
  </Tab>
</Tabs>


# Configure wallet options
Source: https://docs.privy.io/wallets/connectors/setup/configuring-external-connector-wallets



To customize the external wallet options for your app, pass in a **`WalletListEntry`** array to the **`config.appearance.walletList`** property. When users login with, connect, or link an external wallet in your app, the possible options (e.g. MetaMask, Rainbow, WalletConnect) will be presented to users in the order you configure them in this array.

```tsx
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      // Defaults ['detected_wallets', 'metamask', 'coinbase_wallet', 'rainbow', 'wallet_connect']
      walletList: ['metamask', 'rainbow', 'wallet_connect'],
      ...insertTheRestOfYourAppearanceConfig
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

You can also configure which wallet options to show at runtime, by passing in `walletList` to the `connectWallet` method:

```tsx
import {usePrivy} from '@privy-io/react-auth';

const {connectWallet} = usePrivy();

<button onClick={() => connectWallet({walletList: ['rainbow', 'coinbase_wallet']})}>
  Login with email and sms only
</button>;
```

The possible wallets to include in the array are:

* `detected_ethereum_wallets`
* `detected_solana_wallets`
* `metamask`
* `coinbase_wallet`
* `rainbow`
* `phantom`
* `zerion`
* `cryptocom`
* `uniswap`
* `okx_wallet`
* `universal_profile`
* `rabby_wallet`
* `bybit_wallet`
* `ronin_wallet`
* `haha_wallet`
* `safe`
* `solflare`
* `backpack`
* `binance`
* `wallet_connect` (include this to capture the long-tail of wallets that support WalletConnect in your app)

The `detected_*_wallets` option includes all wallets that Privy detects which are not explicitly included elsewhere in the walletList array. As an example, if your user has the Zerion browser extension installed, it will appear under `detected_*_wallets` – unless you include `zerion` elsewhere in the `walletList` array, in which case it will appear in the placement of `zerion`.

<Info>
  Privy detects wallets via [EIP6963 injection](https://eips.ethereum.org/EIPS/eip-6963),
  `window.ethereum` injection, or a mobile wallet's in-app browser.
</Info>

### Configuring the Coinbase Smart Wallet

The Coinbase Smart Wallet is available to all Privy developers. To get set up, you will simply need to add Coinbase Wallet to your login flow and configure your smart wallet preference in the `config.externalWallets.coinbaseWallet.connectionOptions` property.

```tsx
<PrivyProvider
  appId="your-privy-app-id"
  config={{
    appearance: {
      walletList: ['coinbase_wallet'],
      ...insertTheRestOfYourAppearanceConfig
    },
    externalWallets: {
      coinbaseWallet: {
        // Valid connection options include 'all' (default), 'eoaOnly', or 'smartWalletOnly'
        connectionOptions: 'smartWalletOnly'
      }
    },
    ...insertTheRestOfYourPrivyProviderConfig
  }}
>
  {children}
</PrivyProvider>
```

By default, Privy will set `config.externalWallets.coinbaseWallet.connectionOptions` to `all` such that the SDK will detect whether the user has the wallet extension installed. It will popup the Coinbase wallet if they do and the Smart Wallet otherwise.

The following are valid `connectionOptions` property values:

* `eoaOnly`: The Privy SDK will only surface the Coinbase Wallet extension or Coinbase Wallet mobile app QR code. Users who do not have it installed will be prompted to install it.
* `smartWalletOnly`: The Privy SDK will surface the Coinbase Smart Wallet for all users.
* `all`: (default) The Privy SDK will detect whether the user has the Coinbase wallet extension installed. It will popup the Coinbase wallet if they do and the Smart Wallet otherwise.

<Tip>
  Smart Wallet [supports a limited number of
  chains](https://www.smartwallet.dev/FAQ#what-networks-will-be-supported-at-launch). If using `all`
  or `smartWalletOnly` connection options, be sure that your PrivyProvider [default chain and
  supported chains](/basics/react/advanced/configuring-evm-networks#supported-chains) list is a
  subset of Coinbase's supported list.
</Tip>


# null
Source: https://docs.privy.io/wallets/connectors/solana/send-a-transaction



<Tip>
  To sponsor gas fees for transactions on Solana, see our guide
  [here](/wallets/gas-and-asset-management/gas/solana).
</Tip>

<Tabs>
  <Tab title="React">
    <Info>
      When sending a transaction from an embedded wallet, you can customize the signature prompt by using Privy’s native
      [sendTransaction](/wallets/using-wallets/solana/send-a-transaction) method.
    </Info>

    In addition to signing messages, you can sign and send transactions on the Solana blockchain. Privy supports both legacy and v0 (versioned) transactions.

    ```tsx
    sendTransaction(transaction: Transaction): Promise<Transaction>;
    ```

    As an example, you can send a transaction on Solana with connected Solana external and embedded wallets like so:

    ```tsx
    import {PublicKey, Transaction, Connection, SystemProgram} from '@solana/web3.js';
    import {useSolanaWallets} from '@privy-io/react-auth';

    ...

    // The rest of this code must be placed within a React component
    // Get Solana wallet
    const {ready, wallets} = useSolanaWallets();
    const wallet = wallets[0];

    // Build transaction request. You should adapt this logic for the particular
    // type of transaction you need.
    if (!ready || !wallet) return;

    // Configure your connection to point to the correct Solana network
    let connection = new Connection(clusterApiUrl('devnet'));

    // Build out the transaction object for your desired program
    // https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
    let transaction = new Transaction();

    // Send transaction
    console.log(await wallet.sendTransaction!(transaction, connection));
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/connectors/solana/sign-a-message



<Tabs>
  <Tab title="React">
    Use the `signMessage` method exported from the `useSolanaWallets` hook to sign a message with an Solana wallet.

    ```tsx
    signMessage: (message: Uint8Array) => Promise<Uint8Array>;
    ```

    ### Usage

    ```tsx
    import {useSolanaWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useSolanaWallets();

    const message = 'Hello world';
    const {signature} = await wallets[0].signMessage(new TextEncoder().encode(message));
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      Message to be signed.
    </ParamField>

    ### Response

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/connectors/solana/sign-a-transaction



<Tabs>
  <Tab title="React">
    <Info>
      When signing a transaction from an embedded wallet, you can use Privy's native [signTransaction](/wallets/using-wallets/solana/sign-a-transaction) method to customize the signature prompt.
    </Info>

    You can sign transactions on the Solana blockchain without sending them. Privy supports both legacy and v0 (versioned) transactions.

    ```tsx
    signTransaction(transaction: Transaction): Promise<Transaction>;
    ```

    Here's an example of how to sign a transaction on Solana with connected Solana external and embedded wallets:

    ```tsx
    import {PublicKey, Transaction, Connection, SystemProgram} from '@solana/web3.js';
    import {useSolanaWallets} from '@privy-io/react-auth';

    // The rest of this code must be placed within a React component
    // Get Solana wallet
    const {ready, wallets} = useSolanaWallets();
    const wallet = wallets[0];

    // Build transaction request. You should adapt this logic for the particular
    // type of transaction you need.
    if (!ready || !wallet) return;

    // Configure your connection to point to the correct Solana network
    let connection = new Connection(clusterApiUrl('devnet'));

    // Build out the transaction object for your desired program
    // https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
    let transaction = new Transaction();

    // Sign transaction
    const signedTransaction = await wallet.signTransaction!(transaction);
    console.log('Signed transaction:', signedTransaction);
    ```
  </Tab>
</Tabs>


# Interfacing with common libraries
Source: https://docs.privy.io/wallets/connectors/solana/web3-integrations



<Tabs>
  <Tab title="React">
    Privy's **`ConnectedSolanaWallet`** object is fully compatible with popular web3 libraries for interfacing wallets, such as [`@solana/web3js`](https://solana-labs.github.io/solana-web3.js/) and [`solana/kit`](https://github.com/anza-xyz/kit).

    Read below to learn how to best integrate Privy alongside these libraries.

    ## @solana/web3.js

    First find your desired wallet from the **`wallets`** array:

    ```tsx
    import {PublicKey, Transaction, Connection, SystemProgram} from '@solana/web3.js';

    const {wallets} = useSolanaWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    Then, use this wallet to then send Transactions using the @solana/web3.js Transaction and Connection classes:

    ```tsx
    // Configure your connection to point to the correct Solana network
    let connection = new Connection(clusterApiUrl('devnet'));

    // Build out the transaction object for your desired program
    // https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
    let transaction = new Transaction();

    // Send transaction
    console.log(await wallet.sendTransaction!(transaction, connection));
    ```

    {/* TODO: Add solana/kit */}
  </Tab>
</Tabs>


# Authenticate a connected wallet
Source: https://docs.privy.io/wallets/connectors/usage/authenticate



<Tabs>
  <Tab title="React">
    Once a user has connected their wallet to your app, and the wallet is available in the **`useWallets`** or **`useSolanaWallets`** array, you can also prompt them to **login** with that wallet or **link** that wallet to their existing account, instead of prompting the entire **`login`** or **`linkWallet`** flow.

    To do so, find the **`ConnectedWallet`** or **`ConnectedSolanaWallet`** object from Privy, and call the object's **`loginOrLink`** method:

    <Tabs>
      <Tab title="EVM">
        ```tsx
        import {useWallets} from '@privy-io/react-auth';
        ...
        const {wallets} = useWallets();
        ...
        wallets[0].loginOrLink();
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        import {useSolanaWallets} from '@privy-io/react-auth/solana';
        ...
        const {wallets} = useSolanaWallets();
        ...
        wallets[0].loginOrLink();
        ```
      </Tab>
    </Tabs>

    When called, **`loginOrLink`** will directly request a [SIWE](https://docs.login.xyz/general-information/siwe-overview/eip-4361) or [SIWS](https://github.com/phantom/sign-in-with-solana) signature from the user's connected wallet to authenticate the wallet.

    If the user was not **`authenticated`** when the method was called, the user will become **`authenticated`** after signing the message.

    If the user was already **`authenticated`** when the method was called, the user will remain **`authenticated`** after signing the message, and the connected wallet will become one of the user's **`linkedAccounts`** in their **`user`** object.

    You might use the methods above to "split up" the connect and sign steps of external wallet login, like so:

    <Tabs>
      <Tab title="EVM">
        ```tsx
        import {useConnectWallet, useWallets} from '@privy-io/react-auth';

        export default function WalletButton() {
        const {connectWallet} = useConnectWallet();
        const {wallets} = useWallets();

        // Prompt user to connect a wallet with Privy modal
        return (
            {/* Button to connect wallet */}
            <button
                onClick={connectWallet}>
                Connect wallet
            </button>
            {/* Button to login with or link the most recently connected wallet */}
            <button
                disabled={!wallets[0]}
                onClick={() => { wallets[0].loginOrLink() }}>
                Login with wallet
            </button>
        );
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        import {useConnectWallet} from '@privy-io/react-auth';
        import {useSolanaWallets} from '@privy-io/react-auth/solana';

        export default function WalletButton() {
          const {connectWallet} = useConnectWallet();
          const {wallets} = useSolanaWallets();

          // Prompt user to connect a wallet with Privy modal
          return (
            {/* Button to connect wallet */}
            <button
                onClick={connectWallet}>
                Connect wallet
            </button>
            {/* Button to login with or link the most recently connected wallet */}
            <button
                disabled={!wallets[0]}
                onClick={() => { wallets[0].loginOrLink() }}>
                Login with wallet
            </button>
          );
        }
        ```
      </Tab>
    </Tabs>

    ### Sign in with Ledger on Solana

    Currently, Ledger Solana hardware wallets only support transaction signatures, not the message signatures required
    for Sign-In With Solana (SIWS) authentication. In order to authenticate with a Solana Ledger wallet,
    you will need to mount the following hook in your application:

    ```tsx
    import {useSolanaLedgerPlugin} from '@privy-io/react-auth/solana';
    ...
    // Ensure this is mounted throughout the entire sign in flow
    useSolanaLedgerPlugin();
    ```

    Then, when you attempt to login with a Phantom Solana wallet, you will be prompted to indicate whether you are signing with a Ledger wallet,
    which will initiate a separate SIWS flow wherein which a no-op transaction will be signed and used for verification.
  </Tab>
</Tabs>


# Connect or create a wallet
Source: https://docs.privy.io/wallets/connectors/usage/connect-or-create



<Tabs>
  <Tab title="React">
    You can also use Privy to connect a user's external wallet if they have one, or to create an embedded wallet for them if they do not. This ensures users always have a connected wallet they can use with your application, and allows them to choose to use their external wallet if preferred.

    To do so, use the **`connectOrCreateWallet`** method of the **`usePrivy`** hook:

    ```tsx
    const {connectOrCreateWallet} = usePrivy();
    ```

    This method will prompt the user to connect an external wallet, or log in with email, SMS, or socials, depending on your configured `loginMethods`, to create an embedded wallet.

    <Info>
      Privy's `connectOrCreate` interface currently only supports external and embedded wallets on EVM
      networks.
    </Info>

    For example, you might have a "Connect" button in your app that prompts users to connect their wallet, like so:

    ```tsx
    import {useConnectOrCreateWallet} from '@privy-io/react-auth';

    export default function ConnectWalletButton() {
      const {connectOrCreateWallet} = useConnectOrCreateWallet();
      // Prompt user to connect a wallet with Privy modal
      return <button onClick={connectOrCreateWallet}>Connect wallet</button>;
    }
    ```

    <Tip>
      This method functions exactly the same as Privy's `login` method, except when users connect their
      external wallet, they will not automatically be prompted to authenticate that wallet by signing a
      message
    </Tip>

    ### Callbacks

    You can optionally pass callbacks to the `useConnectOrCreateWallet` hook to run custom logic after connecting a wallet or to handle errors.

    #### `onSuccess`

    ```tsx
    onSuccess: (args: {wallet: ConnectedWallet}) => Promise<void>;
    ```

    ##### Parameters

    <ParamField path="wallet" type="ConnectedWallet">
      The most recently connected wallet.
    </ParamField>

    #### `onError`

    ```tsx
    onError: (error: Error) => Promise<void>;
    ```

    ##### Parameters

    <ParamField path="error" type="Error">
      The error that occurred during the this flow.
    </ParamField>
  </Tab>
</Tabs>


# Connect an external wallet
Source: https://docs.privy.io/wallets/connectors/usage/connecting-external-wallets



<Tabs>
  <Tab title="React">
    <Tip>
      To determine if Privy has fully processed all external and embedded EVM wallet connections, use the **`ready`** boolean returned by the **`useWallets`** hook, or the **`ready`** boolean returned by the **`useSolanaWallets`** hook for Solana wallets.
    </Tip>

    To prompt a user to connect an external wallet (on EVM networks or Solana) to your app, use the `connectWallet` method from the `useConnectWallet` hook.

    ```tsx
    connectWallet: async ({ suggestedAddress?: string, walletList?: WalletListEntry[], walletChainType?: 'ethereum' | 'solana' }) => void
    ```

    ### Usage

    <Info>
      To connect external wallets on Solana, your application must first explicitly configure Solana connectors for Privy. [Learn more](/recipes/react/configuring-external-connectors#connecting-external-wallets-on-solana)
    </Info>

    ```tsx
    import {useConnectWallet} from '@privy-io/react-auth';
    const {connectWallet} = useConnectWallet();

    connectWallet();
    ```

    ### Parameters

    <ParamField path="suggestedAddress" type="string">
      An suggested address for the user to connect, which will be displayed in
      Privy's UI.
    </ParamField>

    {/* TODO add walletList link */}

    <ParamField path="walletList" type="WalletListEntry[]">
      {/* TODO add walletList link */}A list of \[wallet option] that you would like
      Privy to display in the connection prompt.

      {/* TODO: Add list of wallets that can be supported here, as an expandable */}
    </ParamField>

    <ParamField path="walletChainType" type="'solana-only' | 'ethereum-only' | 'ethereum-and-solana'">
      Filter the login wallet options to only show wallets that support the specified
      chain type.
    </ParamField>

    ### Callbacks

    You can optionally register an onSuccess or onError callback on the useConnectWallet hook.

    ```tsx
    const {connectWallet} = useConnectWallet({
        onSuccess: ({wallet}) => {
            console.log(wallet);
        },
        onError: (error) => {
            console.log(error);
        },
    });
    ```

    <ParamField path="onSuccess" type="({wallet: Wallet}) => void">
      An optional callback function that is called when a user successfully connects their wallet.
    </ParamField>

    <ParamField path="onError" type="({error: string}) => void">
      An optional callback function that is called when a user exits the connection flow or there is an error.
    </ParamField>
  </Tab>
</Tabs>


# Configuring funding methods
Source: https://docs.privy.io/wallets/funding/configuration



To enable various funding flows for your users, visit the and select your app from the **App Dropdown** in the sidebar. Then, navigate to the [Account Funding](https://dashboard.privy.io/apps?page=funding) page for your selected app.

![Fundingupdate PNG](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/fundingupdate.png)

## Enable funding methods

<Tip>
  Set up Privy UIs in your app with [this guide](/authentication/user-authentication/ui-component),
  as they are required to be integrated in your app for Privy's funding flows.
</Tip>

To enable funding in your app, select which funding methods you would like to allow from **Pay with card** and/or **Transfer from exchange** by selecting the corresponding option in the Dashboard.

Privy will present the options you enable here for your users to select from during a funding flow.

<Info>
  We are actively working on bringing **Transfer from external wallet** to React Native, but this is
  currently **not** yet supported. Enabling this method on your dashboard will not provide this
  option to users.
</Info>

<Info>
  Due to known issues with Coinbase's native on-ramp configuration, Apple Pay may not always be
  surfaced after selecting "Confirm and Purchase" through the Coinbase on-ramp for Pay with Card.
  Please contact Coinbase for further assistance.
</Info>

## Set a default chain and amount

Once you have selected your funding methods, you can select the chain your users will use. When EVM is selected you'll need to select a **default network**. Both for EVM or Solana you'll need an **amount** that users should fund their wallets with. Users can update the amount manually if they choose, before confirming.

During funding flows, Privy will prompt users to fund their wallets with the **native currency of your default chain** (e.g. ETH on Ethereum Mainnet, POL on Polygon, SOL on Solana) with the funding amount you specify here.

<Tip>
  You can also prompt users to fund their wallets with USDC or other ERC20 tokens by setting a
  funding asset [in code](/wallets/funding/prompting-users-to-fund/evm).
</Tip>

You can always change these values in the Dashboard later or even override them in your app's code.


# null
Source: https://docs.privy.io/wallets/funding/overview



**Privy makes it easy for your users to fund their wallets with a variety of assets**, including a network's native currency (e.g. ETH, SOL), USDC, and other tokens.

This makes it seamless to take onchain actions within your apps such as purchasing goods, swapping tokens, minting NFTs, and more.

![images/Funding.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Funding.png)

Privy enables users to fund their wallets by:

* purchasing via [**debit/credit card, Apple Pay, and Google Pay**](#pay-with-card%2C-apple-pay%2C-and-google-pay)
* transferring or bridging assets from an [**external wallet**](#transfer-from-wallet) (e.g. MetaMask, Phantom)
* transferring assets from a cryptocurrency [**exchange**](#transfer-from-exchange), such as Coinbase

Continue below to learn more about the different methods, or go to the guide to learn how to enable various funding methods for your users!

## Pay with card, Apple Pay, and Google Pay

The **pay with card** funding option enables users to purchase assets with a debit card, including with browser payment rails like **Apple Pay** and **Google Pay**. This is particularly useful for users that may not hold crypto outside of your application and are purchasing crypto for the first time.

Privy facilitates card purchases through onramp providers like MoonPay or [Coinbase Onramp](https://www.coinbase.com/developer-platform/products/onramp) embedded within your app. Privy will default to the best provider for your user's payment method, location, and asset; if purchases fail with one provider, users will be given the option to select another.

Please note that these purchases are not immediate, and depending on the payment method selected by your users, it may take a few days for funds to arrive in your user's wallet. Generally, **paying with debit card over credit card has the highest approval rates** for cryptocurrency purchases. Debit cards can be used with Apple and Google Pay.

<Info>
  With MoonPay and Coinbase Onramp, users can purchase a variety of assets across different EVM
  networks and Solana. Please view
  [MoonPay's](https://support.moonpay.com/customers/docs/list-of-supported-cryptocurrencies) and
  [Coinbase's](https://docs.cdp.coinbase.com/onramp/docs/api-configurations#fiat-currencies-and-crypto-assets-supported)
  list of supported assets for more information.
</Info>

## Transfer from wallet

The **transfer from wallets** funding option enables users to transfer or bridge funds from an external wallet (e.g. MetaMask, Phantom) to their embedded wallet within your app.

If a user chooses to fund via external wallet, Privy will prompt the user to connect their external wallet to your app and will query their balance on the [chain](/wallets/funding/configuration) you've configured in the Dashboard.

<Info>
  With external wallets, users can fund their accounts on EVM networks with the network's native
  asset (e.g. ETH, POL), USDC, or ERC20 tokens, and accounts on Solana with SOL.
</Info>

#### Transferring funds on the configured chain

If the external wallet has sufficient funds on the configured chain, Privy will prompt the user to directly **transfer** funds on the configured chain.

If users don't want to connect an external wallet, Privy will also give the users to copy their embedded wallet address or scan it with a QR code, and manually transfer funds from their external wallet to their embedded wallet.

#### Bridging funds to the configured chain

If the external wallet does not have sufficient funds on the configured chain, but has funds on other networks, Privy will prompt the user to instead **bridge** funds to your configured chain. Privy will query balances on the networks listed [here](/basics/react/advanced/configuring-evm-networks#default-configuration) and any additional [`supportedChains`](/basics/react/advanced/configuring-evm-networks#supported-chains) you configure to determine possible source chains for bridging.

If the user only has enough funds on one chain, Privy will automatically prompt the user to bridge from that chain. If the user has enough funds on multiple source chains, Privy will allow the user to select from where to bridge funds.

Users can also bridge funds from Solana to EVM networks and vice versa.

Privy uses [Reservoir Relay](https://relay.link/) to power instant bridging, and supports bridging funds to the networks listed [here](https://docs.relay.link/resources/supported-chains).

## Transfer from exchange

The **transfer from exchange** funding option enables users to purchase or transfer assets from an existing Coinbase exchange account, via [Coinbase Onramp](https://www.coinbase.com/developer-platform/products/onramp) embedded within your app. If users have already completed KYC and identity verification with Coinbase for their Coinbase account, they will not need to do so again, streamlining their asset purchase/transfer experience.

If a user chooses to fund via Coinbase Onramp, Privy will prompt the user to fund with the [amount](./configuration.md#amount) you configure in Dashboard by opening Coinbase in a pop-up window. Once the purchase is complete, this window will automatically close and users can continue in your application.

Please note that these purchases are not immediate and it may take a few minutes for funds to arrive in your user's wallet.

<Info>
  When transferring from an exchange, users can fund their accounts with a network's native currency (e.g. ETH, SOL) or USDC on Coinbase Onramp's [supported networks](https://docs.cdp.coinbase.com/pay-sdk/docs/layer2/).

  Note that not all payment methods are available in all regions due to local regulations. See [this guide](https://docs.cdp.coinbase.com/onramp/docs/payment-methods/) for more information on which payment methods are supported in which regions.
</Info>


# EVM
Source: https://docs.privy.io/wallets/funding/prompting-users-to-fund/evm



# Prompting users to fund wallets

With funding methods enabled for your app, Privy will prompt users to fund their wallets at two points in their experience:

1. Manually, when you call Privy's `fundWallet` method documented below
2. Automatically, when the user attempts to send a transaction but has insufficient funds

You can also configure the chain, asset, and amount that users should fund their wallets with directly in code.

## Manually invoking funding

Once you've enabled a set of funding methods for your app, to invoke the funding flow, use the **`useFundWallet`** hook from the Privy SDK as follows:

<Tabs>
  <Tab title="React">
    Prompt the user to fund their wallets by calling `fundWallet`.

    ```tsx
    import {useFundWallet} from '@privy-io/react-auth';
    ...
    const {fundWallet} = useFundWallet();
    await fundWallet('your-wallet-address-here');
    ```

    If you are using Privy's cross-chain bridging feature to fund an EVM wallet using assets on Solana,
    you will additionally need to mount the **`useSolanaFundingPlugin()`** hook in your app like so:

    ```tsx
    import {useSolanaFundingPlugin} from '@privy-io/react-auth/solana';
    ...
    // Ensure this is mounted throughout the entire funding flow
    useSolanaFundingPlugin();
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take. If only one funding method was enabled for your app, Privy will navigate the user directly to that specific flow.

    You can pass additional configurations to the funding flow in the second, optional parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Automatically invoking funding

    With funding methods enabled for your app, if a user attempts to send a transaction but does not have sufficient funds to do so, Privy will show them an "Add funds" button in the transaction modal that enables them to invoke funding flows.

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, as the second, optional parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                       | Type                                                | Description                                                                                                                                                                                                                                                                                  |
    | ------------------------------- | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `chain`                         | [`Chain`](https://viem.sh/docs/chains/introduction) | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                                                       |
    | `asset`                         | `'native-currency' \| 'USDC' \| {erc20: string}`    | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or a token address in the `erc20` field to fund with an arbitrary ERC20. Defaults to `'native-currency'`.    |
    | `amount`                        | `string`                                            | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                           |
    | `defaultFundingMethod`          | `'card' \| 'exchange' \| 'wallet' \| 'manual'`      | Optional. Specifying the default funding method will send the user directly to the card / exchange provider, directly open the wallet transfer, or directly open the manual QR wallet transfer screen. Additional configured payment options will be shown after the default funding method. |
    | `card.preferredProvider`        | `'coinbase' \| 'moonpay'`                           | Optional. The preferred card provider to use for funding. If not specified, users will be directed to one of these providers initially and given an option to navigate to a different later.                                                                                                 |
    | `uiConfig.receiveFundsTitle`    | `string`                                            | Optional. Configure the title of the "Receive funds" screen.                                                                                                                                                                                                                                 |
    | `uiConfig.receiveFundsSubtitle` | `string`                                            | Optional. Configure the subtitle of the "Receive funds" screen.                                                                                                                                                                                                                              |

    As examples, you can configure the chain, asset, amount, default funding method, and provider to fund like below:

    #### Fund with ETH

    ```tsx
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      chain: base,
      amount: '0.01' // Since no `asset` is set, defaults to 'native-currency' (ETH)
    })
    ```

    #### Fund with USDC

    ```tsx
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      chain: base,
      amount: '15',
      asset: 'USDC'
    })
    ```

    #### Fund with arbitrary ERC20

    ```tsx
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      chain: base,
      amount: '30',
      asset: {erc20: '0x0578d8A44db98B23BF096A382e016e29a5Ce0ffe'}
    })
    ```

    #### Fund with Moonpay

    ```tsx
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      amount: '0.01',
      chain: base,
      card: {
        preferredProvider: 'moonpay',
      },
    });
    ```

    #### Fund with Coinbase exchange immediately

    ```tsx
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      amount: '0.01',
      chain: base,
      card: {
        preferredProvider: 'coinbase',
      },
      defaultFundingMethod: 'exchange'
    });
    ```

    ## Callbacks

    To understand when users have gone through a funding flow, you can use the `onUserExited` callback that can be provided to the **`useFundWallet`** hook. The `address`, `chain`, `fundingMethod`, and `balance` (value of the wallet being funded) are available via the callback, which fires when users exit the funding flow.

    For example, if you want to prompt a user to fund their wallet upon logging in for the first time as a part of your onboarding flow:

    ```tsx
    const {fundWallet} = useFundWallet({
      onUserExited({balance}) {
        if (balance < 1000n) {
          router.push('/insufficient-funds');
        } else {
          router.push('/dashboard');
        }
      }
    });

    const {login} = useLogin({
      onComplete(user, isNewUser) {
        if (isNewUser && user.wallet?.walletClientType === 'privy') {
          fundWallet(user.wallet.address);
        } else {
          router.push('/dashboard');
        }
      }
    });
    ```

    ## Customizing the "Receive funds" screen

    Privy allows you to customize the "Receive funds" screen by providing `uiConfig` options in the `fundWallet` method. You can set the `receiveFundsTitle` and `receiveFundsSubtitle` to customize the title and subtitle of the screen.

    You can then call `fundWallet` like so to customize the UI:

    ```tsx
    import {useFundWallet} from '@privy-io/react-auth';

    // ...
    const {fundWallet} = useFundWallet();
    fundWallet({
      address: 'your-wallet-address-here',
      uiConfig: {
        receiveFundsTitle: 'Receive 0.05 ETH',
        receiveFundsSubtitle: 'Scan this code or copy your wallet address to receive funds on Base.'
      }
    });
    ```

    This will change the default "Receive funds" screen to:

    <Frame className="flex flex-col items-center">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/customized-receive-funds.png" style={{ borderRadius: "0.5rem", width: "50%", margin: "auto" }} alt="Customized Receive funds screen" />
    </Frame>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Make sure `<PrivyElements />` is mounted first, by following [this
      guide](/authentication/user-authentication/ui-component).
    </Tip>

    Prompt the user to fund their wallets by calling `fundWallet`.

    ```tsx
    import { useFundWallet } from "@privy-io/expo/ui";
    ...
    const {fundWallet} = useFundWallet();
    await fundWallet({address: 'your-wallet-address-here'});
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take.

    You can pass additional configurations to the funding flow in the second, optional parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, as the second, optional parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                | Type                                                    | Description                                                                                                                                                                                                                                                   |
    | ------------------------ | ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `address`                | `string`                                                | The destination address to fund.                                                                                                                                                                                                                              |
    | `chain`                  | [`Chain`](https://viem.sh/docs/chains/introduction)     | Optional. A [`viem/chains`](https://viem.sh/docs/chains/introduction) object for the network on which users should fund their accounts. Defaults to the network you configured in the Privy Dashboard.                                                        |
    | `asset`                  | `'native-currency' \| 'USDC' \| {tokenAddress: string}` | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to fund with the `chain`'s native currency (e.g. ETH), `'USDC'` to fund with USDC, or pass the token address to `tokenAddress`. Defaults to `'native-currency'`. |
    | `amount`                 | `string`                                                | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                            |
    | `defaultPaymentMethod`   | `'card' \| 'exchange'`                                  | Optional. If provided, skip the payment method selection screen and immediately trigger the funding flow with the provider.                                                                                                                                   |
    | `card.preferredProvider` | `'coinbase' \| 'moonpay'`                               | Optional. Configure the 3rd-party provider for card based funding flows.                                                                                                                                                                                      |

    ```tsx
    import {useFundWallet} from '@privy-io/expo/ui';
    // Replace this with your desired network
    import {base} from 'viem/chains';
    // ...
    const {fundWallet} = useFundWallet();
    fundWallet({
      address: '0x2F3eb40872143b77D54a6f6e7Cc120464C764c09',
      asset: 'USDC',
      chain: base,
      amount: '1',
      defaultPaymentMethod: 'card',
      card: {
        preferredProvider: 'coinbase'
      }
    });
    ```

    <Tip>
      To skip directly to the provider's on-ramp experience you can use the `defaultPaymentMethod`
      option.
    </Tip>
  </Tab>
</Tabs>


# Solana
Source: https://docs.privy.io/wallets/funding/prompting-users-to-fund/solana



# Prompting users to fund wallets

With funding methods enabled for your app, Privy will prompt users to fund their wallets at two points in their experience:

1. Manually, when you call Privy's `fundWallet` method documented below
2. Automatically, when the user attempts to send a transaction but has insufficient funds

You can also configure the chain, asset, and amount that users should fund their wallets with directly in code.

## Manually invoking funding

Once you've enabled a set of funding methods for your app, to invoke the funding flow, use the **`useFundWallet`** hook from the Privy SDK as follows:

<Tabs>
  <Tab title="React">
    Prompt the user to fund their wallets by calling `fundWallet`.

    ```tsx
    import {useFundWallet} from '@privy-io/react-auth/solana';
    ...
    const {fundWallet} = useFundWallet();
    await fundWallet('your-wallet-address-here');
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take. If only one funding method was enabled for your app, Privy will navigate the user directly to that specific flow.

    You can pass additional configurations to the funding flow in the second, optional parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Automatically invoking funding

    With funding methods enabled for your app, if a user attempts to send a transaction but does not have sufficient funds to do so, Privy will show them an "Add funds" button in the transaction modal that enables them to invoke funding flows.

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, as the second, optional parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                       | Type                                           | Description                                                                                                                                                                                                                                                                                  |
    | ------------------------------- | ---------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `cluster`                       | `{name: Cluster}`                              | Optional. An object for the [Cluster](https://solana-labs.github.io/solana-web3.js/types/Cluster.html) on which users should fund their accounts. Defaults to `mainnet-beta`.                                                                                                                |
    | `amount`                        | `string`                                       | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                                                                                                                           |
    | `defaultFundingMethod`          | `'card' \| 'exchange' \| 'wallet' \| 'manual'` | Optional. Specifying the default funding method will send the user directly to the card / exchange provider, directly open the wallet transfer, or directly open the manual QR wallet transfer screen. Additional configured payment options will be shown after the default funding method. |
    | `card.preferredProvider`        | `'coinbase' \| 'moonpay'`                      | Optional. The preferred card provider to use for funding. If not specified, users will be directed to one of these providers initially and given an option to navigate to a different later.                                                                                                 |
    | `uiConfig.receiveFundsTitle`    | `string`                                       | Optional. Configure the title of the "Receive funds" screen.                                                                                                                                                                                                                                 |
    | `uiConfig.receiveFundsSubtitle` | `string`                                       | Optional. Configure the subtitle of the "Receive funds" screen.                                                                                                                                                                                                                              |

    As examples, you can configure the cluster, amount, and provider to fund like below:

    #### Fund with SOL

    ```tsx
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      cluster: {name: 'devnet'},
      amount: '0.01' // SOL
    });
    ```

    #### Fund with Moonpay

    ```tsx
    fundWallet('your-wallet-address-here', {
      amount: '0.01', // SOL
      card: {
        preferredProvider: 'moonpay'
      }
    });
    ```

    #### Fund with Coinbase exchange immediately

    ```tsx
    // Replace this with your desired network
    import {base} from 'viem/chains'
    ...
    // `fundWallet` from the useFundWallet() hook
    fundWallet('your-wallet-address-here', {
      amount: '0.01',
      chain: base,
      card: {
        preferredProvider: 'coinbase',
      },
      defaultFundingMethod: 'exchange'
    });
    ```

    ## Callbacks

    To understand when users have gone through a funding flow, you can use the `onUserExited` callback that can be provided to the **`useFundWallet`** hook. The `address`, `chain`, `fundingMethod`, and `balance` (value of the wallet being funded) are available via the callback, which fires when users exit the funding flow.

    For example, if you want to prompt a user to fund their wallet upon logging in for the first time as a part of your onboarding flow:

    ```tsx
    const {fundWallet} = useFundWallet({
      onUserExited({balance}) {
        if (balance < 1000n) {
          router.push('/insufficient-funds');
        } else {
          router.push('/dashboard');
        }
      }
    });

    const {login} = useLogin({
      onComplete(user, isNewUser) {
        if (isNewUser && user.wallet?.walletClientType === 'privy') {
          fundWallet(user.wallet.address);
        } else {
          router.push('/dashboard');
        }
      }
    });
    ```

    ## Customizing the "Receive funds" screen

    Privy allows to customize the "Receive funds" screen by providing `uiConfig` options in the `fundWallet` method. You can set the `receiveFundsTitle` and `receiveFundsSubtitle` to customize the title and subtitle of the screen.

    You can then call `fundWallet` like so to customize the UI:

    ```tsx
    import {useFundWallet} from '@privy-io/react-auth';

    // ...
    const {fundWallet} = useFundWallet();
    fundWallet({
      address: 'your-wallet-address-here',
      uiConfig: {
        receiveFundsTitle: 'Receive 0.05 ETH',
        receiveFundsSubtitle: 'Scan this code or copy your wallet address to receive funds on Base.'
      }
    });
    ```

    This will change the default "Receive funds" screen to:

    <Frame className="flex flex-col items-center">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/customized-receive-funds.png" style={{borderRadius: '0.5rem', width: '50%', margin: 'auto'}} alt="Customized Receive funds screen" />
    </Frame>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Make sure `<PrivyElements />` is mounted first, by following [this
      guide](/authentication/user-authentication/ui-component).
    </Tip>

    Prompt the user to fund their wallets by calling `fundSolanaWallet`.

    ```tsx
    import { useFundSolanaWallet } from "@privy-io/expo/ui";
    ...
    const {fundWallet} = useFundSolanaWallet();
    await fundWallet({address: 'your-wallet-address-here'});
    ```

    Once invoked, the **`fundWallet`** method will open a modal that contains a list of funding options the user can take.

    You can pass additional configurations to the funding flow in the second, optional parameter to **`fundWallet`**.

    <Warning>
      Purchases with third-party providers are not always instantaneous, and there may be some time
      before the user completes their purchase and the funds are available in their wallet.
    </Warning>

    ## Setting a funding amount in code

    Optionally, you can pass in a **chain, funding amount, and funding asset** to `fundWallet` to override your Dashboard configuration.

    To do so, as the second, optional parameter to `fundWallet`, pass an object with the following fields:

    | Parameter                | Type                          | Description                                                                                                                                                                                    |
    | ------------------------ | ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `address`                | `string`                      | The destination address to fund.                                                                                                                                                               |
    | `cluster`                | `SolanaCluster`               | Optional. An object for the cluster on which users should fund their accounts. Defaults to `mainnet-beta`.                                                                                     |
    | `asset`                  | `'native-currency' \| 'USDC'` | Optional. The asset you'd like the user to fund their accounts with. Set `'native-currency'` to use the app's configured asset or `'USDC'` to fund with USDC. Defaults to `'native-currency'`. |
    | `amount`                 | `string`                      | Required if `asset` is set, optional otherwise. The amount of the asset to fund as a decimal string. Defaults to the amount you configured in the Privy Dashboard.                             |
    | `defaultPaymentMethod`   | `'card' \| 'exchange'`        | Optional. If provided, skip the payment method selection screen and immediately trigger the funding flow with the provider.                                                                    |
    | `card.preferredProvider` | `'coinbase' \| 'moonpay'`     | Optional. Configure the 3rd-party provider for card based funding flows.                                                                                                                       |

    As an example, you can configure the cluster and amount to fund like so:

    ```tsx
    import {useFundSolanaWallet} from '@privy-io/expo/ui';
    // ...
    const {fundWallet} = useFundSolanaWallet();
    fundWallet({
      address: 'address'
      amount: '0.01', // SOL
      defaultPaymentMethod: 'card',
      card: {
        preferredProvider: 'coinbase',
      }
    });
    ```

    <Tip>
      To skip directly to the provider's on-ramp experience you can use the `defaultPaymentMethod`
      option.
    </Tip>
  </Tab>
</Tabs>


# Fetch balance via webhook
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/balance-event-webhooks



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/from-my-server). More on [Privy architecture
  here](https://docs.privy.io/security/wallet-infrastructure/secure-execution-environments/secure-enclave)
</Warning>

**Privy emits webhooks whenever a server wallet sends or receives a registered asset.** This helps your application stay in sync with the assets in your server wallets, and easily track deposits and withdrawals.

To set up deposit and/or withdrawal webhooks, follow the guide below.

<Info>
  Webhooks is currently a pro feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

<Warning>Deposit webhooks are available for EVM chains only. Solana support is coming soon</Warning>

## Setup a webhooks URL

To start, go to the [**Webhooks**](https://dashboard.privy.io/apps?page=webhooks) page for your app in the [Privy Dashboard](https://dashboard.privy.io) and provide a destination URL for receiving webhooks.

Then, enable the `'wallet.funds_deposited'` and/or `'wallet.funds_withdrawn'` events. You can next configure which assets Privy should emit `'wallet.funds_deposited'` and/or `'wallet.funds_withdrawn'` events for.

Privy will emit a signed webhook to this URL whenever your server wallets sends/receives a transaction for a registered asset, and will retry delivery if the endpoint does not successfully respond to the original webhook.
Privy's webhook system operates on a `at least once` delivery basis, and redundant requests can be identified via the `idempotency_key` field.

## Configure assets to track

Once you've enabled the `'wallet.funds_deposited'` and/or `'wallet.funds_withdrawn'` events, you can then configure which assets you'd like to track via the Privy Dashboard.

Privy supports webhooks for **native tokens** (e.g. ETH, SOL) on EVM and Solana, **ERC20 tokens** on EVM, and **SPL tokens** on Solana.

#### Native tokens

To configure webhooks for native token transactions, simply select the **Native token** asset type and provide the CAIP-2 chain ID for the network on which to track the native token.

#### ERC20 tokens

To configure webhooks for ERC20 token transfers, simply select the **ERC20 token** asset type and provide:

* the contract address for the ERC20 token
* the CAIP-2 chain ID for the network on which to track the ERC20 token

#### SPL tokens

To configure webhooks for SPL token transfers, simply select the **SPL token** asset type and provide:

* the mint address for the SPL token
* the CAIP-2 chain ID for the network on which to track the SPL token

## Payload

When a server wallet receives a transaction for a registered asset, Privy will emit a webhooks payload with the following fields:

<Expandable title="child attributes" defaultOpen="true">
  <ResponseField name="type" type="'wallet.funds_deposited' | 'wallet.funds_withdrawn'">
    Event name for the webhook.
  </ResponseField>

  <ResponseField name="wallet_id" type="string">
    ID of the wallet that received the deposit.
  </ResponseField>

  <ResponseField name="asset" type="Object">
    Asset for the transaction.

    <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
      <ResponseField name="type" type="'native-token' | 'erc20' | 'spl'">
        Type of the asset for the transaction.
      </ResponseField>

      <ResponseField name="address" type="string">
        Contract address for an ERC20 asset, or mint address for an SPL asset. This field will only be included for the 'erc20' and 'spl' asset.types.
      </ResponseField>
    </Expandable>
  </ResponseField>

  <ResponseField name="amount" type="string">
    Absolute amount of the transaction. Denominated based on the asset (e.g. wei for EVM, or lamports
    for SOL). Stringified to maintain precision from BigInt.
  </ResponseField>

  <ResponseField name="transaction_hash" type="string">
    Hash for the transaction.
  </ResponseField>

  <ResponseField name="sender" type="string">
    Sender of the transaction.
  </ResponseField>

  <ResponseField name="recipient" type="string">
    Recipient of the transaction.
  </ResponseField>

  <ResponseField name="caip2" type="string">
    CAIP-2 chain ID of the network where the transaction happened.
  </ResponseField>

  <ResponseField name="block" type="Object">
    Information about the block for the transaction.

    <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
      <ResponseField name="number" type="number">
        Number of the block for the transaction.
      </ResponseField>
    </Expandable>
  </ResponseField>

  <ResponseField name="idempotency_key" type="string">
    An idempotent ID that uniquely identifies the deposit or withdrawal. In cases where the webhooks
    trigger more than once, the idempotency\_key will match.
  </ResponseField>
</Expandable>

### Example

Below is a sample webhooks payload that Privy might send on a deposit of .05 ETH on Base into a server wallet.

```json
{
  "type": "wallet.deposit_received",
  "wallet_id": "cm4db8x9t000ccn87pctvcg9j",
  "asset": {
    "type": "native-token",
    "address": null
  },
  "amount": "500000000000000",
  "transaction_hash": "0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c",
  "sender": "0x59D3eB21Dd06A211C89d1caBE252676e2F3F2218",
  "recipient": "0x59D3eB21Dd06A211C89d1caBE252676e2F3F2218",
  "caip2": "eip155:8453",
  "block": {
    "number": 22000002
  },
  "idempotency_key": "enriched_transaction_v2_0x9fb07e26c4e1913ce3c06602db2c1e216fd6134b40a03def699ea04ca67c7088_20"
}
```


# Fetch transaction via API
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/fetch-a-transaction



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/from-my-server). More on [Privy architecture
  here](https://docs.privy.io/security/wallet-infrastructure/secure-execution-environments/secure-enclave)
</Warning>

<Tabs>
  <Tab title="NodeJS">
    To get a transaction's details using the NodeJS SDK, use the `getTransaction` method from the Privy client:

    ```typescript
    getTransaction: (input: {id: string}) => Promise<WalletApiTransactionResponseType>;
    ```

    ### Usage

    ```typescript
    const transaction = await privy.walletApi.getTransaction({
      id: 'insert-transaction-id'
    });
    console.log(transaction);
    ```

    ### Parameters

    <ParamField path="id" type="string" required>
      ID of the transaction to fetch details for.
    </ParamField>

    ### Returns

    <ResponseField name="transaction" type="WalletApiTransactionResponseType">
      <Expandable title="WalletApiTransactionResponseType" defaultOpen="true">
        <ResponseField name="id" type="string">
          ID for the transaction.
        </ResponseField>

        <ResponseField name="walletId" type="string">
          ID for the wallet that sent the transaction.
        </ResponseField>

        <ResponseField name="caip2" type="string">
          CAIP-2 chain ID for the network the transaction was broadcasted on.
        </ResponseField>

        <ResponseField name="transactionHash" type="string">
          Hash for the transaction.
        </ResponseField>

        <ResponseField name="status" type="'broadcasted' | 'confirmed' | 'execution_reverted'">
          Current status of the transaction.

          * `'broadcasted'` refers to when a transaction has been submitted to the network but has not yet been included in a block
          * `'confirmed'` refers to when a transaction has been included in a block that has been confirmed on the network.
          * `'execution_reverted'` refers to when a transaction has reverted in execution.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    Privy supports fetching transaction status by the transaction ID.

    To do so, make a `GET` request to

    ```bash
    https://api.privy.io/v1/transactions/<transaction_id>
    ```

    replacing `<transaction_id>` with the ID of your desired transaction.

    ## Response

    <ResponseField name="id" type="string">
      ID for the transaction.
    </ResponseField>

    <ResponseField name="wallet_id" type="string">
      ID for the wallet that sent the transaction.
    </ResponseField>

    <ResponseField name="status" type="'broadcasted' | 'confirmed' | 'execution_reverted'">
      Current status of the transaction. - `'broadcasted'` refers to when a transaction has been
      submitted to the network but has not yet been included in a block - `'confirmed'` refers to when a
      transaction has been included in a block that has been confirmed on the network. -
      `'execution_reverted'` refers to when a transaction has reverted in execution.
    </ResponseField>

    <ResponseField name="transaction_hash" type="string">
      Hash for the transaction.
    </ResponseField>

    <ResponseField name="caip2" type="string">
      CAIP-2 chain ID for the network the transaction was broadcasted on.
    </ResponseField>

    ## Example

    For example, you might fetch a transactions status using transaction ID using the `cURL` request below.

    ```bash
    $ curl --request GET https://api.privy.io/v1/transactions/<transaction_id> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    ```

    The response might look like

    ```json
    {
      "id": "<transaction_id>",
      "wallet_id": "fmfdj6yqly31huorjqzq38zc",
      "status": "confirmed",
      "transaction_hash": "0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c",
      "caip2": "eip155:8453"
    }
    ```
  </Tab>
</Tabs>


# Fetch transaction via webhook
Source: https://docs.privy.io/wallets/gas-and-asset-management/assets/transaction-event-webhooks



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/from-my-server). More on [Privy architecture
  here](https://docs.privy.io/security/wallet-infrastructure/secure-execution-environments/secure-enclave)
</Warning>

**Privy emits webhooks whenever the status of a transaction sent by a server wallet changes.** This helps your application track the status of the transaction after it has been broadcasted to the network, and be notified when the transaction is confirmed or reverts.

<Info>
  Webhooks is currently a pro feature. To use webhooks, please upgrade your account in the Privy
  Dashboard.
</Info>

To set up transaction webhooks, follow the guide below.

## Events

Privy allows you to subscribe to webhooks on the following transaction events: `'broadcasted'`, `'confirmed'`, `'execution_reverted'`:

* `'broadcasted'` refers to when a transaction has been submitted to the network but has not yet been included in a block
* `'confirmed'` refers to when a transaction has been included in at least one block that has been confirmed on the network. You can additionally configure Privy to wait for more than one block confirmation before updating a transaction's status to `'confirmed'`.
* `'execution_reverted'` refers to when a transaction has reverted in execution.

## Setup

To start, go to the **Webhooks** page for your app in the [Privy Dashboard](https://dashboard.privy.io) and provide a destination URL for receiving webhooks.

Then, enable the `'transaction.broadcasted'`, `'transaction.confirmed'`, and/or `'transaction.execution_reverted'` events depending on the transaction events you'd like to be notified of.

Privy will emit a signed webhook to this URL whenever transaction status updates, and will retry delivery if the endpoint does not successfully respond to the original webhook.

## Payload

When the status of a transaction updates, Privy will emit a webhooks payload with the following fields:

<ResponseField name="type" type="'transaction.{broadcasted, confirmed, execution_reverted}'">
  Event for the transaction.
</ResponseField>

<ResponseField name="transaction_id" type="string">
  ID for the transaction.
</ResponseField>

<ResponseField name="wallet_id" type="string">
  ID of the server wallet that sent the transaction.
</ResponseField>

<ResponseField name="transaction_hash" type="string">
  Hash for the transaction.
</ResponseField>

<ResponseField name="caip2" type="string">
  CAIP-2 chain ID of the network that the transaction was broadcasted on.
</ResponseField>

### Example

Below is a sample webhooks payload that Privy will send on a `'transaction.confirmed'` event.

```json
{
  "event": "transaction.confirmed",
  "transaction_id": "fmfdj6yqly31huorjqzq38zc",
  "wallet_id": "cm4db8x9t000ccn87pctvcg9j",
  "transaction_hash": "0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c",
  "chain_id": "eip155:8453"
}
```


# Sponsoring transactions on Ethereum
Source: https://docs.privy.io/wallets/gas-and-asset-management/gas/ethereum



Privy makes it easy to create **smart wallets** for your users to sponsor gas fees for transactions on Ethereum. This is done by using a [paymaster](https://docs.alchemy.com/docs/paymaster-overview) to pay for users' gas fees.

<Tabs>
  <Tab title="NodeJS">
    This guide explains how to use smart wallets from your server to sponsor gas fees for transactions on Ethereum. Using server wallets as smart wallets gives your application all the benefits of account abstraction, including gas sponsorship, with the flexibility of server wallets.

    In this setup, an embedded wallet created on your server wallet is the signer for the smart wallet. Note that the server wallet's address is not the smart wallet address in this case - it simply authorizes actions taken by the smart wallet. All transactions and assets are tied to the smart wallet.

    <Note>
      This guide uses Kernel as the smart wallet contract provider, but your implementation can use any
      smart wallet provider.
    </Note>

    ### 0: Install necessary dependencies

    This guide uses Privy's server SDK to create the server wallet, Pimlico's `permissionless` package, and `viem`. Install these packages with the following command:

    ```sh
    npm i @privy-io/server-auth permissionless viem
    ```

    ### 1: Create a server wallet

    Create a `privy` client and use the `create` method from [Privy's SDK](/wallets/wallets/create/from-my-server) to create a server wallet. If you already have a server wallet you wish to use, you can skip this step.

    ```ts
    import {PrivyClient} from '@privy-io/server-auth';

    // Initialize your Privy client
    const privy = new PrivyClient('your privy app id', 'your privy app secret');

    // Create a server wallet
    const {id: walletId, address, chainType} = await privy.walletApi.create({chainType: 'ethereum'});
    ```

    ### 2: Get a `viem` `LocalAccount` for the server wallet

    Create a viem `LocalAccount` object representing the server wallet. Use the `createViemAccount` method from [Privy's SDK](/wallets/using-wallets/ethereum/web3-integrations#node-js).

    ```tsx
    import {createViemAccount} from '@privy-io/server-auth/viem';

    // Create a viem account instance for a wallet
    const serverWalletAccount = await createViemAccount({
      walletId,
      address,
      privy
    });
    ```

    ### 3: Create a smart wallet

    Use [`permissionless`](https://docs.pimlico.io/permissionless/) to create a smart wallet with the server wallet as the signer. Learn more about creating smart wallet accounts in the `permissionless` [docs](https://docs.pimlico.io/permissionless/how-to/accounts/use-kernel-account).

    ```tsx
    import {toKernelSmartAccount} from 'permissionless/accounts';
    import {entryPoint07Address} from 'viem/account-abstraction';

    const kernelSmartAccount = await toKernelSmartAccount({
      client: publicClient,
      entryPoint: {
        address: entryPoint07Address,
        version: '0.7'
      },
      owner: serverWalletAccount
    });
    ```

    ### 4: Create a client for the smart wallet

    You can use this smart wallet client to request signatures and transactions from the smart wallet. Learn more about making transactions on the client in the `permissonless` [docs](https://docs.pimlico.io/permissionless/how-to/accounts/use-kernel-account).

    ```tsx
    import {createSmartAccountClient, walletClientToCustomSigner} from 'permissionless';
    import {createPublicClient, http} from 'viem';

    const bundlerUrl = 'your bundler URL';
    const paymasterUrl = 'your paymaster URL';

    // Create a viem public client for RPC calls
    const publicClient = createPublicClient({
      chain: sepolia, // Replace this with the chain of your choice
      transport: http() // Optionally include an RPC override
    });

    // Create the paymaster client to sponsor gas fees on transactions
    const paymasterClient = createPimlicoClient({
      transport: http(paymasterUrl),
      entryPoint: kernelSmartAccount.entryPoint
    });

    // Create the SmartAccountClient for requesting signatures and transactions (RPCs)
    const smartAccountClient = createSmartAccountClient({
      account: kernelSmartAccount,
      chain: sepolia,
      paymaster: paymasterClient,
      bundlerTransport: http(bundlerUrl),
      userOperation: {
        estimateFeesPerGas: async () => (await paymasterClient.getUserOperationGasPrice()).fast
      }
    });
    ```
  </Tab>

  <Tab title="React">
    ### Gas sponsorship with paymasters

    With smart wallets, your app can pay for gas fees simply by registering a paymaster URL in the Privy Dashboard.

    Follow this guide to [setup smart wallets](/wallets/using-wallets/evm-smart-wallets/overview).

    Privy will automatically route gas payments from your registered paymaster instead of your users' wallets, allowing your users to transact on-chain *instantly* –– even if they don't have a balance in their smart wallet.
  </Tab>

  <Tab title="React Native">
    ### Gas sponsorship with paymasters

    With smart wallets, your app can pay for gas fees simply by registering a paymaster URL in the Privy Dashboard.

    Follow this guide to [setup smart wallets](/wallets/using-wallets/evm-smart-wallets/overview).

    Privy will automatically route gas payments from your registered paymaster instead of your users' wallets, allowing your users to transact on-chain *instantly* –– even if they don't have a balance in their smart wallet.
  </Tab>
</Tabs>


# Sponsoring transactions on Solana
Source: https://docs.privy.io/wallets/gas-and-asset-management/gas/solana



With embedded wallets, your app can sponsor gas fees for transactions on Solana, allowing users to transact without a SOL balance.
This is done by configuring the `feePayer` property of the sponsored transaction to be a fee payer wallet that your app manages to pay users' gas fees.

## Overview

Sponsoring transactions on Solana involves the following steps:

<Steps>
  <Step title="Set up a fee payer wallet">
    Create a fee payer wallet in your backend to pay for users' gas fees.
  </Step>

  <Step title="Prepare and sign the transaction">
    Prepare a transaction with a custom fee payer, sign it with the user's wallet, and send it to your
    backend.
  </Step>

  <Step title="Verify and complete the transaction">
    Verify the transaction, sign it with the fee payer wallet, and broadcast it
    to the network.
  </Step>
</Steps>

<Note>
  To prepare transactions with a fee payer, we recommend using the
  [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/) library.
</Note>

## Setting up a fee payer wallet

To start, create a fee payer wallet in your backend to sponsor transactions sent by users. You can either:

1. Generate a new keypair directly:

```javascript
import {Keypair} from '@solana/web3.js';
import bs58 from 'bs58';

// Generate a new keypair
const feePayerWallet = new Keypair();
const feePayerAddress = feePayerWallet.publicKey.toBase58();
const feePayerPrivateKey = bs58.encode(feePayerWallet.secretKey);

// Make sure to store the private key securely; it should never leave your server
console.log('Fee Payer Address:', feePayerAddress);
console.log('Fee Payer Private Key:', feePayerPrivateKey);
```

2. Or [create a Solana server wallet](/wallets/wallets/create/from-my-server) to act as your fee payer for better security and key management.

Ensure you fund this wallet with SOL to pay for transaction fees.

## Implementing Sponsored Transactions

<Tabs>
  <Tab title="React">
    With the React SDK, follow these steps to prepare and send a sponsored transaction:

    ```javascript
    import {useSolanaWallets} from '@privy-io/react-auth/solana';
    import {
      TransactionMessage,
      PublicKey,
      VersionedTransaction,
      Connection
    } from '@solana/web3.js';

    // This function prepares and signs a sponsored transaction
    async function prepareSponsoredTransaction(instructions, feePayerAddress) {
      // Find the user's embedded wallet
      const { wallets } = useSolanaWallets();
      const embeddedWallet = wallets.find(wallet => wallet.walletClientType === 'privy');

      if (!embeddedWallet) {
        throw new Error('No embedded wallet found');
      }

      // Create a connection to Solana
      const connection = new Connection('https://api.mainnet-beta.solana.com');
      const { blockhash } = await connection.getLatestBlockhash();

      // Create the transaction message with fee payer set to the backend wallet
      const message = new TransactionMessage({
        payerKey: new PublicKey(feePayerAddress),
        recentBlockhash: blockhash,
        instructions
      }).compileToV0Message();

      // Create transaction
      const transaction = new VersionedTransaction(message);

      // Serialize message for signing
      const serializedMessage = Buffer.from(transaction.message.serialize()).toString('base64');

      // Get provider and sign
      const provider = await embeddedWallet.getProvider();
      const { signature: serializedUserSignature } = await provider.request({
        method: 'signMessage',
        params: {
          message: serializedMessage
        }
      });

      // Add user signature to transaction
      const userSignature = Buffer.from(serializedUserSignature, 'base64');
      transaction.addSignature(new PublicKey(embeddedWallet.address), userSignature);

      // Serialize the transaction to send to backend
      const serializedTransaction = Buffer.from(transaction.serialize()).toString('base64');

      // Send to your backend
      const response = await fetch('your-backend-endpoint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ transaction: serializedTransaction })
      });

      const { transactionHash } = await response.json();
      return transactionHash;
    }
    ```
  </Tab>

  <Tab title="React Native">
    With the React Native SDK, follow these steps to prepare and send a sponsored transaction:

    ```javascript
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';
    import {
      TransactionMessage,
      PublicKey,
      VersionedTransaction,
      Connection
    } from '@solana/web3.js';

    // This function prepares and signs a sponsored transaction
    async function prepareSponsoredTransaction(instructions, feePayerAddress) {
      // Get the embedded wallet
      const wallet = useEmbeddedSolanaWallet();
      const embeddedWallet = wallet.wallets[0];

      if (!embeddedWallet) {
        throw new Error('No embedded wallet found');
      }

      // Create a connection to Solana
      const connection = new Connection('https://api.mainnet-beta.solana.com');
      const { blockhash } = await connection.getLatestBlockhash();

      // Create the transaction message with fee payer set to the backend wallet
      const message = new TransactionMessage({
        payerKey: new PublicKey(feePayerAddress),
        recentBlockhash: blockhash,
        instructions
      }).compileToV0Message();

      // Create transaction
      const transaction = new VersionedTransaction(message);

      // Serialize message for signing
      const serializedMessage = Buffer.from(transaction.message.serialize()).toString('base64');

      // Get provider and sign
      const provider = await embeddedWallet.getProvider();
      const { signature: serializedUserSignature } = await provider.request({
        method: 'signMessage',
        params: {
          message: serializedMessage
        }
      });

      // Add user signature to transaction
      const userSignature = Buffer.from(serializedUserSignature, 'base64');
      transaction.addSignature(new PublicKey(embeddedWallet.address), userSignature);

      // Serialize the transaction to send to backend
      const serializedTransaction = Buffer.from(transaction.serialize()).toString('base64');

      // Send to your backend
      const response = await fetch('your-backend-endpoint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ transaction: serializedTransaction })
      });

      const { transactionHash } = await response.json();
      return transactionHash;
    }
    ```
  </Tab>

  <Tab title="Swift">
    With the Swift SDK, follow these steps to prepare and send a sponsored transaction:

    ```swift
    import Foundation
    import SolanaSwift
    import PrivySDK

    // This function prepares and signs a sponsored transaction
    func prepareSponsoredTransaction(
        wallet: EmbeddedSolanaWallet,
        instructions: [TransactionInstruction],
        feePayerAddress: String,
        rpcUrl: String
    ) async throws -> String {
        // Create a Solana RPC client
        let solana = JSONRPCAPIClient(endpoint: URL(string: rpcUrl)!)

        // Get the latest blockhash
        let latestBlockhash = try await solana.getLatestBlockhash()

        // Create public keys
        let walletPK = try PublicKey(string: wallet.address)
        let feePayerPK = try PublicKey(string: feePayerAddress)

        // Create transaction
        var tx = Transaction()

        // Add instructions
        for instruction in instructions {
            tx.instructions.append(instruction)
        }

        // Set the fee payer and blockhash
        tx.recentBlockhash = latestBlockhash
        tx.feePayer = feePayerPK

        // Serialize the transaction message to base64
        let message = try tx.compileMessage().serialize().base64EncodedString()

        // Get the provider for wallet
        let provider = wallet.provider

        // Sign using the embedded wallet
        let userSignature = try await provider.signMessage(message: message)

        // Add the signature to the transaction
        try tx.addSignature(signature: Data(base64Encoded: userSignature)!, publicKey: walletPK)

        // Serialize the transaction for transmission to backend
        let serializedTransaction = tx.serialize().base64EncodedString()

        // Send to backend
        let url = URL(string: "your-backend-endpoint")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")

        let requestBody: [String: Any] = ["transaction": serializedTransaction]
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NSError(domain: "HTTP Error", code: (response as? HTTPURLResponse)?.statusCode ?? 0)
        }

        let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any]
        guard let transactionHash = jsonResponse?["transactionHash"] as? String else {
            throw NSError(domain: "Response Error", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid response"])
        }

        return transactionHash
    }
    ```
  </Tab>

  <Tab title="Android">
    With the Android SDK, follow these steps to prepare and send a sponsored transaction:

    ```kotlin
    import android.util.Base64
    import kotlinx.coroutines.Dispatchers
    import kotlinx.coroutines.withContext
    import org.json.JSONObject
    import java.net.HttpURLConnection
    import java.net.URL

    // This function prepares and signs a sponsored transaction
    suspend fun prepareSponsoredTransaction(
        solanaWallet: EmbeddedSolanaWallet,
        instructions: List<Instruction>,
        feePayerAddress: String,
        rpcUrl: String
    ): Result<String> {
        return try {
            // Create connection to Solana
            val connection = Connection(rpcUrl)

            // Get recent blockhash
            val recentBlockhash = connection.getLatestBlockhash()

            // Create wallet public key
            val walletPublicKey = PublicKey(solanaWallet.address)
            val feePayerPublicKey = PublicKey(feePayerAddress)

            // Build transaction
            val transaction = Transaction()

            // Add instructions to transaction
            instructions.forEach { instruction ->
                transaction.add(instruction)
            }

            // Set blockhash and fee payer
            transaction.recentBlockhash = recentBlockhash
            transaction.feePayer = feePayerPublicKey

            // Serialize transaction message to base64
            val serializedMessage = transaction.serializeMessage().base64()

            // Sign the message with user's wallet
            val signatureResult = solanaWallet.provider.signMessage(serializedMessage)

            when (signatureResult) {
                is Result.Success -> {
                    // Get the signature
                    val userSignature = signatureResult.data

                    // Add signature to transaction
                    transaction.addSignature(
                        walletPublicKey,
                        Base64.decode(userSignature, Base64.DEFAULT)
                    )

                    // Serialize transaction for sending to backend
                    val serializedTransaction = Base64.encodeToString(
                        transaction.serialize(),
                        Base64.NO_WRAP
                    )

                    // Send to backend
                    val url = URL("your-backend-endpoint")
                    val connection = url.openConnection() as HttpURLConnection
                    connection.requestMethod = "POST"
                    connection.setRequestProperty("Content-Type", "application/json")
                    connection.doOutput = true

                    // Create request body
                    val requestBody = JSONObject().apply {
                        put("transaction", serializedTransaction)
                    }.toString()

                    // Send request
                    connection.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    // Read response
                    val responseCode = connection.responseCode
                    if (responseCode in 200..299) {
                        val response = connection.inputStream.bufferedReader().use { it.readText() }
                        val jsonResponse = JSONObject(response)
                        val transactionHash = jsonResponse.getString("transactionHash")
                        Result.Success(transactionHash)
                    } else {
                        val error = connection.errorStream?.bufferedReader()?.use { it.readText() } ?: "Unknown error"
                        Result.Failure(Exception("HTTP Error: $responseCode - $error"))
                    }
                }
                is Result.Failure -> {
                    Result.Failure(signatureResult.error)
                }
            }
        } catch (e: Exception) {
            Result.Failure(e)
        }
    }
    ```
  </Tab>

  <Tab title="Flutter">
    With the Flutter SDK, follow these steps to prepare and send a sponsored transaction:

    ```dart
    import 'dart:convert';
    import 'package:http/http.dart' as http;
    import 'package:solana/solana.dart';

    // This function prepares and signs a sponsored transaction
    Future<Result<String>> prepareSponsoredTransaction({
      required EmbeddedSolanaWallet solanaWallet,
      required List<Instruction> instructions,
      required String feePayerAddress,
      required String rpcUrl,
      required String backendUrl,
    }) async {
      try {
        // Create connection to Solana
        final connection = Connection(rpcUrl);

        // Get recent blockhash
        final recentBlockhash = await connection.getLatestBlockhash();

        // Create wallet public key
        final walletPublicKey = PublicKey(solanaWallet.address);
        final feePayerPublicKey = PublicKey(feePayerAddress);

        // Build transaction
        final transaction = Transaction();

        // Add instructions to transaction
        for (final instruction in instructions) {
          transaction.add(instruction);
        }

        // Set blockhash and fee payer
        transaction.recentBlockhash = recentBlockhash;
        transaction.feePayer = feePayerPublicKey;

        // Serialize transaction message to base64
        final serializedMessage = base64Encode(transaction.serializeMessage());

        // Sign the message with user's wallet
        final signatureResult = await solanaWallet.provider.signMessage(serializedMessage);

        return signatureResult.when(
          success: (userSignature) async {
            // Add signature to transaction
            transaction.addSignature(
              walletPublicKey,
              base64Decode(userSignature)
            );

            // Serialize transaction for sending to backend
            final serializedTransaction = base64Encode(transaction.serialize());

            // Send to backend
            final response = await http.post(
              Uri.parse(backendUrl),
              headers: {'Content-Type': 'application/json'},
              body: jsonEncode({'transaction': serializedTransaction}),
            );

            if (response.statusCode >= 200 && response.statusCode < 300) {
              final jsonResponse = jsonDecode(response.body);
              final transactionHash = jsonResponse['transactionHash'] as String;
              return Success(transactionHash);
            } else {
              return Failure(
                Exception('HTTP Error: ${response.statusCode} - ${response.body}')
              );
            }
          },
          failure: (error) {
            return Failure(Exception('Failed to sign transaction: $error'));
          },
        );
      } catch (e) {
        return Failure(Exception('Error preparing transaction: $e'));
      }
    }
    ```
  </Tab>
</Tabs>

## Backend Implementation

Here's how to implement the server-side portion that receives the partially signed transaction, adds the fee payer signature, and broadcasts it:

```javascript
// Backend implementation (Node.js with Express)
import express from 'express';
import {Keypair, VersionedTransaction, Connection, clusterApiUrl, PublicKey} from '@solana/web3.js';
import bs58 from 'bs58';

const app = express();
app.use(express.json());

// Your fee payer wallet's private key (Keep this secure!)
const FEE_PAYER_PRIVATE_KEY = 'your-base58-encoded-private-key';
const FEE_PAYER_ADDRESS = 'your-fee-payer-address';

// Initialize fee payer keypair
const feePayerWallet = Keypair.fromSecretKey(bs58.decode(FEE_PAYER_PRIVATE_KEY));

// Connect to Solana
const connection = new Connection(clusterApiUrl('mainnet-beta'));

// Endpoint to handle sponsored transactions
app.post('/sponsor-transaction', async (req, res) => {
  try {
    // Get the partially signed transaction from the request
    const {transaction: serializedTransaction} = req.body;

    if (!serializedTransaction) {
      return res.status(400).json({error: 'Missing transaction data'});
    }

    // Deserialize the transaction
    const transactionBuffer = Buffer.from(serializedTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(transactionBuffer);

    // Verify the transaction
    // 1. Check that it's using the correct fee payer
    const message = transaction.message;
    const accountKeys = message.getAccountKeys();
    const feePayerIndex = 0; // Fee payer is always the first account
    const feePayer = accountKeys.get(feePayerIndex);

    if (!feePayer || feePayer.toBase58() !== FEE_PAYER_ADDRESS) {
      return res.status(403).json({
        error: 'Invalid fee payer in transaction'
      });
    }

    // 2. Check for any unauthorized fund transfers
    for (const instruction of message.compiledInstructions) {
      const programId = accountKeys.get(instruction.programIndex);

      // Check if instruction is for System Program (transfers)
      if (programId && programId.toBase58() === '11111111111111111111111111111111') {
        // Check if it's a transfer (command 2)
        if (instruction.data[0] === 2) {
          const senderIndex = instruction.accountKeyIndexes[0];
          const senderAddress = accountKeys.get(senderIndex);

          // Don't allow transactions that transfer tokens from fee payer
          if (senderAddress && senderAddress.toBase58() === FEE_PAYER_ADDRESS) {
            return res.status(403).json({
              error: 'Transaction attempts to transfer funds from fee payer'
            });
          }
        }
      }
    }

    // 3. Sign with fee payer
    transaction.sign([feePayerWallet]);

    // 4. Send transaction
    const signature = await connection.sendTransaction(transaction);

    // Return the transaction hash
    return res.status(200).json({
      transactionHash: signature,
      message: 'Transaction sent successfully'
    });
  } catch (error) {
    console.error('Error processing transaction:', error);
    return res.status(500).json({
      error: 'Failed to process transaction',
      details: error.message
    });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## Security Considerations

When implementing transaction sponsorship, be mindful of these security considerations:

<CardGroup cols={2}>
  <Card title="Verify Transaction Contents" icon="shield-check">
    Always verify the transaction contents in your backend before signing with the fee payer. Ensure
    there are no unauthorized fund transfers.
  </Card>

  <Card title="Rate Limiting" icon="gauge-high">
    Implement rate limiting to prevent abuse of your sponsorship service. Consider limits per user,
    per session, or per wallet.
  </Card>

  <Card title="Amount Validation" icon="money-bill">
    Validate the transaction amount if applicable. Consider setting maximum sponsorship amounts to
    prevent excessive spending.
  </Card>

  <Card title="Program ID Whitelisting" icon="list-check">
    Only sponsor transactions for specific whitelisted program IDs that your app interacts with to
    prevent abuse.
  </Card>
</CardGroup>

<Note>
  Be extremely careful with your fee payer wallet's private key. Never expose it in client-side code
  or store it in unsecured environments. Consider using environment variables, secret management
  services, or HSMs to securely store private keys in production.
</Note>


# null
Source: https://docs.privy.io/wallets/gas-and-asset-management/overview



Privy provides a comprehensive set of tools to handle gas fees and asset management, making interactions seamless for your users.

### Gas Sponsorship

One of the biggest friction points for new users is the need to own cryptocurrency to pay for gas fees. Privy solves this with gas sponsorship options:

* **Ethereum Transactions**: Create smart wallets for your users and sponsor gas fees using paymasters, allowing users to transact even without a balance.
* **Solana Transactions**: Configure a fee payer wallet to cover transaction costs, making the blockchain experience frictionless.

### Transaction Management

Monitor and track transactions across your application:

* **Transaction Status API**: Fetch transaction details and status via API to keep your application in sync.
* **Transaction Webhooks**: Receive notifications when transaction statuses change (broadcasted, confirmed, reverted).
* **Balance Webhooks**: Get notified when server wallets send or receive registered assets.

## Get started

<CardGroup>
  <Card title="Sponsor transactions on solana" icon="bolt" href="/wallets/gas-and-asset-management/gas/solana">
    Sponsor gas fees for Solana transactions to create frictionless experiences for users.
  </Card>
</CardGroup>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/getting-global-wallets



Once a user has successfully linked their account from a provider app, an account of `type: 'cross_app'` will be added to the `linkedAccounts` array of their `user` object.

{/* TODO: make this a reused code snippet */}

This `crossAppAccount` is an object with the following properties:

<ParamField path="type" type="'cross_app'" required>
  Indicates that the linked account is a cross-app account.
</ParamField>

<ParamField path="embeddedWallets" type="Array<{address: string}>">
  An array of the user's embedded wallet(s) from the provider app for the cross-app account.
</ParamField>

<ParamField path="providerApp" type="ProviderAppMetadata">
  Metadata about the provider app for the cross-app account.

  <Expandable defaultOpen="true">
    <ParamField path="id" type="string" required>
      Privy app ID of the source app.
    </ParamField>

    <ParamField path="name" type="string">
      Name of the source app.
    </ParamField>

    <ParamField path="logoUrl" type="string">
      Logo of the source app.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="firstVerifiedAt" type="Date">
  Datetime when the cross-app account was first linked to the user.
</ParamField>

<ParamField path="latestVerifiedAt" type="Date">
  Datetime for when the user last logged in/linked the cross-app account.
</ParamField>

To find a user's cross-app embedded wallet, first find the account of `type: 'cross_app'` from their `linkedAccounts` array. If your app permits users to link cross-app accounts from *multiple* provider apps, you should also filter the `linkedAccounts` by the `providerApp.id` on the cross-app account.

```tsx
// Replace `providerAppId` with the Privy app ID of your desired provider app
const providerAppId = 'insert-provider-app-id';
const crossAppAccount = user.linkedAccounts.find(
  (account) => account.type === 'cross_app' && account.providerApp.id === providerAppId
);
```

Next, from the `crossAppAccount`, inspect the `embeddedWallets` array to get the user's embedded wallet address(es) from the source app.

```tsx
const address = crossAppAccount.embeddedWallets[0].address;
```

<Info>
  Most users only have one embedded wallet per app. Certain apps, however, leverage multiple
  embedded wallets (e.g. HD wallets) per user to support certain use cases. In kind, the
  `embeddedWallets` field is designed as an array, but generally will be a singleton containing one
  entry.
</Info>

<Tip>
  Cross-app operations on Smart Wallets work exactly the same! Just use the right wallet address and all hooks will work as usual.

  ```tsx
  const smartWalletAddress = crossAppAccount.smart_wallets[0].address;
  ```
</Tip>

{/* <!-- [TODO: how to handle HD indices for apps (they will want to pick which to make avail)] --> */}


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/linking-a-global-wallet



<Tabs>
  <Tab title="React">
    To prompt users to link their embedded wallet from a provider app, use the `linkCrossAppAccount` method from the `useCrossAppAccounts` hook:

    ```tsx
    import {usePrivy} from '@privy-io/react-auth';

    function Button() {
      const {ready, authenticated} = usePrivy();
      const {linkCrossAppAccount} = useCrossAppAccounts();

      return (
        <button
          onClick={() => linkCrossAppAccount({appId: 'insert-provider-app-id'})}
          disabled={!ready || !authenticated}
        >
          Link your [insert-provider-app-name] account
        </button>
      );
    }
    ```

    ## Parameters

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    ## Behavior

    When `linkCrossAppAccount` is invoked, the user will be redirected to a page hosted on the domain of the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linkedAccounts` array of their `user` object.

    `linkCrossAppAccount` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user is not `authenticated` and thus cannot link an account from the provider app to an existing account within your requester's app.

    <tip>
      If the user is already logged in on the domain of the source `appId` you specify in
      `linkCrossAppAccount`, they will not have to login again and will only have to consent to sharing
      access to that account in your app.
    </tip>
  </Tab>

  <Tab title="React Native">
    To prompt users to link their embedded wallet from a provider app, use the `linkWithCrossApp` method from the `useLinkWithCrossApp` hook:

    ```tsx
    import {usePrivy, useLinkWithCrossApp} from '@privy-io/expo';

    function LinkWithCrossAppButton() {
      const {isReady, user} = usePrivy();
      const {linkWithCrossApp} = useLinkWithCrossApp();

      return (
        <Button
          onPess={() => linkWithCrossApp({appId: 'insert-provider-app-id'})}
          disabled={!ready || !!user}
        >
          Link your [insert-provider-app-name] account
        </Button>
      );
    }
    ```

    ## Parameters

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    ## Behavior

    When `linkWithCrossApp` is invoked, the user will be redirected to a page hosted on the domain of the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linked_accounts` array of their `user` object.

    `linkWithCrossApp` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user is not `authenticated` and thus cannot link an account from the provider app to an existing account within your requester's app.

     
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/login-with-a-global-wallet



<Tabs>
  <Tab title="React">
    To prompt users to log into your app with an account from a provider app, use the `loginWithCrossAppAccount` method from the `useCrossAppAccounts` hook:

    ```tsx {5,9}
    import {usePrivy} from '@privy-io/react-auth';

    function Button() {
      const {ready, authenticated} = usePrivy();
      const {loginWithCrossAppAccount} = useCrossAppAccounts();

      return (
        <button
          onClick={() => loginWithCrossAppAccount({appId: 'insert-provider-app-id'})}
          disabled={!ready || !authenticated}
        >
          Log in with [insert-provider-app-name]
        </button>
      );
    }
    ```

    ### Parameters

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    ### Behavior

    When `loginWithCrossAppAccount` is invoked, the user will be redirected to a page hosted on the domain of the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linkedAccounts` array of their `user` object.

    `loginWithCrossAppAccount` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user does not already have an account with the provider app.

    <Tip>
      If the user is already logged in on the domain of the source `appId` you specify in
      `loginWithCrossAppAccount`, they will not have to login again and will only have to consent to
      sharing access to that account in your app.
    </Tip>

    ## Using the Privy login modal

    You can add any provider app to the list of login options in the Privy login modal by adding `"privy:"` + the provider's app ID to `loginMethodsAndOrder` in the Privy SDK configuration.

    ```tsx
      <PrivyProvider
        appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ""}
        config={{
          loginMethodsAndOrder: {
            primary: ['email', 'google', 'privy:insert-provider-app-id'],
          },
          ...
        }}
      >
    ```
  </Tab>

  <Tab title="React Native">
    To prompt users to log into your app with an account from a provider app, use the `loginWithCrossApp` method from the `useLoginWithCrossApp` hook:

    ```tsx
    import {usePrivy, useLoginWithCrossApp} from '@privy-io/expo';

    function LoginWithCrossAppButton() {
      const {ready, user} = usePrivy();
      const {loginWithCrossApp} = useLoginWithCrossApp();

      return (
        <Button
          onPress={() => loginWithCrossApp({appId: 'insert-provider-app-id'})}
          disabled={!ready || !!user}
        >
          Log in with [insert-provider-app-name]
        </Button>
      );
    }
    ```

    <ParamField path="appId" type="string" required>
      The Privy app ID of the provider app from which you'd like a user to link their account. You can
      find a list of Privy app IDs for provider apps in the **Cross-app ecosystem** page of the Privy
      Dashboard.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    When `loginWithCrossApp` is invoked, an in-app browser will open for a page hosted on the domain of
    the provider app you specified to authorize access to your own app.

    If the user successfully authorizes access, the user will be redirected back to your app, and an account of `type: 'cross_app'` will be added to the `linked_accounts` array of their `user` object.

    `loginWithCrossApp` will throw an error if:

    * The user does not authorize access to your app or exits the flow prematurely.
    * The provider app you request has not opted-in to share their wallets.
    * The user does not already have an account with the provider app.

    <Tip>
      If the user is already logged in on the domain of the target `appId` you specify in `loginWithCrossApp`, they will not have to login again and will only have to consent to sharing access to that account in your app.
    </Tip>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/overview



Privy allows you to easily integrate embedded wallets from other apps, to verify ownership of users' wallet addresses or even request signatures and transactions from.

This reduces friction around having users transact onchain in your app, as users can easily pull in their assets and identity from other apps where they may already have embedded wallets.

Within this setup, your app is known as the **requester** app.

## Finding available providers

To integrate embedded wallets from another app, first visit the [**Privy Dashboard**](https://dashboard.privy.io) and navigate to User management > Global Wallet > [**Integrations**](https://dashboard.privy.io/apps?tab=integrations\&page=ecosystem) tab to see a list of provider app IDs that consent to sharing their wallets with other apps.

For any providers you'd like to integrate, note down the provider's Privy app ID, as you will use this value in the interfaces outlined below.

<Tip>
  Some providers may only consent to sharing their users' wallets in read-only mode, in which case
  your app can verify that the user owns a particular address, but cannot request signatures or
  transactions from it.
</Tip>


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/rainbowkit-connector



Privy makes it easy to integrate cross-app wallets from various Privy apps into existing setups with RainbowKit, ConnectKit, wagmi and more using the [`@privy-io/cross-app-connect`](https://www.npmjs.com/package/@privy-io/cross-app-connect) SDK.

Integrating apps do not need to use Privy themselves to integrate cross-app wallets; instead, they can import a Privy cross-app connector directly from the SDK to configure with their wallet connector library. Simply follow the instructions below to get set up!

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/connect-only.png" alt="The Rainbowkit connector" />
</Frame>

<Tip>
  See our [`privy-io/cross-app-connect-demo`](https://github.com/privy-io/cross-app-connect-demo)
  repo for an example set up.
</Tip>

## 1. Install dependencies

Install the [`@privy-io/cross-app-connect`](https://www.npmjs.com/package/@privy-io/cross-app-connect) SDK and its peer dependencies:

```bash
npm i @privy-io/cross-app-connect wagmi @rainbow-me/rainbowkit @tanstack/react-query
```

## 2. Create the connector

Import the `toPrivyWallet` connector function from `@privy-io/cross-app-connect/rainbow-kit`:

```tsx
import {toPrivyWallet} from '@privy-io/cross-app-connect/rainbow-kit';
```

Use the `toPrivyWallet` method to create a wallet connector. The function takes `id`, `name`, and `iconUrl` (described below) and returns a connector that RainbowKit will use to connect to the provider wallet.

### Parameters

<ParamField path="id" type="string" required>
  Privy app ID for the provider application.
</ParamField>

<ParamField path="name" type="string" required>
  The name of the Privy provider application.
</ParamField>

<ParamField path="iconUrl" type="string">
  The URL for the icon that will appear in the modal.
</ParamField>

Call this method within RainbowKit's `connectorsForWallets` function like so:

```tsx
import {connectorsForWallets} from '@rainbow-me/rainbowkit';

import {toPrivyWallet} from '@privy-io/cross-app-connect/rainbow-kit';

const connectors = connectorsForWallets(
  [
    {
      groupName: 'Recommended',
      wallets: [
        toPrivyWallet({
          id: 'privy-wallet-app-id',
          name: 'Privy wallet app name',
          iconUrl: 'https://example.com/image.png'
        })
      ]
    }
  ],
  {
    appName: 'Privy',
    projectId: 'Demo'
  }
);
```

{/* <!-- TODO: add list of common provider id, name, and iconUrl---> */}

Then, pass this array of connectors to your wagmi configuration.

```tsx
import {createConfig, http} from 'wagmi';
import {mainnet} from 'wagmi/chains';

export const config = createConfig({
  chains: [mainnet],
  transports: {
    [mainnet.id]: http()
  },
  connectors,
  ssr: true
});
```

This `config` will be passed to the `WagmiProvider` in the next step.

## 3. Wrap app with providers

At the highest level of your applications, wrap the component with the `wagmi`, `QueryClient`, and `RainbowKit` providers. Pass the configuration you created in step 2 to the `wagmi` provider.

```tsx
import {RainbowKitProvider} from '@rainbow-me/rainbowkit';
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
import type {AppProps} from 'next/app';
import {WagmiProvider} from 'wagmi';

import {config} from '../wagmi';

const client = new QueryClient();

function MyApp({Component, pageProps}: AppProps) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={client}>
        <RainbowKitProvider>
          <Component {...pageProps} />
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}

export default MyApp;
```

### Complete example

All together, this should look like:

<Tabs>
  <Tab title="config.ts">
    ```tsx
    import {connectorsForWallets} from '@rainbow-me/rainbowkit';
    import {createConfig, http} from 'wagmi';
    import {mainnet} from 'wagmi/chains';

    import {toPrivyWallet} from '@privy-io/cross-app-connect/rainbow-kit';

    const connectors = connectorsForWallets(
      [
        {
          groupName: 'Recommended',
          wallets: [
            toPrivyWallet({
              id: 'privy-wallet-app-id',
              name: 'Privy wallet app name',
              iconUrl: 'https://example.com/image.png'
            })
          ]
        }
      ],
      {
        appName: 'Privy',
        projectId: 'Demo'
      }
    );

    export const config = createConfig({
      chains: [mainnet],
      transports: {
        [mainnet.id]: http()
      },
      connectors,
      ssr: true
    });
    ```
  </Tab>

  <Tab title="providers.tsx">
    ```tsx
    import {RainbowKitProvider} from '@rainbow-me/rainbowkit';
    import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
    import type {AppProps} from 'next/app';
    import {WagmiProvider} from 'wagmi';

    import {config} from '../wagmi';

    const client = new QueryClient();

    function MyApp({Component, pageProps}: AppProps) {
      return (
        <WagmiProvider config={config}>
          <QueryClientProvider client={client}>
            <RainbowKitProvider>
              <Component {...pageProps} />
            </RainbowKitProvider>
          </QueryClientProvider>
        </WagmiProvider>
      );
    }
    ```
  </Tab>
</Tabs>

## 4. Use the `ConnectButton`

Import the `ConnectButton` and use to prompt users to connect to their provider Privy wallet.

```tsx
import {ConnectButton} from '@rainbow-me/rainbowkit';

function Page() {
  return (
    <div>
      <h1> My app </h1>
      ...
      <ConnectButton />
    </div>
  );
}
```

Thats it! You can now use any wagmi hook in your application to interact with the connected wallet. When users connect and transact with their wallet, Privy will open a pop-up for users to authorize any actions.


# null
Source: https://docs.privy.io/wallets/global-wallets/integrate-a-global-wallet/using-global-wallets



<Tabs>
  <Tab title="React">
    <Info>
      When you request a signature or transaction from a user's embedded wallet from another app, Privy **requires** the user to explicitly confirm the signature or transaction. This is accomplished by opening a popup to the provider app's domain, where the user confirms the action in an isolated environment.
    </Info>

    To request signatures and transactions from a user's embedded wallet from a provider app, use the `signMessage`, `signTypedData`, and `sendTransaction` methods returned by Privy's `useCrossAppAccounts` hook

    ```tsx
    import {useCrossAppAccounts} from '@privy-io/react-auth';

    const {signMessage, signTypedData, sendTransaction} = useCrossAppAccounts();
    ```

    These methods are similar to the [`signMessage`](/wallets/using-wallets/ethereum/sign-a-message), [`signTypedData`](/wallets/using-wallets/ethereum/sign-typed-data), and [`sendTransaction`](/wallets/using-wallets/ethereum/send-a-transaction) methods returned by `usePrivy` except they all require an additional `CrossAppWalletOptions` object of the following type:

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    If the `address` you specify in this `CrossAppWalletOptions` object is not a valid embedded wallet
    that has been linked to the current user from a provider app, these wallet methods will error.

    ## signMessage

    To the `signMessage` method returned by `useCrossAppAccounts`, pass the following parameters:

    <ParamField path="message" type="string" required>
      The message the user must sign as a `string`.
    </ParamField>

    <ParamField path="options" type="CrossAppWalletOptions" required>
      Options for the cross-app embedded wallet, which must include the requested wallet's address.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string" required>
          The address for the cross-app embedded wallet that you'd like to request a
          signature/transaction from.
        </ParamField>
      </Expandable>
    </ParamField>

    ## signTypedData

    To the `signTypedData` method returned by `useCrossAppAccounts`, pass the following parameters:

    <ParamField path="typedData" type="SignedTypedDataParams" required>
      A JSON object that conforms to the EIP-712 [`TypedData JSON
        schema.`](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc)
    </ParamField>

    <ParamField path="options" type="CrossAppWalletOptions" required>
      Options for the cross-app embedded wallet, which must include the requested wallet's address.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string" required>
          The address for the cross-app embedded wallet that you'd like to request a
          signature/transaction from.
        </ParamField>
      </Expandable>
    </ParamField>

    ## sendTransaction

    To the `sendTransaction` method returned by `useCrossAppAccounts`, pass the following parameters:

    <ParamField path="requestData" type="UnsignedTransactionRequest" required>
      The transaction request to be sent.
    </ParamField>

    <ParamField path="options" type="CrossAppWalletOptions" required>
      Options for the cross-app embedded wallet, which must include the requested wallet's address.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string" required>
          The address for the cross-app embedded wallet that you'd like to request a
          signature/transaction from.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Example signature request

    As an example, you might request a signature from a user's cross-app wallet like so:

    ```tsx
    import {usePrivy, useCrossAppAccounts} from '@privy-io/react-auth';

    function Button() {
      const {user} = usePrivy();
      const {signMessage} = useCrossAppAccounts();
      const crossAppAccount = user.linkedAccounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embeddedWallets[0].address;

      return (
        <button onClick={() => signMessage('Hello world', {address: address})} disabled={!address}>
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Info>
      When you request a signature or transaction from a user's embedded wallet from another app, Privy
      **requires** the user to explicitly confirm the signature or transaction. This is accomplished by
      opening a popup to the provider app's domain, where the user confirms the action in an isolated
      environment.
    </Info>

    To request signatures and transactions from a user's embedded wallet from a provider app, use the `signMessage`, `signTypedData`, and `sendTransaction` methods returned by Privy's hooks: `useSignMessageWithCrossApp`, `useSignTypedDataWithCrossApp` and `useSendTransactionWithCrossApp`.

    ```tsx
    const {signMessage} = useSignMessageWithCrossApp();
    const {signTypedData} = useSignTypedDataWithCrossApp();
    const {sendTransaction} = useSendTransactionWithCrossApp();
    ```

    These methods all require an additional `address` property, and an optional `redirectUri`, of the following types:

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    If the `address` you specify in this `CrossAppWalletOptions` object is not a valid embedded wallet
    that has been linked to the current user from a provider app, these wallet methods will error.

    ### signMessage

    To the `signMessage` method returned by \`useSignMessageWithCrossApp\`\`, pass the following parameters:

    ```tsx
    import {usePrivy, useSignMessageWithCrossApp} from '@privy-io/expo';

    function Button() {
      const {user} = usePrivy();
      const {signMessage} = useSignMessageWithCrossApp();
      const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embedded_wallets[0].address;

      return (
        <button onClick={() => signMessage('Hello world', {address})} disabled={!address}>
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```

    <ParamField path="message" type="string" required>
      The message the user must sign as a `string`.
    </ParamField>

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    ### signTypedData

    To the `signTypedData` method returned by `useSignTypedDataWithCrossApp`, pass the following parameters:

    ```tsx
    import {usePrivy, useSignMessageWithCrossApp} from '@privy-io/expo';

    function Button() {
      const {user} = usePrivy();
      const {signTypedData} = useSignTypedDataWithCrossApp();
      const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embedded_wallets[0].address;

      return (
        <button onClick={() => signTypedData({Hello: 'World'}, {address})} disabled={!address}>
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```

    <ParamField path="typedData" type="TypedDataDefinition" required>
      A JSON object that conforms to the EIP-712 [`TypedData JSON
        schema.`](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc)
    </ParamField>

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>

    ### sendTransaction

    To the `sendTransaction` method returned by `useSendTransactionWithCrossApp`, pass the following parameters:

    ```tsx
    import {usePrivy, useSendTransactionWithCrossApp} from '@privy-io/expo';

    function Button() {
      const {user} = usePrivy();
      const {sendTransaction} = useSendTransactionWithCrossApp();
      const crossAppAccount = user.linked_accounts.find((account) => account.type === 'cross_app');
      const address = crossAppAccount.embedded_wallets[0].address;

      return (
        <button
          onClick={() =>
            sendTransaction(
              {
                to: '0xRecipientAddress',
                value: 1000000000000000000,
                gas: 21000,
                gasPrice: 20000000000,
                nonce: 0,
                data: '0x'
              },
              {address}
            )
          }
          disabled={!address}
        >
          Sign a message with your cross-app wallet
        </button>
      );
    }
    ```

    {/* TODO add UnsignedTxRequest Type */}

    <ParamField path="requestData" type="UnsignedTransactionRequest" required>
      The transaction request to be sent.
    </ParamField>

    <ParamField path="address" type="string" required>
      The address for the cross-app embedded wallet that you'd like to request a signature/transaction
      from.
    </ParamField>

    <ParamField path="redirectUri" type="string">
      A URL path that the provider will automatically redirect to after successful authentication. This
      defaults to a link back to your app root, eg. `'/'`, if not provided.
    </ParamField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/global-wallets/launch-your-wallet



**Providers** are apps that enable their users' embedded wallets to be used in other apps. Becoming a provider enables your users to use their embedded wallets and assets from your app elsewhere, allowing them to transact from an existing balance, aggregate assets, and more.

<Tip>
  Before sharing your uses' wallets as a provider app, you must enable a **base domain** for your app.

  **Enabling a base domain helps secure your users' wallets in a cross-app context.** Read more about [security for cross-app wallets](/wallets/global-wallets/overview) and follow [this guide](/recipes/react/cookies) to set up a base domain!
</Tip>

## Configuring your app as a provider

To become a provider and share your users' embedded wallets with other apps, simply visit the **Privy Dashboard** and navigate to the **User management > [Global Wallet](https://dashboard.privy.io/apps?page=ecosystem)** section.

Under the [**My app**](https://dashboard.privy.io/apps?tab=app\&page=ecosystem) tab of this page, enable the **Make my wallet available for other apps to integrate** toggle. You should also upload a square logo image with aspect ratio 1:1 to be shared with other apps. We recommend a JPEG or PNG with size 180px by 180px for best results.

Once enabled, your app will show up as an available wallet provider that other apps can integrate via the [**Integrations**](https://dashboard.privy.io/apps?tab=integrations\&page=ecosystem) tab of this page.

You can also see apps that have actively integrated your wallets under the [**My ecosystem**](https://dashboard.privy.io/apps?tab=ecosystem\&page=ecosystem) tab.

## Transaction scanning

As an additional security feature, Privy is integrated with [Blockaid](https://www.blockaid.io/) transaction scanning to ensure that all transactions from your users' global wallets are safe and secure.

Transaction scanning has two levels of security; **validation** and **simulation**. With transaction validation, users will be notified if the transaction has been flagged by Blockaid as suspicious or malicious. Blockaid will also simulate the transaction with the wallet, showing the token and USD value or exposure difference if the transaction is approved.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/transaction-scan.png" alt="Transaction scanning UI" />

To enable transaction scanning for your global wallet users, navigate to the [Global wallet > My app](https://dashboard.privy.io/apps?page=ecosystem) page of the Privy Dashboard and toggle the **Blockaid transaction simulation** setting on.

Privy has a default API key your app can use for testing but to prevent rate limiting your app should **configure its own Blockaid API key** in the dashboard.

## Read-only mode

When sharing your users' embedded wallets with other apps, your users are protected from any malicious developer. Usage of embedded wallets across apps are strictly domain-segregated and every user action requires explicit consent in a third-party app.

If you would like to limit the scope of your users' wallets to only be read-only in other apps, click the **Read-only mode** checkbox within the [**My app**](https://dashboard.privy.io/apps?tab=app\&page=ecosystem) tab. With this setting enabled, requester apps may see your user's wallet addresses, but not request signatures or transactions from them.

This may be particularly useful for setups where users verifying ownership of assets from your app in other apps, but not necessarily transacting with them.


# null
Source: https://docs.privy.io/wallets/global-wallets/overview



Privy embedded wallets can be made interoperable across apps, making it easy for you to launch your own **global wallet**. In this setup, global wallets foster a cross-app ecosystem where users can easily port their wallets from one app to another, including by integrating wallet connector solutions like RainbowKit and wagmi.

Using **global wallets**, users can seamlessly move assets between different apps and can easily prove ownership of, sign messages, or send transactions with their existing wallets.

![images/Crossapp.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Crossapp.png)

## Providers and requesters

Suppose that Alice is logged in to **App A** and wants to connect with her **App B** wallet to prove she owns an asset. In this setup:

* App A is the **requester app**: it *requests* access to a third-party wallet.
* App B is the **provider app**: it *provides* access to embedded wallets generated on its app.

The **provider** and **requester** nomenclature will be used throughout this documentation and the SDK interfaces.

## User consent and security

<Info>Privy requires that users explicitly confirm all wallet actions in a cross-app context.</Info>

**Global wallets are built to safeguard user privacy and security.** No app developer can view user assets or learn about their address without both:

* The provider app opting into cross-app flows.
* The user explicitly consenting to share their wallet information with the requester app.

By enabling cross-app functionality, the provider's Privy app (hosted on an isolated subdomain) acts as an OAuth-compliant authentication provider. This means requesting apps can initiate the connection, and if the user approves:

* Users are granted a custom access token to make future requests to the provider wallet
* The user's wallet addresses are then attached to the requester's user object as a new cross-app linked account
* If the provider allows for the wallet to be used for signatures and transactions, the requester can request signatures and transactions using the custom access token. Providers can also choose to make their wallets available in read-only mode.

Privy enables the provider to opt into cross-app wallets in **read-only** mode, enabling the requester app to view the user's wallet address but not prompt the user to transact. If transactions are enabled, the user will always be redirected to the isolated subdomain to explicitly approve them, in addition to needing to be logged in to the provider site and holding the custom access token.

Concretely, this means that when a requester app requests a signature or transaction from a user's cross-app wallet, Privy will open up a pop-up to the isolated subdomain, where **the user must confirm the action explicitly.** This means requesters cannot customize wallet prompts when interacting with a provider wallet, and cannot prompt users to export private keys from a provider wallet.


# Overview
Source: https://docs.privy.io/wallets/overview



Privy builds wallet infrastructure that empowers users and applications to transact on hundreds of blockchains, including Ethereum, Solana, Base, [and more](/wallets/overview/chains) .

These wallets can be embedded within your application, to have users interact with them directly, or can be controlled by your servers via Privy's API. Use Privy to instantly spin up self-custodial wallets for your users or create a fleet of your own.

Privy embedded wallets are built on globally distributed infrastructure to ensure high uptime and low latency. They leverage secure hardware (TEEs) and client-side computation to ensure only the rightful owner can control their wallet or access its keys.

Privy also supports users connecting external wallets (like Metamask or Phantom) to your app so they can bring their assets and online identity with them to your product if they already have a wallet.

Regardless of what wallet you integrate (embedded or external wallets), you can easily request signatures and transactions from your users to interact with tokenized assets and onchain infrastructure. The logic for making these requests is similar across wallet types.

![images/walletoverview.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/walletoverview.png)

## Embedded wallets

Privy's embedded wallet system lets you build wallets directly into your app whether you're building self-custodial wallets for your users or a wallet fleet you control.

Privy's wallet infrastructure ensures only the appropriate party controls the wallet. This means you can set up wallets for any user, customer, or agent under a range of custody options.

Privy surfaces both user-centric abstractions enabling you to authenticate users and generate wallets for them, as well as wallet-centric abstractions whereby you can create wallets with assigned authorization keys to control them.

### Common usage

#### User wallets

You can generate self-custodial wallets for your users for a wallet experience that is directly embedded in your application—no separate wallet client, like a browser extension or a mobile app, required.

This means users have full custody of their wallets without needing to manage secret keys. Neither Privy nor your application ever sees the user's keys; secrets are only ever reconstituted in a secure environment under the user's control so they can sign messages or transactions.

Users can manage their embedded wallet seamlessly with their account; they never need to handle any unnecessary technical complexity. Your application can even [pregenerate wallets](/wallets/wallets/create/pregenerate-wallets) for an account, like an email address or phone number, before the user logs in. Users can also [export the key](/wallets/wallets/export) for their embedded wallet, providing an escape hatch to leave Privy at any time.

Your application can easily guide users to use their wallet with simple abstractions to prompt users to fund, transact, and sign with their wallet.

#### Managed wallets

Set up a fleet of wallets to enable secure treasury management across use cases. This means wallets with quorums of pre-approved signers and assigned policies to receive and forward funds and manage complex flows.

Register webhooks to automate events based on onchain actions, assign specific policies to wallet signers to manage risk, and more.

Server wallets leverage secure enclaves and key splitting to ensure secure key reconstitution and appropriate custody for all use cases.

### Features

Privy's wallet infrastructure gives you the flexibility to manage key signing directly or integrate onchain infrastructure like smart accounts out of the box. Wallets ship with:

* **Cross-chain usage**: Create and manage wallets on all EVM- and SVM-compatible blockchains, including Ethereum, Base, Arbitrum, HyperEVM, Solana, and Eclipse. You can also use the underlying cryptographic keys directly to transact on other chains, like Bitcoin, Spark, TRON, Stellar, and more.
* **Robust transaction controls**: Execute arbitrary transactions with wallets, such as transferring funds and arbitrary interactions with smart contracts. Make transactions idempotent to ensure that they are only submitted once in case of a retry.
* **Onchain indexing**: Broadcast transactions onchain and register event listeners (via [webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks)) on transaction status, deposits, and withdrawals.
* **Powerful policy engine**: Enforce granular policies what actions a wallet can take, set allowlisted contracts or recipients, maximum amounts to be transferred, restrictions on smart contract calldata, and more. Enforce MFA on transactions, require approval signatures from a quorum of parties, and more. [Learn more](/controls/overview)
* **Flexible custody model**: Cryptographically enforce a chain of custody on wallets, allowing you to require approvals from `m-of-n` parties to execute certain wallet actions.
* **Automated gas sponsorship**: Never worry about topping up a wallet. Keep wallets loaded to pay for transactions at all times. [Learn more](/wallets/gas-and-asset-management/overview)
* **Rich onchain integrations**: Leverage features like Privy's wallet UI library, RainbowKit connector, transaction and balance webhooks, or automated gas management to streamline your integration with the blockchain.

## External wallets

External wallets are managed by a third-party client, such as MetaMask, Phantom, or Rainbow. All browser extension wallets, hardware wallets, and mobile app wallets fall into this category.

If they choose, users may use multiple external wallets within your app and may link these wallets to their account. You can request signatures and transactions from an external wallet directly, or by integrating Privy alongside a library like wagmi, viem, or @solana/web3.js.

## Get started

<CardGroup>
  <Card title="Create a wallet" icon="rocket" href="/wallets/wallets/create/overview">
    Create a user or managed wallet
  </Card>

  <Card title="Connect external wallets" icon="screwdriver-wrench" href="/wallets/connectors/usage/connecting-external-wallets">
    Connect external wallets to your app like MetaMask or Phantom
  </Card>

  <Card title="Provision session signers" icon="code" href="/wallets/using-wallets/session-signers/overview">
    Take actions on behalf of your users with session signers
  </Card>
</CardGroup>


# Chain support
Source: https://docs.privy.io/wallets/overview/chains



Privy offers support for multiple blockchain ecosystems, organized into three distinct tiers that provide different levels of functionality.

| Blockchain                               | Tier   |
| ---------------------------------------- | ------ |
| Ethereum and all EVM-compatible networks | Tier 3 |
| Solana and SVM-compatible networks       | Tier 3 |
| Cosmos                                   | Tier 2 |
| Stellar                                  | Tier 2 |
| Bitcoin                                  | Tier 2 |
| Lightspark                               | Tier 2 |
| Bitcoin L2s                              | Tier 1 |

## Support tiers

### Tier 1: Cryptographic signing

Tier 1 provides fundamental cryptographic capabilities:

* Raw cryptographic signatures
* Basic key management

### Tier 2: Wallet abstractions

Tier 2 support focuses on core wallet functionality:

* Curve-level cryptographic signatures that can be used for transaction signing
* Basic wallet functionality, including key export
* Integration with chain-specific libraries
* Chain address derivation
* 0-index HD wallet creation and key derivation

### Tier 3: Full functionality

Chains with Tier 3 support receive comprehensive capabilities, including:

* Complete client-level support end-to-end
* Full wallet functionality
* Transaction building and submission
* Message signing
* Advanced features like MFA and embedded wallets

### Smart wallets, policies and more

Beyond this, Privy has advanced support for smart contract parsing as part of policies, native smart-contract wallet support and more.

Please reach out if you need this for the chain your product leverages.

## Upcoming support

We're actively expanding our chain support capabilities. The following chains are expected to receive support this quarter:

* Aptos
* Sui
* Tron
* Ton
* Near
* Starknet

<Info>
  Our roadmap prioritizes both expanding to new chains and enhancing support for existing chains by
  moving them to higher tiers.
</Info>

## Choosing the right integration

When building your application with Privy, consider the tier of support available for your target blockchain:

* **Tier 1 chains** support basic signing operations and require more custom implementation
* **Tier 2 chains** provide core transaction capabilities but may require chain-specific code
* **Tier 3 chains** offer the most seamless experience with full native functionality

For questions about specific chain support or to request prioritization of particular chains, please contact the Privy team.

<Warning>
  While all tiers allow for blockchain integration, lower tiers may require additional development
  effort to handle chain-specific operations.
</Warning>

<Tip>
  Learn more about configuring your application for different
  [EVM](/basics/react/advanced/configuring-evm-networks) and
  [Solana](/basics/react/advanced/configuring-evm-networks) networks
</Tip>


# Using Bitcoin
Source: https://docs.privy.io/wallets/using-wallets/bitcoin/using-bitcoin



<Tabs>
  <Tab title="React Native">
    ## Getting the wallets

    Use the `useEmbeddedBitcoinWallet` hook from the `@privy-io/expo` package to get the user's embedded Bitcoin wallets:

    ```ts
    import {useEmbeddedBitcoinWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedBitcoinWallet();
    ```

    Each entry in the `wallets` array is an object with the following fields:

    <ParamField path="chainType" type="'bitcoin-taproot' | 'bitcoin-segwit'" required>
      The type of the wallet.
    </ParamField>

    <ParamField path="address" type="string" required>
      The address (base58-encoded public key) for the wallet.
    </ParamField>

    <ParamField path="publicKey" type="string" required>
      The public key (hex encoded) for the wallet.
    </ParamField>

    <ParamField path="walletIndex" type="number" required>
      The [HD index](/wallets/wallets/create/from-my-client#param-opts-create-additional) for the
      wallet.
    </ParamField>

    <ParamField path="getProvider" type="Promise<EmbeddedBitcoinWalletProvider>" required>
      Method to get a provider for interacting with the wallet.
    </ParamField>

    The `create` method returned by `useEmbeddedBitcoinWallet` also returns this same type of object.

    ### Getting the address

    Once a user has created their embedded Bitcoin wallet, you can get its address by inspecting the `address` field of the `wallet` object:

    ```ts
    const wallet = await create({chainType: 'bitcoin-taproot'});
    console.log(wallet.address);
    // bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr
    ```

    ## Getting a wallet provider

    To send signature and transaction requests to a user's Bitcoin wallet, you must first get a **provider** instance for their wallet. This serves as a standardized abstraction to communicate requests from your app to the user's wallet.

    To get a provider for the user's Bitcoin wallet, call the `getProvider` method on the `wallet` interface returned by `useEmbeddedBitcoinWallet`:

    ```tsx
    // This assumes you have already created a Bitcoin wallet for the user
    const {wallets} = useEmbeddedBitcoinWallet();
    const wallet = wallets.find((wallet) => wallet.chainType === 'bitcoin-taproot');
    const provider = await wallet.getProvider();
    ```

    ## Signing a transaction

    To sign a transaction using a Bitcoin wallet, call the `signTransaction` method on the wallet's [provider](#provider).
    This method will return an object with a `signedTransaction` field, containing a hex-encoded string for the signed transaction.

    ```tsx
    // The `transaction` below is a `Transaction` object from `@scure/btc-signer`.
    const {signedTransaction} = await provider.signTransaction({
      psbt: bytesToHex(transaction.toPSBT())
    });
    ```

    ### Parameters

    <ParamField path="psbt" type="string" required>
      A hex-encoded transaction in Partially Signed Bitcoin Transaction format.
    </ParamField>

    ## Requesting a signature

    To request a signature from a user's Bitcoin wallet, call the `sign` method on the wallet's [provider](#provider).
    This method will return a signature over the provided `hash`, encoded as a base64 string.

    ```tsx
    // The `transaction` below is a `Transaction` object from `@scure/btc-signer`.
    const {signature} = await provider.sign({hash: transaction.hash});
    ```

    ### Parameters

    <ParamField path="hash" type="string" required>
      The hash of the transaction to sign.
    </ParamField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/send-a-transaction



<Tabs>
  <Tab title="React">
    To send a transaction from a wallet using the React SDK, use the `sendTransaction` method from the `useSendTransaction` hook:

    ```javascript
    sendTransaction: (input: UnsignedTransactionRequest, options?: SendTransactionOptions) => Promise<{ hash: HexString }>
    ```

    ### Usage

    ```javascript
    import {useSendTransaction} from '@privy-io/react-auth';
    const {sendTransaction} = useSendTransaction();
    sendTransaction({
      to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
      value: 100000
    });
    ```

    ### Parameters

    <ParamField path="input" type="UnsignedTransactionRequest" required>
      The details of the transaction to send on the chain.
    </ParamField>

    <ParamField path="options.uiOptions" type="SendTransactionModalUIOptions">
      The options for the UI of the send transaction modal. [Learn
      more](/wallets/using-wallets/ui-library).
    </ParamField>

    <ParamField path="options.fundWalletConfig" type="FundWalletConfig">
      The configuration for funding the wallet.
    </ParamField>

    <ParamField path="options.address" type="string">
      The address of the wallet to use for sending the transaction.
    </ParamField>

    ### Returns

    <ResponseField name="hash" type="HexString">
      The hash for the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To send a transaction from a wallet using the React Native SDK use the `request` method from the wallets EIP1193 provider:

    ```javascript
    request: (request: { method: 'eth_sendTransaction', params: [SendTransactionParams] }) => Promise<HexString>
    ```

    ### Usage

    ```javascript
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    const provider = await wallet.getProvider();
    const accounts = await provider.request({
        method: 'eth_requestAccounts',
    });

    // Send transaction (will be signed and populated)
    const response = await provider.request({
        method: 'eth_sendTransaction',
        params: [
            {
                from: accounts[0],
                to: '0x0000000000000000000000000000000000000000',
                value: '0x2386F26FC10000',
            },
        ],
    });
    ```

    ### Parameters

    <ParamField path="request.method" type="'eth_sendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="request.params" type="SendTransactionParams" required>
      The details of the transaction to send on the chain.
    </ParamField>

    ### Returns

    <ResponseField name="response" type="HexString">
      The hash for the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Use the `request` method on the Ethereum provider to send a transaction with an Ethereum wallet.

    ```swift
    public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    ```

    ### Usage

    ```swift
    let provider = wallet.provider

    let tx = try JSONEncoder().encode([
        "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        "value": "0x186a0", // 100000 in hex
        "chainId": "0x2105", // 8453 (Base) in hex
        "from": wallet.address
    ])

    guard let txString = String(data: tx, encoding: .utf8) else {
        print("Data encoding error")
        return
    }

    let transactionHash = try await provider.request(
        EthereumRpcRequest(
            method: "eth_sendTransaction",
            params: [txString]
        )
    )
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="[String]" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="transactionHash" type="string">
      The hash of the broadcasted transaction.
    </ResponseField>

    ### HD wallets

    Ethereum embedded wallets are [hierarchical deterministic (HD) wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets), and a user's seed entropy can support multiple separate embedded wallets.

    <Warning>
      HD wallets are only supported on Ethereum. `allowAdditional` is not supported for Solana wallets.
    </Warning>

    ### Send a request with the new wallet

    To send a request to an embedded wallet not at the 0-index, pass the desired wallet address as an optional second parameter to `provider.request`.

    ```swift
    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // the target wallet here is looked up by it's position in the list,
    // but you may choose to have some application state that includes
    // it's address, and look it up that way
    let wallet = wallets[1]

    // Get RPC provider for wallet
    let provider = wallet.provider

    let response = try await provider.request(
        RpcRequest(
            method: "personal_sign",
            params: ["The message that is being signed", wallet.address]
        )
    )
    ```
  </Tab>

  <Tab title="Android">
    Use the `request` method on the Ethereum wallet provider to send a transaction with an Ethereum wallet.

    ```kotlin
    public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    ```

    ### Usage

    ```kotlin
    val transaction = JSONObject().apply {
        put("to", "0xE3070d3e4309afA3bC9a6b057685743CF42da77C")
        put("value", "0x186a0") // 100000 in hex
        put("chainId", "0x2105") // 8453 (Base) in hex
        put("from", ethereumWallet.address)
    }.toString()

    val result = ethereumWallet.provider.request(
        request = EthereumRpcRequest(
            method = "eth_sendTransaction",
            params = listOf(transaction),
        ),
    )

    when (result) {
        is Result.Success -> {
            val transactionHash = result.data.data
            // Handle successful transaction
        }
        is Result.Failure -> {
            // Handle error
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<String>" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_sendTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    Use the `Request` method on the wallet's RPC provider to send a transaction with an Ethereum wallet.

    ```csharp
    public Task<RpcResponse> Request(RpcRequest request);
    ```

    ### Usage

    ```csharp
    // Create transaction JSON
    string transactionJson = JsonUtility.ToJson(new {
        to = "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        value = "0x186a0", // 100000 in hex
        chainId = "0x2105", // 8453 (Base) in hex
        from = embeddedWallet.Address
    });

    // Create RPC request
    var rpcRequest = new RpcRequest
    {
        Method = "eth_sendTransaction",
        Params = new string[] { transactionJson }
    };

    // Send transaction
    RpcResponse transactionResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

    // Transaction hash is in the response data
    string transactionHash = transactionResponse.Data;
    ```

    ### Parameters

    <ParamField path="Method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="Params" type="string[]" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="RpcResponse" type="RpcResponse">
      An RPC response object with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_sendTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `request` method on the Ethereum wallet provider to send a transaction with an Ethereum wallet.

    ```dart
    Future<Result<EthereumRpcResponse>> request(EthereumRpcRequest request);
    ```

    ### Usage

    ```dart
    // Create transaction parameters as a Map
    final transactionMap = {
        'to': '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
        'value': '0x186a0', // 100000 in hex
        'chainId': '0x2105', // 8453 (Base) in hex
        'from': ethereumWallet.address
    };

    // Convert Map to JSON string
    final transactionJson = jsonEncode(transactionMap);

    // Create the RPC request
    final rpcRequest = EthereumRpcRequest(
        method: 'eth_sendTransaction',
        params: [transactionJson],
    );

    // Send the transaction
    final result = await ethereumWallet.provider.request(rpcRequest);

    // Handle the result
    result.when(
        success: (response) {
            final transactionHash = response.data;
            print('Transaction sent with hash: $transactionHash');
        },
        failure: (error) {
            print('Failed to send transaction: $error');
        },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<dynamic>" required>
      List containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_sendTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#node-js).
    </Tip>

    Use the `sendTransaction` method on the Ethereum client to send a transaction with an Ethereum wallet.

    ```js
    sendTransaction: (input: EthereumSendTransactionInputType) => Promise<EthereumSendTransactionResponseType>
    ```

    ### Usage

    ```js
    const {hash, caip2} = await privy.walletApi.ethereum.sendTransaction({
        walletId: 'insert-wallet-id',
        caip2: 'eip155:8453',
        transaction: {
            to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
            value: '0x2386F26FC10000',
            chainId: 8453,
        },
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to send the transaction from.
    </ParamField>

    <ParamField path="caip2" type="`eip155:${number}`" required>
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField path="transaction" type="EthereumTransactionType" required>
      The transaction to send.
    </ParamField>

    ### Returns

    <ResponseField name="hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="caip2" type="`eip155:${number}`">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>

    <Warning>
      A successful response indicates that the transaction has been broadcasted to the network.
      Transactions may get broadcasted but still fail to be confirmed by the network: we recommend
      [listening for transaction event
      webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks) to evaluate and
      handle transactions stuck in a broadcasted state.
    </Warning>
  </Tab>

  <Tab title="REST API">
    To send a transaction make a `POST` request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "eth_sendTransaction",
        "caip2": "eip155:1",
        "params": {
            "transaction": {
                "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
                "value": "0x2386F26FC10000",
            }
        }
    }'
    ```

    A successful response will look like the following:

    ```json
    {
        "method": "eth_sendTransaction",
        "data": {
            "hash": "<transaction-hash>",
            "caip2": "eip155:1"
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_sendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="caip2" type="`eip155:${number}`" required>
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField path="params.transaction" type="EthereumTransactionType" required>
      The details of the transaction to send on the chain.
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_sendTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="data.caip2" type="`eip155:${number}`">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>

    <Warning>
      A successful response indicates that the transaction has been broadcasted to the network.
      Transactions may get broadcasted but still fail to be confirmed by the network: we recommend
      [listening for transaction event
      webhooks](/wallets/gas-and-asset-management/assets/transaction-event-webhooks) to evaluate and
      handle transactions stuck in a broadcasted state.
    </Warning>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-a-message



<Info>
  This method uses Ethereum's `personal_sign` RPC method. If you are looking for a low-level raw signature over a input hash, see [secp256k1\_sign](/wallets/using-wallets/ethereum/sign-a-raw-hash).
</Info>

<Tabs>
  <Tab title="React">
    Use the `signMessage` method exported from the `useSignMessage` hook to sign a message with an Ethereum embedded wallet.

    ### Usage

    ```tsx
    import {useSignMessage} from '@privy-io/react-auth';

    const {signMessage} = useSignMessage();

    const uiOptions = {
      title: 'You are voting for foobar project'
    };

    const {signature} = await signMessage({message: 'I hereby vote for foobar'}, {uiOptions});
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      Message to be signed.
    </ParamField>

    <ParamField path="options" type="Object">
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="uiOptions" type="SignMessageModalUIOptions">
          UI options to customize the signature prompt modal. [Learn
          more](/wallets/using-wallets/ui-library)
        </ParamField>

        <ParamField path="address" type="string">
          Address for the embedded wallet signing the message. Only set this parameter if using imported
          embedded wallets or multiple HD embedded wallets for the same user. Defaults to the user's
          embedded wallet at HD index 0.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>

    ### Callbacks

    Configure callbacks for Privy's `signMessage` method on the `useSignMessage` hook:

    ```tsx
    import {useSignMessage} from '@privy-io/react-auth';

    const {signMessage} = useSignMessage({
      onSuccess: ({signature}) => {
        console.log(signature);
        // Any logic you'd like to execute after a user successfully signs a message
      },
      onError: (error) => {
        console.log(error);
        // Any logic you'd like to execute after a user exits the message signing flow or there is an error
      }
    });

    // Then call `signMessage` in your code, which will invoke these callbacks on completion
    ```

    As parameters to **`useSignMessage`**, you may include an **`onSuccess`** callback and/or an **`onError`** callback.

    While this component is mounted, any invocation of **`signMessage`** will trigger the **`onSuccess`** callback or **`onError`** callback on completion, depending on if the message was successfully signed or not.

    #### onSuccess

    If set, the **`onSuccess`** callback will execute after a user has successfully signed the message. Within this callback, you can access a **`signature`** parameter, which is the **`signature`** string value generated by the wallet to sign the message.

    #### onError

    If set, the **`onError`** callback will execute after a user attempts to sign a message and there is an error, or if the user exits the signature flow prematurely. Within this callback, you may access an **`error`** code with more information about the error.
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ### Usage

    ```tsx
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    // Get an EIP-1193 Provider
    const provider = await wallet.getProvider();
    // Get address
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    // Sign message
    const message = 'I hereby vote for foobar';
    const signature = await provider.request({
      method: 'personal_sign',
      params: [message, accounts[0]]
    });
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Request a message signature on the wallet's Ethereum provider.

    ### Usage

    ```swift
    guard let user = privy.user else {
        // If user is null, user is not authenticated
        return
    }

    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // Grab the desired wallet. Here, we retrieve the first wallet
    guard let wallet = ethereumWallets.first else {
        // No ETH wallets
        return
    }

    let data = EthereumRpcRequest(method: "personal_sign", params: ["A message to sign", wallet.address])
    let signature = try await wallet.provider.request(data)

    print("Result signature: \(signature)")
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>

    ### HD wallets

    Ethereum embedded wallets are [hierarchical deterministic (HD) wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets), and a user's seed entropy can support multiple separate embedded wallets.

    <Warning>
      HD wallets are only supported on Ethereum. `allowAdditional` is not supported for Solana wallets.
    </Warning>

    ### Send a request with the new wallet

    To send a request to an embedded wallet not at the 0-index, pass the desired wallet address as an optional second parameter to `provider.request`.

    ```swift
    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // the target wallet here is looked up by it's position in the list,
    // but you may choose to have some application state that includes
    // it's address, and look it up that way
    let wallet = wallets[1]

    // Get RPC provider for wallet
    let provider = wallet.provider

    let response = try await provider.request(
        RpcRequest(
            method: "personal_sign",
            params: ["The message that is being signed", wallet.address]
        )
    )
    ```
  </Tab>

  <Tab title="Android">
    ### Usage

    ```kotlin
    // Get Privy user
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
      // Retrieve list of user's embedded Ethereum wallets
      val ethereumWallets = user.embeddedEthereumWallets

      if (ethereumWallets.isNotEmpty()) {
        // Grab the desired wallet. Here, we retrieve the first wallet
        val ethereumWallet = ethereumWallets.first()

        // Make an rpc request
        ethereumWallet.provider.request(
          request = EthereumRpcRequest(
            method = "personal_sign",
            params = listOf("A message to sign", ethereumWallet.address),
          ),
        )
      }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ### Usage

    ```csharp
    try {
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];
        var rpcRequest = new RpcRequest
        {m
            Method = "personal_sign",
            Params = new string[] { "A message to sign", embeddedWallet.Address }  // Use the 'new' keyword here
        };
        RpcResponse personalSignResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);
        Debug.Log(personalSignResponse.Data);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    ### Usage

    ```dart
    // Get an EIP-1193 Provider
    final ethereumWallet = privy.user.embeddedEthereumWallets.first;
    final provider = ethereumWallet.provider;

    // Sign message
    final message = 'A message to you Rudy';
    final request = EthereumRpcRequest(
      method: 'personal_sign',
      params: [message, ethereumWallet.address],
    );

    final result = await provider.request(request);

    result.fold(
      onSuccess: (response) {
        final signature = response.data;
        print('Signature: $signature');
      },
      onFailure: (error) {
        print('Error signing message: ${error.message}');
      },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string | Uint8Array" required>
          The string or bytes to sign with the wallet.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'personal_sign'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signMessage` method on the Ethereum client to sign a message with an Ethereum wallet.

    ```javascript
    signMessage: async ({walletId: string, message: string, idempotencyKey?: string}) => Promise<{signature: string, encoding: 'hex'}>
    ```

    ### Usage

    ```tsx
    const {signature, encoding} = await privy.walletApi.ethereum.signMessage({
      walletId: 'insert-wallet-id',
      message: 'Hello world'
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="message" type="string | Uint8Array" required>
      The string or bytes to sign with the wallet.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'hex'` is supported for
      Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To sign a message make a POST request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'personal_sign'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The message to sign with the wallet. If the message to sign is raw bytes, you must serialize
          the message as a hexadecimal string.
        </ParamField>

        <ParamField path="encoding" type="'utf-8' | 'hex'" required>
          The encoding format for `params.message`. Use `utf-8` for a string message and `hex` for
          bytes.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'personal_sign'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'hex'">
          The encoding format for the returned `signature`. Currently, only `'hex'` is supported for Ethereum.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "chain_type": "ethereum",
      "method": "personal_sign",
      "params": {
        "message": "Hello, Ethereum.",
        "encoding": "utf-8"
      }
    }'
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-a-raw-hash



<Info>
  This interface is for raw signing over a hash, which primarily applies to Coinbase Smart Wallet integrations, EIP-7702 authorizations and other scenarios requiring basic curve-level signing. For most use cases, such as authenticating to a website or proving ownership, we recommend [signing a message](/wallets/using-wallets/ethereum/sign-a-message).
</Info>

<Tabs>
  <Tab title="React">
    To sign a raw hash from a wallet using the React SDK use the `request` method from the wallets EIP1193 provider:

    ```javascript
     request: (request: { method: 'secp256k1_sign', params: [hash: Hex] }) => Promise<HexString>
    ```

    ### Usage

    ```javascript
    import {useWallets} from '@privy-io/react-auth';

    const {wallets} = useWallets();
    const wallet = wallets[0];

    const provider = await wallet.getProvider();

    // Sign raw hash
    const response = await provider.request({
      method: 'secp256k1_sign',
      params: ['0xTheRawHash']
    });
    ```

    ### Parameters

    <ParamField path="request.method" type="'secp256k1_sign'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="request.params" type="[hash: Hex]" required>
      The raw hash to sign over.
    </ParamField>

    ### Returns

    <ResponseField name="response" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `secp256k1Sign` method on the Ethereum client to sign a raw hash along the secp256k1 curve.

    ```javascript
    secp256k1Sign: async ({walletId: string, hash: string}) => Promise<{signature: string, encoding: 'hex'}>
    ```

    ### Usage

    ```tsx
    const {signature, encoding} = await privy.walletApi.ethereum.secp256k1Sign({
      walletId: 'insert-wallet-id',
      hash: '0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa'
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="hash" type="hash" required>
      The hash to sign. Must start with '0x'.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'hex'` is supported for
      Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To sign a message make a POST request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'secp256k1_sign'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="hash" type="string" required>
          The hash to sign with the wallet. Must start with '0x'.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'secp256k1_sign'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'hex'">
          The encoding format for the returned `signature`. Currently, only `'hex'` is supported for Ethereum.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "chain_type": "ethereum",
      "method": "secp256k1_sign",
      "params": {
        "hash": "0x6503b027a625549f7be691646404f275f149d17a119a6804b855bac3030037aa",
        "encoding": "hex"
      }
    }'
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-a-transaction



<Tabs>
  <Tab title="React">
    To send a transaction from a wallet using the React SDK, use the `signTransaction` method from the `useSignTransaction` hook:

    ```javascript
    signTransaction: (input: UnsignedTransactionRequest, options?: SendTransactionOptions) => Promise<{ signature: HexString }>
    ```

    ### Usage

    ```javascript
    import {useSignTransaction} from '@privy/react-auth';
    const {signTransaction} = useSignTransaction();
    signTransaction({
      to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
      value: 100000
    });
    ```

    ### Parameters

    <ParamField path="input" type="UnsignedTransactionRequest" required>
      The details of the transaction to sign.
    </ParamField>

    <ParamField path="options.uiOptions" type="SendTransactionModalUIOptions">
      The options for the UI of the send transaction modal. [Learn
      more](/wallets/using-wallets/ui-library).
    </ParamField>

    <ParamField path="options.fundWalletConfig" type="FundWalletConfig">
      The configuration for funding the wallet.
    </ParamField>

    <ParamField path="options.address" type="string">
      The address of the wallet to use for signing the transaction.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="HexString">
      The signed transaction hash.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To sign a transaction from a wallet using the React Native SDK use the `request` method from the wallets EIP1193 provider:

    ```javascript
    request: (request: { method: 'eth_signTransaction', params: [SignTransactionParams] }) => Promise<HexString>
    ```

    ### Usage

    ```javascript
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    const provider = await wallet.getProvider();
    const accounts = await provider.request({
        method: 'eth_requestAccounts',
    });

    // Sign transaction (will be signed and populated)
    const response = await provider.request({
        method: 'eth_signTransaction',
        params: [
            {
                from: accounts[0],
                to: '0x0000000000000000000000000000000000000000',
                value: '1',
            },
        ],
    });
    ```

    ### Parameters

    <ParamField path="request.method" type="'eth_signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="request.params" type="SignTransactionParams" required>
      The details of the transaction to sign.
    </ParamField>

    ### Returns

    <ResponseField name="response" type="HexString">
      The hash for the broadcasted transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Use the `request` method on the Ethereum provider to sign a transaction with an Ethereum wallet.

    ```swift
    public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    ```

    ### Usage

    ```swift
    let provider = wallet.provider

    let tx = try JSONEncoder().encode([
        "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        "value": "0x186a0", // 100000 in hex
        "chainId": "0x2105", // 8453 (Base) in hex
        "from": wallet.address
    ])

    guard let txString = String(data: tx, encoding: .utf8) else {
        print("Data encoding error")
        return
    }

    let transactionHash = try await provider.request(
        EthereumRpcRequest(
            method: "eth_signTransaction",
            params: [txString]
        )
    )
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="[String]" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="transactionHash" type="string">
      The hash of the broadcasted transaction.
    </ResponseField>

    ### HD wallets

    Ethereum embedded wallets are [hierarchical deterministic (HD) wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets), and a user's seed entropy can support multiple separate embedded wallets.

    <Warning>
      HD wallets are only supported on Ethereum. `allowAdditional` is not supported for Solana wallets.
    </Warning>

    ### Send a request with the new wallet

    To send a request to an embedded wallet not at the 0-index, pass the desired wallet address as an optional second parameter to `provider.request`.

    ```swift
    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // the target wallet here is looked up by it's position in the list,
    // but you may choose to have some application state that includes
    // it's address, and look it up that way
    let wallet = wallets[1]

    // Get RPC provider for wallet
    let provider = wallet.provider

    let response = try await provider.request(
        RpcRequest(
            method: "personal_sign",
            params: ["The message that is being signed", wallet.address]
        )
    )
    ```
  </Tab>

  <Tab title="Android">
    Use the `request` method on the Ethereum wallet provider to sign a transaction with an Ethereum wallet.

    ```kotlin
    public suspend fun request(request: EthereumRpcRequest): Result<EthereumRpcResponse>
    ```

    ### Usage

    ```kotlin
    val transaction = JSONObject().apply {
        put("to", "0xE3070d3e4309afA3bC9a6b057685743CF42da77C")
        put("value", "0x186a0") // 100000 in hex
        put("chainId", "0x2105") // 8453 (Base) in hex
        put("from", ethereumWallet.address)
    }.toString()

    val result = ethereumWallet.provider.request(
        request = EthereumRpcRequest(
            method = "eth_signTransaction",
            params = listOf(transaction),
        ),
    )

    when (result) {
        is Result.Success -> {
            val transactionHash = result.data.data
            // Handle successful transaction
        }
        is Result.Failure -> {
            // Handle error
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<String>" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_signTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    Use the `Request` method on the wallet's RPC provider to sign a transaction with an Ethereum wallet.

    ```csharp
    public Task<RpcResponse> Request(RpcRequest request);
    ```

    ### Usage

    ```csharp
    // Create transaction JSON
    string transactionJson = JsonUtility.ToJson(new {
        to = "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
        value = "0x186a0", // 100000 in hex
        chainId = "0x2105", // 8453 (Base) in hex
        from = embeddedWallet.Address
    });

    // Create RPC request
    var rpcRequest = new RpcRequest
    {
        Method = "eth_signTransaction",
        Params = new string[] { transactionJson }
    };

    // Sign transaction
    RpcResponse transactionResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);

    // Transaction hash is in the response data
    string transactionHash = transactionResponse.Data;
    ```

    ### Parameters

    <ParamField path="Method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="Params" type="string[]" required>
      Array containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="RpcResponse" type="RpcResponse">
      An RPC response object with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_signTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `request` method on the Ethereum wallet provider to sign a transaction with an Ethereum wallet.

    ```dart
    Future<Result<EthereumRpcResponse>> request(EthereumRpcRequest request);
    ```

    ### Usage

    ```dart
    // Create transaction parameters as a Map
    final transactionMap = {
        'to': '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
        'value': '0x186a0', // 100000 in hex
        'chainId': '0x2105', // 8453 (Base) in hex
        'from': ethereumWallet.address
    };

    // Convert Map to JSON string
    final transactionJson = jsonEncode(transactionMap);

    // Create the RPC request
    final rpcRequest = EthereumRpcRequest(
        method: 'eth_signTransaction',
        params: [transactionJson],
    );

    // Sign the transaction
    final result = await ethereumWallet.provider.request(rpcRequest);

    // Handle the result
    result.when(
        success: (response) {
            final transactionHash = response.data;
            print('Transaction sent with hash: $transactionHash');
        },
        failure: (error) {
            print('Failed to sign transaction: $error');
        },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="List<dynamic>" required>
      List containing the transaction JSON as a single string element.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="to" type="string" required>
          The address to send the transaction to.
        </ParamField>

        <ParamField path="value" type="string">
          The amount of wei to send, as a hexadecimal string.
        </ParamField>

        <ParamField path="chainId" type="string">
          The chain ID as a hexadecimal string. Defaults to mainnet (0x1) if omitted.
        </ParamField>

        <ParamField path="from" type="string">
          The address sending the transaction (the user's wallet address).
        </ParamField>

        <ParamField path="data" type="string">
          The data to include with the transaction, as a hexadecimal string.
        </ParamField>

        <ParamField path="gasLimit" type="string">
          The gas limit for the transaction, as a hexadecimal string.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<EthereumRpcResponse>">
      A Result that, when successful, contains the EthereumRpcResponse with:

      <Expandable title="child attributes" defaultOpen="true">
        <ResponseField name="method" type="string">
          The RPC method that was executed (eth\_signTransaction).
        </ResponseField>

        <ResponseField name="data" type="string">
          The transaction hash for the broadcasted transaction.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), learn more [here](/wallets/using-wallets/ethereum/web3-integrations#node-js).
    </Tip>

    Use the `signTransaction` method on the Ethereum client to sign a transaction with an Ethereum wallet.

    ```js
    signTransaction: (input: EthereumSignTransactionInputType) => Promise<EthereumSignTransactionResponseType>
    ```

    ### Usage

    ```js
    const {signedTransaction, encoding} = await privy.walletApi.ethereum.signTransaction({
        walletId: 'insert-wallet-id',
        transaction: {
            to: '0xE3070d3e4309afA3bC9a6b057685743CF42da77C',
            value: '0x2386F26FC10000',
            chainId: 8453,
        },
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to sign the transaction with.
    </ParamField>

    <ParamField path="transaction" type="EthereumTransactionType" required>
      The transaction to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signedTransaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="encoding" type="'rlp'">
      The encoding format for the returned `signedTransaction`. Currently, only `'rlp'` is supported for Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To sign a transaction make a `POST` request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "eth_signTransaction",
        "params": {
            "transaction": {
              "to": "0xE3070d3e4309afA3bC9a6b057685743CF42da77C",
              "value": "0x2386F26FC10000",
              "chain_id": 1,
              "type": 2,
              "gas_limit": "0x5208",
              "nonce": 1,
              "max_fee_per_gas": "0x14bf7dadac",
              "max_priority_fee_per_gas": "0xf4240"
            }
        }
    }'
    ```

    A successful response will look like the following:

    ```json
    {
      "method": "eth_signTransaction",
      "data": {
        "signed_transaction": "0x28eac519bf4051a624d4246a5788667baf84dcd7d2a439b314b339013b5cdb4c",
        "encoding": "rlp"
      }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <ParamField path="transaction" type="EthereumTransactionType" required>
        The details of the transaction to send on the chain.
      </ParamField>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_signTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.signed_transaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="data.encoding" type="'rlp'">
      The encoding format for the signed transaction. Currently, only `'rlp'` is supported for Ethereum.
    </ResponseField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/ethereum/sign-typed-data



<Tabs>
  <Tab title="React">
    Use the `signTypedData` method exported from the `useSignTypedData` hook to sign a message with an Ethereum embedded wallet.

    ```javascript
    signTypedData(input: SignTypedDataParams, options?: SignTypedDataOptions): Promise<{signature: string}>
    ```

    ### Usage

    ```tsx
    import {useSignTypedData} from '@privy-io/react-auth';

    const {signTypedData} = useSignTypedData();
    const {signature} = await signTypedData({...});
    ```

    ### Parameters

    <ParamField path="input" type="Object" required>
      The typed data object to sign with the wallet, with the properties defined in
      [EIP-712](https://eips.ethereum.org/EIPS/eip-712).
    </ParamField>

    <ParamField path="options" type="Object">
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="uiOptions" type="SignMessageModalUIOptions">
          UI options to customize the signature prompt modal. [Learn
          more](/wallets/using-wallets/ui-library)
        </ParamField>

        <ParamField path="address" type="string">
          Address for the embedded wallet signing the message. Only set this parameter if using imported
          embedded wallets or multiple HD embedded wallets for the same user. Defaults to the user's
          embedded wallet at HD index 0.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Response

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>

    ### Callbacks

    Configure callbacks for `signTypedData` with the `useSignTypedData` hook.

    ```tsx
    import {useSignTypedData} from '@privy-io/react-auth';

    const {signTypedData} = useSignTypedData({
      onSuccess: ({signature}) => {
        console.log(signature);
        // Any logic you'd like to execute after a user successfully signs the EIP-712 typed data
      },
      onError: (error) => {
        console.log(error);
        // Any logic you'd like to execute after a user exits the signing flow or there is an error
      }
    });

    // Then call `signTypedData` in your code, which will invoke these callbacks on completion
    ```

    As parameters to **`useSignTypedData`**, you may include an **`onSuccess`** callback and/or an **`onError`** callback.

    While this component is mounted, any invocation of **`signTypedData`** will trigger the **`onSuccess`** callback or **`onError`** callback on completion, depending on if the data was successfully signed or not.

    ### onSuccess

    If set, the **`onSuccess`** callback will execute after a user has successfully signed the message. Within this callback, you can access a **`signature`** parameter, which is the **`signature`** string value generated by the wallet to sign the data.

    ### onError

    If set, the **`onError`** callback will execute after a user attempts to sign the typed data and there is an error, or if the user exits the signature flow prematurely. Within this callback, you may access an **`error`** code with more information about the error.
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ```javascript
    request: ({method: 'eth_signTypedData_v4', params: [address, typedData]}) => Promise<{signature: string}>
    ```

    ### Usage

    ```tsx
    import {useEmbeddedEthereumWallet} from '@privy-io/expo';

    const {wallets} = useEmbeddedEthereumWallet();
    const wallet = wallets[0];

    // Get an EIP-1193 Provider
    const provider = await wallet.getProvider();
    // Get address
    const accounts = await provider.request({
      method: 'eth_requestAccounts'
    });

    const signature = await provider.request({
      method: 'eth_signTypedData_v4',
      params: [accounts[0], typedData]
    });
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typeData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    To request an [EIP712](https://eips.ethereum.org/EIPS/eip-712) signature from a user's embedded wallet, send an [`eth_signTypedData_v4`](https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/) JSON-RPC request to the wallet's EIP1193 provider.

    ```swift [expandable]
    // Define a struct to represent your typed data
    struct Param: Codable {
        let types: ParamTypes
        let primaryType: String
        let domain: Domain
        let message: Message
    }

    struct ParamTypes: Codable {
        let eIP712Domain: [DomainType]
        let person: [DomainType]
        let mail: [DomainType]

        enum CodingKeys: String, CodingKey {
            case eIP712Domain = "EIP712Domain"
            case person = "Person"
            case mail = "Mail"
        }
    }

    struct DomainType: Codable {
        let name: String
        let type: String
    }

    struct Domain: Codable {
        let name: String
        let version: String
        let chainId: Int
        let verifyingContract: String
    }

    struct Message: Codable {
        struct W: Codable {
            let name: String
            let wallet: String
        }

        let from: W
        let to: W
        let contents: String
    }

    func typedData() async throws {
        let wallets = user.embeddedEthereumWallets

        // Grab the desired wallet. Here, we retrieve the first wallet
        guard let wallet = wallets.first else {
            // No ETH wallets
            return
        }

        let typedData = Param(
            types: ParamTypes(
                eIP712Domain: [
                    DomainType(name: "name", type: "string"),
                    DomainType(name: "version", type: "string"),
                    DomainType(name: "chainId", type: "uint256"),
                    DomainType(name: "verifyingContract", type: "address"),
                ],
                person: [
                    DomainType(name: "name", type: "string"),
                    DomainType(name: "wallet", type: "address")
                ],
                mail: [
                    DomainType(name: "from", type: "Person"),
                    DomainType(name: "to", type: "Person"),
                    DomainType(name: "contents", type: "string"),
                ]
            ), primaryType: "Mail",
            domain: Domain(
                name: "Ether Mail",
                version: "1",
                chainId: 1,
                verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
            ),
            message: Message(
                from: Message.W(name: "Cow", wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"),
                to: Message.W(name: "Bob", wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"),
                contents: "Hello, Bob!"
            )
        )

        let encodedTypedData = try JSONEncoder().encode(typedData)

        guard let typedDataStr = String(data: encodedTypedData, encoding: .utf8) else {
            print("Data parse error")
            return
        }

        let signature = try await wallet.provider.request(
            EthereumRpcRequest(
                method: "eth_signTypedData_v4",
                params: [wallet.address, typedDataStr]
            )
        )

        print(signature)
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'personal_sign'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typedData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>

    ### HD wallets

    Ethereum embedded wallets are [hierarchical deterministic (HD) wallets](https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets), and a user's seed entropy can support multiple separate embedded wallets.

    <Warning>
      HD wallets are only supported on Ethereum. `allowAdditional` is not supported for Solana wallets.
    </Warning>

    ### Send a request with the new wallet

    To send a request to an embedded wallet not at the 0-index, pass the desired wallet address as an optional second parameter to `provider.request`.

    ```swift
    // Retrieve list of user's embedded Ethereum wallets
    let ethereumWallets = user.embeddedEthereumWallets

    // the target wallet here is looked up by it's position in the list,
    // but you may choose to have some application state that includes
    // it's address, and look it up that way
    let wallet = wallets[1]

    // Get RPC provider for wallet
    let provider = wallet.provider

    let response = try await provider.request(
        RpcRequest(
            method: "personal_sign",
            params: ["The message that is being signed", wallet.address]
        )
    )
    ```
  </Tab>

  <Tab title="Android">
    ```kotlin
    // Get Privy user
    ethereumWallet.provider.request(
      request = EthereumRpcRequest(
        method = "eth_signTypedData_v4",
        params = listOf(ethereumWallet.address, typedData),
      ),
    )
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typeData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ```csharp
    try {
        IEmbeddedEthereumWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedWallets[0];
        var rpcRequest = new RpcRequest
        {m
            Method = "eth_signTypedData_v4",
            Params = new string[] {embeddedWallet.Address, typedData }  // Use the 'new' keyword here
        };
        RpcResponse signTypedDataResponse = await embeddedWallet.RpcProvider.Request(rpcRequest);
        Debug.Log(signTypedDataResponse.Data);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing messages, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typedData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    {' '}

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Get an EIP-1193 Provider
    final ethereumWallet = privy.user.embeddedEthereumWallets.first;
    final provider = ethereumWallet.provider;

    // Define the typed data
    final typedData = {
      'types': {
        'EIP712Domain': [
          {'name': 'name', 'type': 'string'},
          {'name': 'version', 'type': 'string'},
          {'name': 'chainId', 'type': 'uint256'},
          {'name': 'verifyingContract', 'type': 'address'},
        ],
        'Person': [
          {'name': 'name', 'type': 'string'},
          {'name': 'wallet', 'type': 'address'},
        ],
        'Mail': [
          {'name': 'from', 'type': 'Person'},
          {'name': 'to', 'type': 'Person'},
          {'name': 'contents', 'type': 'string'},
        ],
      },
      'primaryType': 'Mail',
      'domain': {
        'name': 'Ether Mail',
        'version': '1',
        'chainId': 1,
        'verifyingContract': '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
      },
      'message': {
        'from': {
          'name': 'Cow',
          'wallet': '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
        },
        'to': {
          'name': 'Bob',
          'wallet': '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
        },
        'contents': 'Hello, Bob!',
      },
    };

    // Create the RPC request
    final request = EthereumRpcRequest(
      method: 'eth_signTypedData_v4',
      params: [ethereumWallet.address, jsonEncode(typedData)],
    );

    // Sign the typed data
    final result = await provider.request(request);

    result.fold(
      onSuccess: (response) {
        final signature = response.data;
        print('Signature: $signature');
      },
      onFailure: (error) {
        print('Error signing typed data: ${error.message}');
      },
    );
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      The method for the wallet request. For signing typed data, this is `'eth_signTypedData_v4'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>

        <ParamField path="typedData" type="Object" required>
          The typed data to sign with the wallet.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_signTypedData_v4'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signTypedData` method on the Ethereum client to sign a message with an Ethereum wallet.

    ```javascript
    signTypedData: (input: {walletId: string, typedData: TypedData}) => Promise<{signature: string, encoding: 'hex'}>
    ```

    ### Usage

    ```tsx
    // Get the signature and encoding from the response
    const {signature, encoding} = await privy.walletApi.ethereum.signTypedData({
      walletId: 'insert-wallet-id',
      typedData: {
        domain: {
          name: 'Ether Mail',
          version: '1',
          chainId: 1,
          verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'
        },
        types: {
          EIP712Domain: [
            {name: 'name', type: 'string'},
            {name: 'version', type: 'string'},
            {name: 'chainId', type: 'uint256'},
            {name: 'verifyingContract', type: 'address'}
          ],
          Person: [
            {name: 'name', type: 'string'},
            {name: 'wallet', type: 'address'}
          ],
          Mail: [
            {name: 'from', type: 'Person'},
            {name: 'to', type: 'Person'},
            {name: 'contents', type: 'string'}
          ]
        },
        primaryType: 'Mail',
        message: {
          from: {
            name: 'Cow',
            wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826'
          },
          to: {
            name: 'Bob',
            wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB'
          },
          contents: 'Hello, Bob!'
        }
      }
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    <ParamField path="typedData" type="Object" required>
      The typed data object to sign with the wallet, with the properties defined in
      [EIP-712](https://eips.ethereum.org/EIPS/eip-712).

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="domain" type="Object" required>
          The typed data's domain, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
        </ParamField>

        <ParamField path="types" type="Object" required>
          The typed data's types, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
        </ParamField>

        <ParamField path="primaryType" type="string" required>
          The typed data's primary type, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
          specification.
        </ParamField>

        <ParamField path="message" type="Object" required>
          The typed data's message, per the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'hex'` is supported for
      Ethereum.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To sign typed data make a POST request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'eth_signTypedData_v4'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The message to sign with the wallet. If the message to sign is raw bytes, you must serialize
          the message as a hexadecimal string.
        </ParamField>

        <ParamField path="encoding" type="'utf-8' | 'hex'" required>
          The encoding format for `params.message`. Use `utf-8` for a string message and `hex` for
          bytes.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'eth_signTypedData_v4'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'hex'">
          The encoding format for the returned `signature`. Currently, only `'hex'` is supported for Ethereum.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash
    curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "method": "eth_signTypedData_v4",
      "params": {
        "typed_data": {
          "types": {
            "EIP712Domain": [
              { "name": "name", "type": "string" },
              { "name": "version", "type": "string" },
              { "name": "chainId", "type": "uint256" },
              { "name": "verifyingContract", "type": "address" }
            ],
            "Person": [
              { "name": "name", "type": "string" },
              { "name": "wallet", "type": "address" }
            ],
            "Mail": [
              { "name": "from", "type": "Person" },
              { "name": "to", "type": "Person" },
              { "name": "contents", "type": "string" }
            ]
          },
          "message": {
            "from": {
              "name": "Alice",
              "wallet": "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
            },
            "to": {
              "name": "Bob",
              "wallet": "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"
            },
            "contents": "Hello, Bob!"
          },
          "primary_type": "Mail",
          "domain": {
            "name": "DApp Mail",
            "version": "1",
            "chainId": 1,
            "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
          }
        }
      }
    }'
    ```
  </Tab>
</Tabs>


# Switch chains
Source: https://docs.privy.io/wallets/using-wallets/ethereum/switch-chain



<Tabs>
  <Tab title="React">
    To switch the network of a connected wallet, first [find the corresponding **`ConnectedWallet`** object](/wallets/wallets/get-a-wallet) from the **`wallets`** array.

    ```tsx
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    Then, call the wallet's **`switchChain`** method. As a parameter to the method, pass the chain ID for your desired network as a `number` or hexadecimal `string`:

    ```tsx
    await wallet.switchChain(7777777);
    ```

    For embedded wallets, **`switchChain`** will update the network of the embedded wallet behind the scenes. For external wallets, **`switchChain`** will prompt the user to switch to the target network within the external wallet's client (e.g. their browser extension or mobile app).

    **`switchChain`** returns a Promise that resolves to `void` once the wallet has successfully been switched to the target network. The Promise will reject with an error if:

    * The target chain has [not been configured](/basics/react/advanced/configuring-evm-networks).
    * The user declines the request to switch their network, if using an external wallet.
  </Tab>

  <Tab title="React Native">
    By default, embedded wallets will be connected to the first network specified in your **`supportedChains`** array, and to Ethereum mainnet if no **`supportedChains`** are specified.

    To switch the embedded wallet to a different network, **send a [`wallet_switchEthereumChain`](https://docs.metamask.io/wallet/reference/wallet_switchethereumchain/) JSON-RPC request to the wallet's EIP-1193 provider.** In the request's **`params`**, specify your target **`chainId`** as a hexadecimal string.

    ```ts
    const provider = await wallet.getProvider();
    await provider.request({
      method: 'wallet_switchEthereumChain',
      // Replace '0x5' with the chainId of your target network
      params: [{chainId: '0x5'}]
    });
    ```

    You can also use the **`eth_chainId`** request (with no **`params`**) to get the current network of the embedded wallet.
  </Tab>
</Tabs>


# Interfacing with common libraries
Source: https://docs.privy.io/wallets/using-wallets/ethereum/web3-integrations



<Tabs>
  <Tab title="React">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), [`wagmi`](https://wagmi.sh/), [`ethers`](https://docs.ethers.org/), and [`web3js`](https://web3js.readthedocs.io/en/v1.10.0/).
    </Tip>

    Read below to learn how to best integrate Privy alongside these libraries.

    ## Viem

    Viem represents connected wallets as a [**wallet client**](https://viem.sh/docs/clients/wallet.html) object, which you can use to get information about the current wallet or the request signatures and transactions.

    To get a viem wallet client for a user's connected wallet, first import your desired network from the **`viem/chains`** package and import the **`createWalletClient`** method and **`custom`** transport from **`viem`**:

    ```tsx
    import {createWalletClient, custom} from 'viem';
    // Replace `sepolia` with your desired network
    import {sepolia} from 'viem/chains';
    ```

    Then, find your desired wallet from the **`wallets`** array and switch its network to the chain you imported, using the wallet's **`switchChain`** method:

    ```tsx
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    await wallet.switchChain(sepolia.id);
    ```

    Lastly, get the wallet's EIP1193 provider using the wallet's **`getEthereumProvider`** method and pass it to viem's **`createWalletClient`** method like so:

    ```tsx
    const provider = await wallet.getEthereumProvider();
    const walletClient = createWalletClient({
        account: wallet.address as Hex,
        chain: sepolia,
        transport: custom(provider),
    });
    ```

    You can then use the [**wallet client**](https://viem.sh/docs/clients/wallet) to get information about the wallet or request signatures and transactions.

    ## Wagmi

    Privy is fully compatible with **`wagmi`**. Please see our [**wagmi guide**](/wallets/connectors/ethereum/integrations/wagmi) for setting up the integration.

    ## Ethers

    ### Ethers v5

    ```tsx
    const privyProvider = await wallet.getEthereumProvider();
    const provider = new ethers.providers.Web3Provider(privyProvider);
    ```

    ### Ethers v6

    ```tsx
    const provider = await wallet.getEthereumProvider();
    const ethersProvider = new ethers.BrowserProvider(provider);
    const signer = ethersProvider.getSigner();
    ```

    ## Web3.js

    Web3.js represents connected wallets as a [**Web3**](https://docs.web3js.org/guides/web3_providers_guide/#providers-types) object, which you can use to get information about the current wallet or the request signatures and transactions.

    To get a Web3js provider for a user's connected wallet, first [find your desired wallet](/wallets/wallets/get-a-wallet/get-connected-wallet) from the **`wallets`** array and switch it to your desired network, using the wallet's **`switchChain`** method:

    ```ts
    const {wallets} = useWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    await wallet.switchChain(sepolia.id);
    ```

    Then, get the wallet's EIP1193 provider using the wallet's **`getEthereumProvider`** method and pass it to Web3js's **`Web3`** constructor like so:

    ```ts
    const provider = await wallet.getEthereumProvider();
    const web3 = new Web3(provider);
    ```

    You can then use the [**Web3 provider**](https://docs.web3js.org/guides/web3_providers_guide/) to get information about the wallet or request signatures and transactions.
  </Tab>

  <Tab title="React Native">
    <Tip>
      Privy is fully compatible with popular web3 libraries for interfacing wallets, including [`viem`](https://viem.sh/), [`ethers`](https://docs.ethers.org/), and [`web3js`](https://web3js.readthedocs.io/en/v1.10.0/).
    </Tip>

    <Warning>
      Third-party libraries may require additional shims to be used in a React Native environment.
    </Warning>

    ### Integrating with `viem`

    First, import the necessary methods, objects, and networks from `viem`:

    ```ts
    import {createWalletClient, custom} from 'viem';
    // Replace 'mainnet' with your desired network
    import {mainnet} from 'viem/chains';
    ```

    Next, get an EIP-1193 provider for the user's embedded wallet, and switch its network to your desired network:

    ```ts
    const provider = await wallet.getProvider();
    await provider.request({
        method: 'wallet_switchEthereumChain',
        // Replace '0x1' with the chain ID of your desired network
        params: [{chainId: '0x1'}],
    });
    ```

    Lastly, initialize a viem Wallet Client from the EIP-1193 provider:

    ```ts
    const walletClient = createWalletClient({
        // Replace this with your desired network that you imported from viem
        chain: mainnet,
        transport: custom(provider),
    });
    ```

    You can now use methods implemented by viem's [Wallet Client](https://viem.sh/docs/clients/wallet.html), including [`signMessage`](https://viem.sh/docs/actions/wallet/signMessage.html#signmessage), [`signTypedData`](https://viem.sh/docs/actions/wallet/signTypedData.html#signtypeddata), and [`sendTransaction`](https://viem.sh/docs/actions/wallet/sendTransaction.html#sendtransaction)!

    ### Integrating with `ethers`

    First, import `ethers`:

    ```ts
    import {ethers} from 'ethers';
    ```

    Next, get an EIP-1193 provider for the user's embedded wallet, and switch its network to your desired network:

    ```ts
    await provider.request({
        method: 'wallet_switchEthereumChain',
        // Replace '0x1' with the chain ID of your desired network
        params: [{chainId: '0x1'}],
    });
    ```

    Lastly, initialize an ethers provider and signer from this EIP-1193 provider:

    ```ts
    const ethersProvider = new ethers.providers.Web3Provider(provider);
    const ethersSigner = ethersProvider.getSigner();
    ```

    You can then use methods implemented by ethers' [providers](https://docs.ethers.org/v5/api/providers/) and [signers](https://docs.ethers.org/v5/api/signer/), including [`signMessage`](https://docs.ethers.org/v5/api/signer/#Signer-signMessage) and [`sendTransaction`](https://docs.ethers.org/v5/api/signer/#Signer-sendTransaction).

    ### Integrating with `web3.js`

    First, import `web3`:

    ```ts
    import {Web3} from 'web3';
    ```

    Next, get an EIP-1193 provider for the user's embedded wallet, and switch its network to your desired network:

    ```ts
    await wallet.provider.request({
        method: 'wallet_switchEthereumChain',
        // Replace '0x1' with the chain ID of your desired network
        params: [{chainId: '0x1'}],
    });
    ```

    Lastly, initialize an ethers provider and signer from this EIP-1193 provider:

    ```ts
    const web3 = new Web3(wallet.getEthereumProvider());
    ```

    You can then use interfaces by web3.js for [signing messages](https://docs.web3js.org/guides/wallet/signing), [sending transactions](https://docs.web3js.org/guides/wallet/transactions), and [more](https://docs.web3js.org/guides/web3_eth/eth).
  </Tab>

  <Tab title="NodeJS">
    ### Viem

    [`viem`](https://viem.sh/docs/accounts/local.html) is a popular TypeScript library on EVM for executing onchain actions with wallets. Privy's server wallets on EVM natively integrate with `viem`, allowing you to use the library's interfaces for signing messages, signing typed data, sending transactions, and more.

    To integrate with `viem`, first install version `2^` of the library as a peer dependency:

    ```sh
    npm i viem@latest
    ```

    Then, use Privy's `createViemAccount` method to initialize an instance of a viem [`Account`](https://viem.sh/docs/accounts/local) for an EVM server wallet. As a parameter to this method, pass an object with the following:

    | Field      | Type          | Description                                |
    | ---------- | ------------- | ------------------------------------------ |
    | `walletId` | `string`      | ID of the wallet.                          |
    | `address`  | `0x${string}` | Ethereum address of the wallet.            |
    | `privy`    | `PrivyClient` | Instance of the Privy client for your app. |

    As an example, you can initialize an `Account` like so:

    ```tsx
    import {PrivyClient} from '@privy-io/server-auth';
    import {createViemAccount} from '@privy-io/server-auth/viem';

    // Initialize your Privy client
    const privy = new PrivyClient(...);
    // Create a viem account instance for a wallet
    const account = await createViemAccount({
        walletId: 'insert-wallet-id',
        address: 'insert-address',
        privy
    });
    ```

    From the returned `Account`, you can then initialize a viem [`WalletClient`](https://viem.sh/docs/clients/wallet) to sign messages and execute transactions with the wallet like so:

    ```tsx
    import {createWalletClient, http, parseEther} from 'viem';
    import {base} from 'viem/chains';

    const client = createWalletClient({
        account, // `Account` instance from above
        chain: base, // Replace with your desired network
        transport: http()
    });

    const hash = await client.sendTransaction({
        to: '0x59D3eB21Dd06A211C89d1caBE252676e2F3F2218',
        value: parseEther('0.001')
    });
    ```
  </Tab>
</Tabs>


# Smart wallets
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/overview



Privy makes it easy to create **smart wallets** for your users. Smart wallets are **programmable, onchain accounts** that incorporate the features of [account abstraction](https://ethereum.org/en/roadmap/account-abstraction/). With just a few lines of code, you can create smart wallets for your users to sponsor gas payments, send batched transactions, and more.

<Info>
  Please note that this native smart wallet integration is only available in the client-side SDKs.
  To configure smart wallets with wallets created from your server, follow [this
  guide](/wallets/gas-and-asset-management/gas/ethereum).
</Info>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/smart-wallets-splash.png" alt="Sample enable smart wallets" />

To set up with smart wallets, start by [enabling smart wallets in the Privy Dashboard](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard). This will configure your app to create smart wallets for your users controlled by Privy embedded signers.

<Info>
  Privy's smart wallets only support EVM-compatible networks. For Solana, we recommend using
  [transaction instructions](https://solana.com/docs/core/transactions) for batching actions or a
  [fee
  payer](https://www.circle.com/blog/how-circles-gas-station-uses-fee-payers-to-enable-gasless-transactions-on-solana#:~:text=What%20is%20a%20fee%20payer,like%20SOL%20for%20transaction%20fees.)
  for sponsoring gas fees.
</Info>

### Native ERC-4337 support with embedded signers

Under the hood, a smart wallet is an [ERC-4337](https://www.erc4337.io/)-compatible smart contract deployed onchain. This smart contract can be programmed to support features like transaction batching, gas sponsorship, delegating permissions, and more.

When using a smart wallet, a user's assets are held by the smart contract itself. This smart contract is controlled by an **embedded signer** (an externally-owned account) secured by Privy's self-custodial wallet infrastructure. Privy automatically takes care of creating signers for users and generating smart contract wallets controlled by these signers.

Your app can customize which ERC-4337 account *implementation* powers your users' smart wallets, between Kernel (ZeroDev), Safe, LightAccount (Alchemy), Biconomy, Thirdweb, and the Coinbase Smart Wallet.

<Info>
  Privy partners with the ERC-4337 account providers above to ensure a smooth experience. If you'd
  like us to add support for another, please [reach out](https://privy.io/slack)!
</Info>

### Gas sponsorship with paymasters

With smart wallets, your app can pay for gas fees simply by registering a paymaster URL in the Privy Dashboard. Privy will automatically route gas payments from your registered paymaster instead of your users' wallets, allowing your users to transact on-chain *instantly* –– even if they don't have a balance in their smart wallet.

### Future-proofed for the latest standards

Privy works closely with the teams building the next generation of account abstraction standards on top of ERC-4337, such as permissions & session keys ([ERC-7715](https://ethereum-magicians.org/t/erc-7715-grant-permissions-from-wallets/20100)), smart wallet modules ([ERC-7579](https://erc7579.com/)), and smart account discovery ([ERC-7555](https://ethereum-magicians.org/t/erc-7555-single-sign-on-for-account-discovery/16536)) across different applications. As these standards become ratified, Privy will incorporate native support for these features.


# Configure smart wallets in the dashboard
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard



To get started with smart wallets, navigate to the [**Smart wallets**](https://dashboard.privy.io/apps?page=smart-wallets) tab under the **Wallet Infrastructure** section on the [Privy Dashboard](https://dashboard.privy.io/apps?page=embedded\&tab=smart-wallets) to configure your setups.

## 1. Enable smart wallets

First, enable the smart wallets toggle and select a smart wallet type. Privy currently supports [Kernel](https://zerodev.app/), [Biconomy](https://www.biconomy.io/smart-accounts), [Light Account](https://www.alchemy.com/account-contracts), [Safe](https://safe.global/), [Thirdweb](https://thirdweb.com/contracts) and the [Coinbase Smart Wallet](https://github.com/coinbase/smart-wallet) as smart wallet types.

<Frame>![Sample enable smart wallets](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/enable-smart-wallets.png)</Frame>

<Info>
  If you modify your smart wallet type after users have already created smart wallets, Privy will
  provision the original smart wallet type for existing users to ensure they can access the accounts
  they already use.
</Info>

## 2. Configure the supported networks

Next, configure the networks for your smart wallets. You should do this for *any* network that your app plans to use smart wallets on.

<Frame>![Sample enable smart wallets](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/configure-network.png)</Frame>

For each configured network, you can optionally provide a bundler URL and/or a paymaster URL.

#### Bundler

The **bundler URL** specifies the node you want to use bundle operations from multiple users into a single transaction. If a bundler URL is not set for a network, Privy defaults to Pimlico's public bundler (`https://public.pimlico.io/v2/{chainId}/rpc`).

<Tip>
  **We strongly recommend setting your own bundler URL when taking smart wallets to production**, to
  give you more control over bundler rate limits. Privy's default bundler is heavily rate limited
  and is not suitable for production usage.
</Tip>

#### Paymaster

The **paymaster URL** specifies the paymaster used to sponsor gas fees for the smart wallets on the network. If a paymaster URL is set, Privy will use that paymaster to sponsor gas fees for your users' transactions. If a paymaster URL is not set, your users' smart wallets must have a balance of the network's native currency to pay for gas fees for transactions.

For additional security, we strongly recommend setting **Allowed domains** for your paymaster and/or bundler through your provider's dashboard, to restrict usage of these URLs to only your website.

#### Recommended providers

If you are looking to set up a paymaster or bundler for your app, we suggest the following providers:

| Provider | Get started                                                                                                                      |
| -------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Pimlico  | [https://dashboard.pimlico.io](https://dashboard.pimlico.io)                                                                     |
| ZeroDev  | [https://dashboard.zerodev.app/](https://dashboard.zerodev.app/)                                                                 |
| Alchemy  | [https://dashboard.alchemy.com/](https://dashboard.alchemy.com/)                                                                 |
| Biconomy | [https://dashboard.biconomy.io/](https://dashboard.biconomy.io/)                                                                 |
| Thirdweb | [https://thirdweb.com](https://thirdweb.com)                                                                                     |
| Coinbase | [https://www.coinbase.com/developer-platform/products/paymaster](https://www.coinbase.com/developer-platform/products/paymaster) |

<Tip>
  If using **Alchemy** for your paymaster, please provide your Alchemy gas policy ID. Each gas
  policy ID is tied to a specific chain and Alchemy project.
</Tip>

<Tip>
  If using **Biconomy** as a paymaster with `@privy-io/react-auth`, you can override our default
  paymaster context in the `SmartAccountsProvider`. View more in [our setup
  notes](/wallets/using-wallets/evm-smart-wallets/usage).
</Tip>

#### Custom chains

If you do not see the chain you wish to configure on the drop down, you can configure a custom chain. Before configuring a custom chain on the Privy dashboard, please ensure the chain is supported by your smart wallet provider. Custom chain configuration requires an EIP155 chain ID, chain name, paymaster URL, bundler URL, and RPC URL; none of these values can be defaulted as they are in supported chains.


# Configure smart wallets in the SDK
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/setup/configuring-sdk



Once you have [configured](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard) smart wallets in the Privy Dashboard, you can use them in your application with just a few lines of code.

<Tabs>
  <Tab title="React">
    <Info>
      Looking to get started quickly? Check out our [Smart Wallets starter
      repo](https://github.com/privy-io/smart-wallets-starter)
    </Info>

    ## Setup

    First install the necessary peer dependencies:

    ```bash
    npm install permissionless viem
    ```

    To set up your app with smart wallets, first import the `SmartWalletsProvider` component from `@privy-io/react-auth/smart-wallets` and wrap your app with it.

    The `SmartWalletsProvider` must wrap any component or page that will use smart wallets. We recommend rendering it as close to the root of your application as possible, nested *within* your `PrivyProvider`.

    ```tsx
    import {PrivyProvider} from '@privy-io/react-auth';
    import {SmartWalletsProvider} from '@privy-io/react-auth/smart-wallets';

    export default function Providers({children}: {children: React.ReactNode}) {
      return (
        <PrivyProvider appId="your-privy-app-id">
          <SmartWalletsProvider>{children}</SmartWalletsProvider>
        </PrivyProvider>
      );
    }
    ```

    <Tip>
      Make sure that the networks you've configured for smart wallets in the Dashboard are also
      configured for your app's [`defaultChain` and
      `supportedChains`](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard).
    </Tip>

    ## Creating smart wallets

    Once the `SmartWalletsProvider` component is rendered and a smart wallet configuration has been set up for your app in the [Dashboard](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard), Privy will automatically generate smart wallets for your users once they have an embedded wallet. The embedded wallet is used as the primary **signer** controlling the smart wallet.

    You can configure your app to [create embedded wallets](/wallets/wallets/create/from-my-client) automatically on login or manually; smart wallets will be created following the same configuration.

    ## Overriding paymaster context

    Certain paymasters, like Alchemy and Biconomy, use an additional `paymasterContext` for gas sponsorship. Privy constructs this paymaster context based on either dashboard provided gas policy ID for Alchemy or a default set of values for Biconomy. However, you can override these defaults by passing a `paymasterContext` prop to the `SmartWalletsProvider`. See an example of how to set this below:

    ```tsx
    <SmartWalletsProvider
      config={{
        paymasterContext: {
          mode: 'SPONSORED',
          calculateGasLimits: true,
          expiryDuration: 300,
          sponsorshipInfo: {
            webhookData: {},
            smartAccountInfo: {
              name: 'BICONOMY',
              version: '2.0.0'
            }
          }
        }
      }}
    >
      {children}
    </SmartWalletsProvider>
    ```
  </Tab>

  <Tab title="React Native">
    ## Setup

    ### 1. Set up your build configuration

    Ensure you've followed the steps in [custom build configuration](/basics/react-native/advanced/custom-build-configuration).

    Additionally, add `permissionless` to the list of modules that require package exports in your `metro.config.js` file.

    ```ts
    //...other config logic

    // Enable package exports for select libraries
    ...
    const resolveRequestWithPackageExports = (context, moduleName, platform) => {
      if (moduleName.startsWith('@privy-io/') || moduleName.startsWith('permissionless')) {
        const ctx = {
          ...context,
          unstable_enablePackageExports: true,
        };
        return ctx.resolveRequest(ctx, moduleName, platform);
      }

      return context.resolveRequest(context, moduleName, platform);
    };
    ```

    ### 2. Install peer dependencies

    ```sh
    npx expo install viem permissionless
    ```

    ### 3. Import and wrap your app with the `SmartWalletsProvider`

    The `SmartWalletsProvider` must wrap any component or page that will use smart wallets. We recommend rendering it as close to the root of your application as possible, nested *within* your `PrivyProvider`.

    ```tsx
    import {PrivyProvider} from '@privy-io/expo';
    import {SmartWalletsProvider} from '@privy-io/expo/smart-wallets';

    export default function Providers({children}: {children: React.ReactNode}) {
      return (
        <PrivyProvider
          appId={Constants.expoConfig?.extra?.privyAppId}
          clientId={Constants.expoConfig?.extra?.privyAppClientId}
        >
          <SmartWalletsProvider>{children}</SmartWalletsProvider>
        </PrivyProvider>
      );
    }
    ```

    ## Creating smart wallets

    Once the `SmartWalletsProvider` component is rendered and a smart wallet configuration has been set up for your app in the [Dashboard](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard), Privy will automatically generate smart wallets for your users once they have an embedded wallet. The embedded wallet is used as the primary **signer** controlling the smart wallet.

    You can configure your app to [create embedded wallets](/wallets/wallets/create/from-my-client) manually; smart wallets will be created following the same configuration.
  </Tab>
</Tabs>


# Using smart wallets
Source: https://docs.privy.io/wallets/using-wallets/evm-smart-wallets/usage



<Tabs>
  <Tab title="React">
    <Tip>
      Follow the [smart wallets setup guide](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard) to configure smart wallets for your application.
    </Tip>

    ## Get the smart wallet address

    Once a smart wallet has been created for a user, you can get the address for the smart wallet by finding the account of `type: 'smart_wallet'` from the user's `linkedAccounts` array.

    ```jsx
    const {user} = usePrivy();
    const smartWallet = user.linkedAccounts.find((account) => account.type === 'smart_wallet');
    console.log(smartWallet.address);
    // Logs the smart wallet's address
    console.log(smartWallet.type);
    // Logs the smart wallet type (e.g. 'safe', 'kernel', 'light_account', 'biconomy', 'thirdweb', 'coinbase_smart_wallet')
    ```

    ## Sign a message

    Use the `signMessage` function from the `client` returned by `useSmartWallets` hook in your React component to sign a message using the user's smart wallet.

    ```jsx
    signMessage: (input: {message: SignableMessage}, opts?: {uiOptions?: SignMessageModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    const uiOptions = {
        title: 'Sample title text',
        description: 'Sample description text',
        buttonText: 'Sample button text'
    };
    client.signMessage({message: 'Hello, world!'}, {uiOptions}).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signMessage` method accepts the following parameters:

    <ParamField path="input.message" type="string | {raw: Hex | ByteArray}" required>
      The message to sign by the smart account.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SignMessageModalUIOptions">
      Optional UI customization options for the signature prompt.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Sign typed data

    Use the `signTypedData` function from the `client` returned by `useSmartWallets` hook in your React component to sign structured data using the user's smart wallet.

    ```jsx
    signTypedData: (input: SignTypedDataParameters, opts?: {uiOptions?: SignMessageModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    const uiOptions = {
        title: 'Sample title text',
        description: 'Sample description text',
        buttonText: 'Sample button text'
    };
    client.signTypedData(typedDataRequestParams, {uiOptions}).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signTypedData` method accepts the following parameters:

    <ParamField path="input" type="SignTypedDataParameters" required>
      The typed data to sign by the smart account.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SignMessageModalUIOptions">
      Optional UI customization options for the signature prompt.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Send a transaction

    Use the `sendTransaction` function from the `client` returned by `useSmartWallets` hook in your React component to send a transaction using the user's smart wallet.

    ```jsx
    sendTransaction: (input: SendTransactionParameters, opts?: {uiOptions?: SendTransactionModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    const uiOptions = {
        title: 'Sample title text',
        description: 'Sample description text',
        buttonText: 'Sample button text'
    };
    client.sendTransaction({
        chain: base,
        to: 'insert-recipient-address',
        value: 0.1
    }, {uiOptions}).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method accepts the following parameters:

    <ParamField path="input" type="SendTransactionParameters" required>
      The transaction to send by the smart account.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SendTransactionModalUIOptions">
      Optional UI customization options for the transaction prompt.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the sent transaction.
    </ResponseField>

    ## Batch transactions

    Smart wallets support sending a batch of transactions in a single, atomic submission to the network.

    ```jsx
    sendTransaction: (input: {calls: Array<{to: string, value?: bigint, data?: string}>}, opts?: {uiOptions?: SendTransactionModalUIOptions}) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/react-auth/smart-wallets';
    const {client} = useSmartWallets();
    client.sendTransaction({
        calls: [
            // Approve transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'approve',
                    args: ['insert-spender-address', BigInt(1e6)]
                })
            },
            // Transfer transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'transfer',
                    args: ['insert-recipient-address', BigInt(1e6)]
                })
            }
        ]
    }).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method for batching accepts the following parameters:

    <ParamField path="input.calls" type="Array<{to: string, value?: bigint, data?: string}>" required>
      Array of transactions to batch together.
    </ParamField>

    <ParamField path="opts.uiOptions" type="SendTransactionModalUIOptions">
      Optional UI customization options for the transaction prompt.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the batched transaction.
    </ResponseField>

    ## Switch chains

    Use the `getClientForChain` method to create a new smart wallet client for a specific chain.

    ```jsx
    getClientForChain: ({id: number}) => Promise<SmartWalletClient>
    ```

    ### Usage

    ```jsx
    import {base} from 'viem/chains';
    const {getClientForChain} = useSmartWallets();
    const baseClient = await getClientForChain({
        id: base.id,
    });
    // Client will send transaction on Base
    baseClient.sendTransaction({
        ...
    });
    ```

    ### Parameters

    The `getClientForChain` method accepts the following parameters:

    <ParamField path="id" type="number" required>
      The chain ID to create a client for.
    </ParamField>

    ### Returns

    <ResponseField name="client" type="SmartWalletClient">
      A new smart wallet client configured for the specified chain.
    </ResponseField>

    <Tip>
      If configured `defaultChain` does not have a smart wallet network configuration, the smart wallet client will default to using the first configured chain that has a smart wallet network configuration.
    </Tip>
  </Tab>

  <Tab title="React Native">
    <Tip>
      Follow the [React Native setup guide](/wallets/using-wallets/evm-smart-wallets/setup/configuring-dashboard) to configure smart wallets for your React Native application.
    </Tip>

    ## Get the smart wallet address

    Once a smart wallet has been created for a user, you can get the address for the smart wallet by finding the account of `type: 'smart_wallet'` from the user's `linked_accounts` array.

    ```jsx
    const {user} = usePrivy();
    const smartWallet = user.linked_accounts.find((account) => account.type === 'smart_wallet');
    console.log(smartWallet.address);
    // Logs the smart wallet's address
    console.log(smartWallet.type);
    // Logs the smart wallet type (e.g. 'safe', 'kernel', 'light_account', 'biconomy', 'thirdweb', 'coinbase_smart_wallet')
    ```

    ## Sign a message

    Use the `signMessage` function from the `client` returned by `useSmartWallets` hook in your React Native component to sign a message using the user's smart wallet.

    ```jsx
    signMessage: ({message: SignableMessage}) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.signMessage({message: 'Hello, world!'}).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signMessage` method accepts the following parameters:

    <ParamField path="input.message" type="string | {raw: Hex | ByteArray}" required>
      The message to sign by the smart account.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Sign typed data

    Use the `signTypedData` function from the `client` returned by `useSmartWallets` hook in your React Native component to sign structured data using the user's smart wallet.

    ```jsx
    signTypedData: (input: SignTypedDataParameters) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.signTypedData(...).then((signature) => {
        console.log(signature);
    });
    ```

    ### Parameters

    The `signTypedData` method accepts the following parameters:

    <ParamField path="input" type="SignTypedDataParameters" required>
      The typed data to sign by the smart account.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="Hex">
      The signed message by the smart wallet.
    </ResponseField>

    ## Send a transaction

    Use the `sendTransaction` function from the `client` returned by `useSmartWallets` hook in your React Native component to send a transaction using the user's smart wallet.

    ```jsx
    sendTransaction: (input: SendTransactionParameters) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.sendTransaction({
        account: client.account,
        chain: base,
        to: 'insert-recipient-address',
        value: 0.1
    }).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method accepts the following parameters:

    <ParamField path="input" type="SendTransactionParameters" required>
      The transaction to send by the smart account.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the sent transaction.
    </ResponseField>

    ## Batch transactions

    Smart wallets support sending a batch of transactions in a single, atomic submission to the network.

    ```jsx
    sendTransaction: (input: {calls: Array<{to: string, value?: bigint, data?: string}>}) => Promise<Hex>
    ```

    ### Usage

    ```jsx
    import {useSmartWallets} from '@privy-io/expo/smart-wallets';
    const {client} = useSmartWallets();
    client.sendTransaction({
        account: client.account,
        calls: [
            // Approve transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'approve',
                    args: ['insert-spender-address', BigInt(1e6)]
                })
            },
            // Transfer transaction
            {
                to: USDC_ADDRESS,
                data: encodeFunctionData({
                    abi: USDC_ABI,
                    functionName: 'transfer',
                    args: ['insert-recipient-address', BigInt(1e6)]
                })
            }
        ]
    }).then((txHash) => {
        console.log(txHash);
    });
    ```

    ### Parameters

    The `sendTransaction` method for batching accepts the following parameters:

    <ParamField path="input.calls" type="Array<{to: string, value?: bigint, data?: string}>" required>
      Array of transactions to batch together.
    </ParamField>

    ### Returns

    <ResponseField name="txHash" type="Hex">
      The transaction hash of the batched transaction.
    </ResponseField>

    <Tip>
      The smart wallet client will default to using the first configured chain that has a smart wallet network configuration.
    </Tip>
  </Tab>
</Tabs>


# Provisioning session signers
Source: https://docs.privy.io/wallets/using-wallets/session-signers/delegate-wallet



Wallets created through Privy can either be used directly from a user's device or from a server. To allow wallets created on user devices to be used from the server, follow the guide below.

<Tabs>
  <Tab title="React">
    To provision a session signer for a user's wallets, use the `delegateWallet` method from the `useHeadlessDelegatedActions` hook:

    ```tsx
    type delegateWallet = ({address: string, chainType: 'ethereum' | 'solana'}) => Promise<void>
    ```

    ### Usage

    ```tsx
    import {useHeadlessDelegatedActions} from '@privy-io/react-auth';
    const {delegateWallet} = useHeadlessDelegatedActions();
    ```

    ### Parameters

    The `delegateWallet` method accepts a `params` object with the following fields:

    <ParamField path="address" type="string">
      Address of the embedded wallet to delegate.
    </ParamField>

    <ParamField path="chainType" type="'ethereum' | 'solana'">
      Chain type of the embedded wallet to delegate.
    </ParamField>

    <Tip>
      In addition to a full whitelabel experience, Privy also offers a default UI component to prompt users to delegate their wallet and add a session signer. [Learn more](/wallets/using-wallets/session-signers/ui-component)
    </Tip>
  </Tab>

  <Tab title="React Native">
    To provision server-side access for a user's wallets, use the `delegateWallet` method from the `useHeadlessDelegatedActions` hook:

    ```tsx
    type delegateWallet: async ({address: string, chainType: 'ethereum' | 'solana'}) => Promise<void>
    ```

    ### Usage

    ```tsx
    import {useHeadlessDelegatedActions} from '@privy-io/expo';
    const {delegateWallet} = useHeadlessDelegatedActions();
    ```

    ### Parameters

    The `delegateWallet` method accepts a `params` object with the following fields:

    <ParamField path="address" type="string">
      Address of the embedded wallet to delegate.
    </ParamField>

    <ParamField path="chainType" type="'ethereum' | 'solana'">
      Chain type of the embedded wallet to delegate.
    </ParamField>
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/wallets/using-wallets/session-signers/index



{/* This page is the overview for the legacy embedded wallet docs, /overview is for the unified stack */}

Using session signers, users can allow your server to sign requests with their embedded wallet, enabling your app to take action on-chain without needing the user in the loop. This functionality allows your app to:

* Approve future onchain actions (i.e. setting a limit order or stop loss) for when the user is offline
* Automate certain onchain actions (i.e. sending a transaction when a certain condition is met)
* Reduce popups by signing transactions on the users behalf

Privy’s architecture guarantees that your server will never see the wallet's private key. All signing takes place in a secure enclave that only your application can make authorized requests to.

Follow the guides below to provision session signers for your users' wallets and enable your app to securely interact with these wallets from your servers.

## Get started

<CardGroup>
  <Card title="Add a session signer" icon="stamp" href="/wallets/using-wallets/session-signers/delegate-wallet">
    Add a session signer to a user's wallet and start interacting with the wallet from your servers.
  </Card>

  <Card title="Send transactions from your server" icon="gear" href="/wallets/using-wallets/session-signers/use-session-signers">
    Send transactions on behalf of your users from a server environment.
  </Card>
</CardGroup>


# Revoking session signers
Source: https://docs.privy.io/wallets/using-wallets/session-signers/revoke-wallets



Once a user has [provisioned a session signer](/wallets/using-wallets/session-signers/delegate-wallet), they may also revoke consent to prevent your app from taking any further wallet actions on their behalf.

<Tabs>
  <Tab title="React">
    To revoke all session signers on users wallets automatically, *without* a revocation screen, use the `revokeWallets` method from the `useHeadlessDelegatedActions` hook:

    ```tsx
    type revokeWallets: async () => Promise<void>
    ```

    ### Usage

    ```tsx
    import {useHeadlessDelegatedActions} from '@privy-io/react-auth';
    ...
    const {revokeWallets} = useHeadlessDelegatedActions();
    ```

    When invoked, the `revokeWallets` method will revoke all of the session signers provisioned on all of the user's wallets

    Once a user confirms revocation, your app will no longer be able to take actions on behalf of the user with their wallet unless the user [provisions a session signer](/wallets/using-wallets/session-signers/delegate-wallet).

    If a user has provisioned multiple session signers, they will **all** be revoked.

    As an example, you might have a button within your app to allow users to revoke session signer provisioned wallets like so:

    ```tsx Example Create Wallet Button
    import {usePrivy, useheadlessDelegatedActions, type WalletWithMetadata} from '@privy-io/react-auth';

    function RevokeDelegateActionButton() {
      const {user} = usePrivy();
      const {revokeWallets} = useHeadlessDelegatedActions();

      // Check if the user has any delegated wallets by searching the linkedAccounts array for wallets
      // with `delegated: true` set
      const hasDelegatedWallets =
        user.linkedAccounts.filter(
          (account): account is WalletWithMetadata => account.type === 'wallet' && account.delegated
        ).length !== 0;

      const onRevoke = async () => {
        if (!hasDelegatedWallets) return; // Button is disabled to prevent this case
        await revokeWallets();
      };

      return (
        <button disabled={!hasDelegatedWallets} onClick={onRevoke}>
          Revoke permission for this app to transact on my behalf
        </button>
      );
    }
    ```
  </Tab>

  <Tab title="React Native">
    To revoke all session signers on users wallets automatically, *without* a revocation screen, use the `revokeWallets` method from the `useHeadlessDelegatedActions` hook:

    ```tsx
    type revokeWallets: async () => Promise<void>
    ```

    ### Usage

    ```tsx
    import {useHeadlessDelegatedActions} from '@privy-io/expo';
    ...
    const {revokeWallets} = useHeadlessDelegatedActions();
    ```

    When invoked, the `revokeWallets` method will revoke all of the session signers on user's wallets.

    Once a user confirms revocation, your app will no longer be able to take actions on behalf of the user with their wallet unless the user [provisions a session signer](/wallets/using-wallets/session-signers/delegate-wallet).

    If a user has provisioned multiple session signers, they will **all** be revoked.

    As an example, you might have a button within your app to allow users to revoke all session signers on a user's wallets like so:

    ```tsx Example Create Wallet Button
    import {usePrivy, useHeadlessDelegatedActions, type WalletWithMetadata} from '@privy-io/expo';

    function RevokeDelegateActionButton() {
      const {user} = usePrivy();
      const {revokeWallets} = useHeadlessDelegatedActions();
      const wallets = getAllUserEmbeddedEthereumWallets(user); // or getAllUserEmbeddedSolanaWallets

      // Check if the user has any delegated wallets by searching the user's wallets for any with
      // `delegated: true` set.
      const hasDelegatedWallets = wallets.some((wallet) => wallet.delegated);

      const onRevoke = async () => {
        if (!hasDelegatedWallets) return; // Button is disabled to prevent this case
        await revokeWallets();
      };

      return (
        <button disabled={!hasDelegatedWallets} onClick={onRevoke}>
          Revoke permission for this app to transact on my behalf
        </button>
      );
    }
    ```
  </Tab>
</Tabs>


# Setup
Source: https://docs.privy.io/wallets/using-wallets/session-signers/setup



At a high-level, setting up session signers for your app involves three steps:

<Steps>
  <Step title="Enable session signers">
    Enable session signers within the Privy Dashboard to allow your app to request permission from
    users to transact on their behalf.
  </Step>

  <Step title="Generate an authorization key">
    (Optional, but strongly recommended) Within the Privy Dashboard, when enabling session signers,
    generate an authorization keypair to ensure that actions with user's wallets are only taken with
    requests signed by your app's servers.
  </Step>

  <Step title="Prompt users to grant consent">
    Within your client (web or native mobile app), prompt the user to provision a session signer for
    their wallet.
  </Step>
</Steps>

## Enable session signers

To enable session signers for your app, visit the [Privy Dashboard](https://dashboard.privy.io/apps?page=embedded\&tab=advanced) and navigate to the **User management > Authentication** page for your app.

Select the **Advanced** tab and toggle the **Server-side access** setting to enable session signers for your app.

## Generate an authorization key

Once you've enabled session signers, you can further secure your integration by generating an authorization key that is required to sign requests.

To generate an authorization key, under the toggle to enable session signers, enable the **Require signed requests** setting. A modal will appear with a **Signing key** to copy. Copy this value and save it securely in a secrets manager or similar.

With this setting enabled, all requests to transact on the users wallet must be signed with your **Signing key**. This ensures that Privy only ever executes requests sent by your server.

**Privy never sees this private key and cannot help you recover it.**

<Info>
  The **authorization key** is the private key of a P-256 keypair. Privy never sees the private key,
  and verifies signatures on your requests against the corresponding public key to ensure your
  server authorizes the action to take with a user's delegated wallet.
</Info>

## Configuring permissions

To configure permissions to control what kinds of actions your session signer can take on provisioned wallets, you can set up new policies for your session signing key in your Privy dashboard under **Wallet infrastructure > Policies**.

## Provisioning session signers

To use session signers, your user must first grant consent for your app to take certain actions on their behalf. To have users grant consent, follow the guides below depending on the client-side SDK(s) you integrate.


# UI Component
Source: https://docs.privy.io/wallets/using-wallets/session-signers/ui-component



Privy provides a UI component that you can use to prompt users to provision session signers for their wallets and revoke server-side access.

## Provision server-side access

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/wallets/server-sessions.png" alt="Session signers" />
</Frame>

<Tabs>
  <Tab title="React">
    To prompt users to delegate their wallets *with* a consent screen, use the `delegateWallet` method from the `useDelegatedActions` hook:

    ```tsx
    import {useDelegatedActions} from '@privy-io/react-auth';
    ...
    const {delegateWallet} = useDelegatedActions();
    ```

    ### Parameters

    <ParamField path="address" type="string" required>
      Address of the embedded wallet to delegate.
    </ParamField>

    <ParamField path="chainType" type="'ethereum' | 'solana'" required>
      Chain type of the embedded wallet to delegate.
    </ParamField>

    When invoked, the `delegateWallet` method will open a Privy modal where the user can either approve or reject the delegation.

    If the user approves, Privy will initiate the process to provision a session signer for the wallet. If the user refuses or there is another error during provisioning, this method will throw an error.

    ### Usage

    ```tsx
    import {
    usePrivy,
    useSolanaWallets,
    useDelegatedActions,
    type WalletWithMetadata,
    } from '@privy-io/react-auth';

    function DelegateActionButton() {
    const {user} = usePrivy();
    const {ready, wallets} = useSolanaWallets(); // or useWallets()
    const {delegateWallet} = useDelegatedActions();

    // Find the embedded wallet to delegate from the array of the user's wallets
    const walletToDelegate = wallets.find((wallet) => wallet.walletClientType === 'privy');

    // Check if the wallet to delegate by inspecting the user's linked accounts
    const isAlreadyDelegated = !!user.linkedAccounts.find(
        (account): account is WalletWithMetadata => account.type === 'wallet' && account.delegated,
    );

    const onDelegate = async () => {
        if (!walletToDelegate || !ready) return; // Button is disabled to prevent this case
        await delegateWallet({address: walletToDelegate.address, chainType: 'solana'}); // or chainType: 'ethereum'
    };

    return (
        <button disabled={!ready || !walletToDelegate || isAlreadyDelegated} onClick={onDelegate}>
        Delegate access
        </button>
    );
    }
    ```
  </Tab>

  <Tab title="React Native">
    To prompt users to provision a session signer for their wallets *with* a consent screen, use the `delegateWallet` method from the `useDelegatedActions` hook:

    ```tsx
    import {useDelegatedActions} from '@privy-io/expo/ui';
    ...
    const {delegateWallet} = useDelegatedActions();
    ```

    ### Parameters

    <ParamField path="address" type="string" required>
      Address of the embedded wallet to delegate.
    </ParamField>

    <ParamField path="chainType" type="'ethereum' | 'solana'" required>
      Chain type of the embedded wallet to provision a session signer for.
    </ParamField>

    When invoked, the `delegateWallet` method will open a Privy modal where the user can either approve or reject the provisioning of a session signer.

    If the user approves, Privy will initiate the process to provision a session signer for the wallet. If the user refuses or there is another error during provisioning, this method will throw an error.

    ### Usage

    ```tsx
    import {
    usePrivy,
    useEmbeddedEthereumWallet,
    getAllUserEmbeddedEthereumWallets,
    } from '@privy-io/expo';
    import {useDelegatedActions} from '@privy-io/expo/ui';

    function DelegateActionButton() {
    const {user, isReady} = usePrivy();
    const wallets = getAllUserEmbeddedEthereumWallets(user); // or getAllUserEmbeddedSolanaWallets
    const {delegateWallet} = useDelegatedActions();

    // Find the embedded wallet account to delegate
    const walletToDelegate = wallets.find((wallet) => wallet.wallet_index === 0);

    // Check if the wallet is already delegated
    const isAlreadyDelegated = walletToDelegate.delegated;

    const onDelegate = async () => {
        if (!walletToDelegate || !isReady) return; // Button is disabled to prevent this case
        await delegateWallet({address: walletToDelegate.address, chainType: 'ethereum'}); // or chainType: 'solana'
    };

    return (
        <button disabled={!isReady || !walletToDelegate || isAlreadyDelegated} onClick={onDelegate}>
        Delegate access
        </button>
    );
    }
    ```
  </Tab>
</Tabs>

***

## Revoke server-side access

<Tabs>
  <Tab title="React">
    To prompt users to revoke a session signer with a revocation screen, use the `revokeWallets` method from the `useDelegatedActions` hook:

    ```tsx
    import {useDelegatedActions} from '@privy-io/react-auth';
    ...
    const {revokeWallets} = useDelegatedActions();
    ```

    When invoked, the `revokeWallets` method will open a Privy modal where the user can either confirm the revocation of their session signer. If the user has no session signers, this method will error.

    Once a user confirms revocation, your app will no longer be able to take actions on behalf of the user with their wallet unless the user [provisions a session signer](/wallets/using-wallets/session-signers/delegate-wallet).

    If a user has provisioned multiple session signers, they will **all** be revoked.

    ### Usage

    ```tsx
    import {usePrivy, useDelegatedActions, type WalletWithMetadata} from '@privy-io/react-auth';

    function RevokeDelegateActionButton() {
      const {user} = usePrivy();
      const {revokeWallets} = useDelegatedActions();

      // Check if the user has any delegated wallets by searching the linkedAccounts array for wallets
      // with `delegated: true` set
      const hasDelegatedWallets =
        user.linkedAccounts.filter(
          (account): account is WalletWithMetadata => account.type === 'wallet' && account.delegated
        ).length !== 0;

      const onRevoke = async () => {
        if (!hasDelegatedWallets) return; // Button is disabled to prevent this case
        await revokeWallets();
      };

      return (
        <button disabled={!hasDelegatedWallets} onClick={onRevoke}>
          Revoke permission for this app to transact on my behalf
        </button>
      );
    }
    ```
  </Tab>

  <Tab title="React Native">
    To prompt users to revoke a session signer with a revocation screen, use the `revokeWallets` method from the `useDelegatedActions` hook:

    ```tsx
    import {useDelegatedActions} from '@privy-io/expo/ui';
    ...
    const {revokeWallets} = useDelegatedActions();
    ```

    When invoked, the `revokeWallets` method will open a Privy modal where the user can either confirm the revocation of their session signer. If the user has no session signers, this method will error.

    Once a user confirms revocation, your app will no longer be able to take actions on behalf of the user with their wallet unless the user [provisions a session signer](/wallets/using-wallets/session-signers/delegate-wallet).

    If a user has provisioned multiple session signers, they will **all** be revoked.

    ### Usage

    ```tsx
    import {usePrivy, getAllUserEmbeddedEthereumWallets} from '@privy-io/expo';
    import {useDelegatedActions} from '@privy-io/expo/ui';

    function RevokeDelegateActionButton() {
    const {user} = usePrivy();
    const {revokeWallets} = useDelegatedActions();
    const wallets = getAllUserEmbeddedEthereumWallets(user); // or getAllUserEmbeddedSolanaWallets

    // Check if the user has any delegated wallets by searching the user's wallets for any with
    // `delegated: true` set.
    const hasDelegatedWallets = wallets.some((wallet) => wallet.delegated);

    const onRevoke = async () => {
        if (!hasDelegatedWallets) return; // Button is disabled to prevent this case
        await revokeWallets();
    };

    return (
        <button disabled={!hasDelegatedWallets} onClick={onRevoke}>
            Revoke permission for this app to transact on my behalf
        </button>
    );
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/session-signers/use-session-signers



Once your user's have session signers on their wallets, your app can take actions on their behalf. This is done by sending requests to the Privy API to sign transactions with the user's wallet. Follow the guide below to get started with signing transactions on behalf of users.

## Requesting signatures

Wallets provisioned for session signers can be used to transact and sign messages on behalf of a user from your server.

To get started, configure the [NodeJS SDK](/basics/nodeJS/setup) or the [REST API](/basics/rest-api/setup). This is how your application will make requests to the Privy API to sign transactions on behalf of users. The signing key you configured in the dashboard is the authorization signing key used to produce authorization signatures when submitting requests.

Once you have configured the NodeJS SDK or REST API, your application can send both [Ethereum](/wallets/using-wallets/ethereum/send-a-transaction) and [Solana](/wallets/using-wallets/solana/send-a-transaction) transactions from a users wallet. Follow the NodeJS or REST API guides in the `Using wallets` section to learn more about signing requests with wallets.

## Getting wallets

From your server, you can query Privy to determine what wallets have been provisioned session signers by a given user to allow your app to take actions on their behalf.

<Tabs>
  <Tab title="NodeJS">
    Use the Privy client's `getUser` method to get the user object for your user. As a parameter to this method, pass the user's DID as a `string`:

    ```tsx
    const user = await client.getUser({identityToken});
    ```

    To get a list of the user's wallets with session signers, first find all of the user's embedded wallets from the user's linked accounts. Filter the `user.linkedAccounts` array for wallet entries with `type: 'wallet'` and `delegated: true`:

    ```tsx
    // The `WalletWithMetadata` type can be imported from '@privy-io/server-auth'
    const walletsWithSessionSigners = user.linkedAccounts.filter(
      (account): account is WalletWithMetadata =>
        account.type === 'wallet' && account.delegated === true
    );
    ```

    This constitutes the user's wallets with session signers. Wallets with session signers will always have the `delegated` flag set to `true`.

    For wallets included in this array, your app may make requests to Privy to execute actions on [Solana](/wallets/using-wallets/solana/sign-a-message) or [EVM networks](/wallets/using-wallets/ethereum/sign-a-message) on behalf of the user.
  </Tab>

  <Tab title="REST API">
    Make a `GET` request to:

    ```bash
    https://auth.privy.io/api/v1/users/<user-did>
    ```

    Replace `<did>` with your desired Privy DID. It should have the format `did:privy:XXXXXX`.

    Below is a sample cURL command for this request:

    ```bash
    curl --request GET https://auth.privy.io/api/v1/users/<user-did> \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>"
    ```

    Then, to get a list of the user's delegated wallets, inspect the `linked_accounts` field of the response body for all entries with the fields `type: 'wallet'` and `delegated: true`.
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/solana/send-a-transaction



<Tip>
  To sponsor gas fees for transactions on Solana, see our guide [here](/wallets/gas-and-asset-management/gas/solana).
</Tip>

<Tabs>
  <Tab title="React">
    To send a transaction from a wallet using the React SDK, use the `sendTransaction` method from the `useSendTransaction` hook:

    ```javascript
    sendTransaction: (input: {
      transaction: SupportedSolanaTransaction;
      connection: Connection;
      uiOptions?: SendTransactionModalUIOptions;
      transactionOptions?: SendTransactionOptions;
      fundWalletConfig?: SolanaFundingConfig;
      address?: string;
    }) => Promise<SolanaTransactionReceipt>
    ```

    ### Usage

    ```javascript
    import {useSendTransaction} from '@privy-io/react-auth/solana';
    import {Connection, Transaction, VersionedTransaction} from '@solana/web3.js';

    // Inside your component
    const { sendTransaction } = useSendTransaction();

    // Configure your connection to point to the correct Solana network
    const connection = new Connection('https://api.mainnet-beta.solana.com');

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    const transaction = new Transaction(); // or new VersionedTransaction()
    // Add your instructions to the transaction...

    // Send the transaction
    const receipt = await sendTransaction({
        transaction: transaction,
        connection: connection
    });

    console.log("Transaction sent with signature:", receipt.signature);
    ```

    ### Parameters

    <ParamField path="transaction" type="SupportedSolanaTransaction" required>
      The transaction to be sent. Can be either a legacy Transaction or VersionedTransaction from [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html).
    </ParamField>

    <ParamField path="connection" type="Connection" required>
      Connection to an SVM (Solana) network.
    </ParamField>

    <ParamField path="uiOptions" type="SendTransactionModalUIOptions">
      UI options to customize the transaction request modal.
    </ParamField>

    <ParamField path="transactionOptions" type="SendTransactionOptions">
      Transaction options to customize the transaction request.
    </ParamField>

    <ParamField path="fundWalletConfig" type="SolanaFundingConfig">
      Funding configuration to specify cluster and funding amount (if enabled), in the case of insufficient funds.
    </ParamField>

    <ParamField path="address" type="string">
      Address for the embedded wallet sending the transaction. Defaults to the user's embedded wallet at HD index 0.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature of the transaction.
    </ResponseField>

    <ResponseField name="signedTransaction" type="SupportedSolanaTransaction">
      The signed transaction.
    </ResponseField>

    <ResponseField name="parsedTransaction" type="ParsedTransactionWithMeta | null">
      The parsed transaction result.
    </ResponseField>

    <ResponseField name="fees" type="bigint">
      The fees paid for the transaction in lamports.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To send a transaction from a wallet using the React Native SDK, use the `request` method from the wallet's provider:

    ```javascript
    request: (request: {
      method: 'signAndSendTransaction',
      params: {
        transaction: Transaction | VersionedTransaction,
        connection: Connection
      }
    }) => Promise<{ signature: string }>
    ```

    ### Usage

    ```javascript
    import {Connection} from '@solana/web3.js';
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const { wallets } = useEmbeddedSolanaWallet();
    const wallet = wallets[0];

    // Get the provider
    const provider = await wallet.getProvider();

    // Create a connection to the Solana network
    const connection = new Connection('insert-your-rpc-url-here');

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    // transaction = ...

    // Send the transaction
    const { signature } = await provider.request({
      method: 'signAndSendTransaction',
      params: {
        transaction: transaction,
        connection: connection,
      },
    });

    console.log("Transaction sent with signature:", signature);
    ```

    ### Parameters

    <ParamField path="method" type="'signAndSendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the transaction.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
          The transaction to sign and send. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html).
        </ParamField>

        <ParamField path="connection" type="Connection" required>
          Connection to an SVM (Solana) network.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature of the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Sending a Solana transaction involves building the transaction, signing it, and then submitting it to the network.

    ```swift
    public protocol EmbeddedSolanaWalletProvider {
        func signMessage(message: String) async throws -> String
    }
    ```

    ### Usage

    ```swift
    import SolanaSwift

    // Get the provider for wallet (assumes wallet is already obtained)
    let provider = wallet.provider

    // Create a Solana RPC client
    let solana = JSONRPCAPIClient(endpoint: URL(string: "https://api.mainnet-beta.solana.com")!)

    // Build the transaction using your preferred method
    let latestBlockhash = try await solana.getLatestBlockhash()
    let walletPK = try PublicKey(string: wallet.address)
    var tx = Transaction()
    tx.instructions.append(
        SystemProgram.transferInstruction(
            from: walletPK,
            to: try PublicKey(string: "9NvE68JVWHHHGLp5NNELtM5fiBw6SXHrzqQJjUqaykC1"),
            lamports: 100000000000000
        )
    )
    tx.recentBlockhash = latestBlockhash
    tx.feePayer = walletPK

    // Serialize the transaction for signing as base64
    let message = try tx.compileMessage().serialize().base64EncodedString()

    // Sign using the Privy Embedded Wallet
    let signature = try await provider.signMessage(message: message)

    // Add the signature back to the transaction
    try tx.addSignature(signature: Data(base64Encoded: signature)!, publicKey: walletPK)

    // Send the transaction via a JSON-RPC call
    let txHash = try await solana.sendTransaction(transaction: tx.serialize().base64EncodedString())

    print("Transaction sent with hash: \(txHash)")
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="String">
      The base64-encoded signature for the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```kotlin
    public suspend fun signMessage(message: String): Result<String>
    ```

    ### Usage

    ```kotlin
    // Retrieve user's Solana wallet (assumes wallet is already obtained)
    val solanaWallet = user.embeddedSolanaWallets.first()

    // Create a Solana RPC client
    val connection = Connection("https://api.mainnet-beta.solana.com")

    // Build the transaction
    val walletPublicKey = PublicKey(solanaWallet.address)
    val instruction = SystemProgram.transfer(
        fromPubkey = walletPublicKey,
        toPubkey = PublicKey(recipientAddress),
        lamports = amount
    )

    // Get recent blockhash
    val recentBlockhash = connection.getLatestBlockhash()

    // Create transaction
    val transaction = Transaction()
    transaction.add(instruction)
    transaction.recentBlockhash = recentBlockhash
    transaction.feePayer = walletPublicKey

    // Serialize transaction to base64
    val serializedTransaction = transaction.serializeMessage().base64()

    // Sign the transaction message
    val result = solanaWallet.provider.signMessage(serializedTransaction)

    when (result) {
        is Result.Success -> {
            // Add signature to transaction
            val signature = result.data
            transaction.addSignature(walletPublicKey, Base64.decode(signature))

            // Send the transaction
            val txHash = connection.sendRawTransaction(transaction.serialize())
            // Handle successful transaction
        }
        is Result.Failure -> {
            // Handle error
        }
    }
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```dart
    Future<Result<String>> signMessage(String message);
    ```

    ### Usage

    ```dart
    // Retrieve the user's Solana wallet (assumes wallet is already obtained)
    final solanaWallet = user.embeddedSolanaWallets.first;

    // Create a Solana RPC client
    final connection = Connection('https://api.mainnet-beta.solana.com');

    // Build the transaction
    final walletPublicKey = PublicKey(solanaWallet.address);
    final instruction = SystemProgram.transfer(
        fromPubkey: walletPublicKey,
        toPubkey: PublicKey(recipientAddress),
        lamports: amount
    );

    // Get recent blockhash
    final recentBlockhash = await connection.getLatestBlockhash();

    // Create transaction
    final transaction = Transaction();
    transaction.add(instruction);
    transaction.recentBlockhash = recentBlockhash;
    transaction.feePayer = walletPublicKey;

    // Serialize transaction to base64
    final serializedTransaction = base64Encode(transaction.serializeMessage());

    // Sign the transaction message
    final result = await solanaWallet.provider.signMessage(serializedTransaction);

    // Handle the result
    result.when(
        success: (signature) {
            // Add signature to transaction
            transaction.addSignature(walletPublicKey, base64Decode(signature));

            // Send the transaction
            connection.sendRawTransaction(transaction.serialize())
              .then((txHash) {
                print('Transaction sent with hash: $txHash');
              });
        },
        failure: (error) {
            print('Failed to sign transaction: $error');
        },
    );
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signAndSendTransaction` method on the Solana client to send a transaction with a Solana wallet.

    ```js
    signAndSendTransaction: (input: SolanaSignAndSendTransactionInputType) => Promise<SolanaSignAndSendTransactionResponseType>
    ```

    ### Usage

    ```js
    import {
      PublicKey,
      SystemProgram,
      VersionedTransaction,
      TransactionMessage,
    } from '@solana/web3.js';

    const walletPublicKey = new PublicKey(wallet.address);
    const instruction = SystemProgram.transfer({
      fromPubkey: walletPublicKey,
      toPubkey: new PublicKey(recipientAddress),
      lamports: amount,
    });

    const message = new TransactionMessage({
      payerKey: walletPublicKey,
      instructions: [instruction],
      recentBlockhash,
    });

    const transaction = new VersionedTransaction(message.compileToV0Message());

    const {hash} = await privy.walletApi.solana.signAndSendTransaction({
      walletId: 'insert-wallet-id',
      caip2: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1', // Mainnet
      transaction: transaction,
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to send the transaction from.
    </ParamField>

    <ParamField path="caip2" type="string" required>
      The CAIP2 chain ID of the chain the transaction is being sent on.
    </ParamField>

    <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
      The transaction to sign and send. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html).
    </ParamField>

    ### Returns

    <ResponseField name="hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="caip2" type="string">
      The CAIP2 chain ID of the chain the transaction was sent on.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To send a transaction make a POST request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
        "method": "signAndSendTransaction",
        "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
        "params": {
            "transaction": "insert-base-64-encoded-serialized-transaction",
            "encoding": "base64"
        }
    }'
    ```

    A successful response will look like the following:

    ```json
    {
        "method": "signAndSendTransaction",
        "data": {
            "hash": "insert-transaction-hash",
            "caip2": "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
        }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'signAndSendTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="caip2" type="string" required>
      The CAIP2 chain ID to broadcast the transaction on.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="transaction" type="string" required>
          An encoded string serializing the transaction to be signed with the wallet.
        </ParamField>

        <ParamField path="encoding" type="'base64'" required>
          The encoding format for `params.transaction`. Currently, only `'base64'` is supported.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'signAndSendTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.hash" type="string">
      The hash for the broadcasted transaction.
    </ResponseField>

    <ResponseField name="data.caip2" type="string">
      The CAIP2 chain ID the transaction was submitted on.
    </ResponseField>
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/solana/sign-a-message



<Tabs>
  <Tab title="React">
    Use the `signMessage` method exported from the `useSolanaWallets` hook to sign a message with an Solana wallet.

    ```tsx
    signMessage: (message: Uint8Array) => Promise<Uint8Array>;
    ```

    ### Usage

    ```tsx
    import {useSolanaWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useSolanaWallets();

    const message = 'Hello world';
    const {signature} = await wallets[0].signMessage(new TextEncoder().encode(message));
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      Message to be signed.
    </ParamField>

    ### Response

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    Request a message signature on the wallets Ethereum provider.

    ```tsx
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const wallet = useEmbeddedSolanaWallet();
    const provider = await wallet.getProvider();

    const message = 'Hello world';
    const {signature} = await provider.request({
      method: 'signMessage',
      params: {message}
    });
    ```

    ### Parameters

    <ParamField path="method" type="'signMessage'" required>
      The method for the wallet request. For signing messages, this is `'signMessage'`.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The string to sign with the wallet. If the message is a string, you should pass the string as
          the message directly. If the message is an array of bytes (Uint8Array), you should
          base64-encode the array as a string before passing it to message.
        </ParamField>

        <ParamField path="address" type="string">
          The address of the wallet to sign the message with.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Request a message signature on the wallet's Solana provider.

    ```swift
    guard let user = privy.user else {
        // If user is null, user is not authenticated
        return
    }

    // Retrieve list of user's embedded Solana wallets
    let solanaWallets = user.embeddedSolanaWallets

    // Grab the desired wallet. Here, we retrieve the first wallet
    guard let wallet = solanaWallets.first else {
        // No SOL wallets
        return
    }

    // Sign a Base64 encoded message
    let signature = try await wallet.provider.signMessage(message: "SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")

    print("Result signature: \(signature)")
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The message to sign, as a base64-encoded string.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `signMessage` method on the Solana wallet provider to sign a message with the wallet.

    ```kotlin
    // Get current auth state
    val user = privy.user

    // check if user is authenticated
    if (user != null) {
        // Retrieve list of user's Solana wallet
        val solanaWallet = user.embeddedSolanaWallets.first()

        if (solanaWallet != null) {
            // Sign a message
            val result = solanaWallet.provider.signMessage("SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")
        }
    }
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The message to sign, as a base64-encoded string.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Unity">
    ### Usage

    ```csharp
    try {
        IEmbeddedSolanaWallet embeddedWallet = PrivyManager.Instance.User.EmbeddedSolanaWallets[0];
        IEmbeddedSolanaWalletProvider provider = embeddedWallet.EmbeddedSolanaWalletProvider;
        string signature = await provider.SignMessage("A message to sign");
        Debug.Log(signature);
    } catch (PrivyException.EmbeddedWalletException ex){
        Debug.LogError($"Could not sign message due to error: {ex.Error} {ex.Message}");
    } catch (Exception ex) {
        Debug.LogError($"Could not sign message exception {ex.Message}");
    }
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The base64 encoded bytes of the message or transaction to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The base64 encoded signature of the message, produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `signMessage` method on the Solana wallet provider to sign a message with the wallet.

    ```dart
    // Get the current user
    final user = privy.user;

    // Check if the user is authenticated
    if (user != null) {
      // Retrieve the user's Solana wallet
      final solanaWallet = user.embeddedSolanaWallets.first;

      if (solanaWallet != null) {
        // Sign a message
        final result = solanaWallet.provider.signMessage("SGVsbG8hIEkgYW0gdGhlIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLg==")
      }
    }
    ```

    ### Parameters

    <ParamField path="message" type="string" required>
      The message to sign, as a base64-encoded string.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature produced by the wallet.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signMessage` method on the ethereum client to sign a message with an Solana wallet.

    ```tsx
    signMessage: (message: string, options: {uiOptions: SignMessageModalUIOptions; address?: string}) =>
      Promise<{signature: string}>;
    ```

    ### Usage

    ```tsx
    const {signature, encoding} = await privy.walletApi.solana.signMessage({
      walletId: 'insert-wallet-id',
      message: 'Hello world'
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      Unique ID of the wallet to take actions with.
    </ParamField>

    <ParamField path="message" type="string | Uint8Array" required>
      The string or bytes to sign with the wallet.
    </ParamField>

    <ParamField path="idempotencyKey" type="string">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      An encoded string serializing the signature produced by the user's wallet.
    </ResponseField>

    <ResponseField name="encoding" type="'hex'">
      The encoding format for the returned `signature`. Currently, only `'base64'` is supported for
      Solana.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To sign a message make a POST request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Parameters

    <ParamField path="method" type="'signMessage'" required>
      RPC method to execute with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the RPC method to execute with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ParamField path="message" type="string" required>
          The message to sign with the wallet. If the message to sign is raw bytes, you must serialize
          the message as a base64 string.
        </ParamField>

        <ParamField path="encoding" type="'base64'" required>
          The encoding format for `message`. Currently, only `'base64'` is supported for Solana.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'signMessage'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data" type="Object">
      Outputs for the RPC method executed with the wallet.

      <Expandable title="properties" defaultOpen="true">
        <ResponseField name="signature" type="string">
          An encoded string serializing the signature produced by the user's wallet.
        </ResponseField>

        <ResponseField name="encoding" type="'base64'">
          The encoding format for the returned `signature`. Currently, only `'base64'` is supported for Solana.
        </ResponseField>
      </Expandable>
    </ResponseField>

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    -d '{
      "chain_type": "solana",
      "method": "signMessage",
      "params": {
        "message": "Hello, Solana.",
        "encoding": "base64"
      }
    }'
    ```
  </Tab>
</Tabs>


# null
Source: https://docs.privy.io/wallets/using-wallets/solana/sign-a-transaction



<Tip>
  To sponsor gas fees for transactions on Solana, see our guide [here](/wallets/gas-and-asset-management/gas/solana).
</Tip>

<Tabs>
  <Tab title="React">
    Use the `signTransaction` method exported from the `useSignTransaction` hook to sign a transaction with a Solana wallet.

    ```tsx
    signTransaction: (input: {
      transaction: SupportedSolanaTransaction;
      connection: Connection;
      uiOptions?: SendTransactionModalUIOptions;
      transactionOptions?: SendTransactionOptions;
      address?: string;
    }) => Promise<SupportedSolanaTransaction>;
    ```

    ### Usage

    ```tsx
    import {useSignTransaction} from '@privy-io/react-auth/solana';
    import {Connection, Transaction, VersionedTransaction} from '@solana/web3.js';

    // Inside your component
    const {signTransaction} = useSignTransaction();

    // Configure your connection to point to the correct Solana network
    const connection = new Connection('https://api.mainnet-beta.solana.com');

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    const transaction = new Transaction(); // or new VersionedTransaction()
    // Add your instructions to the transaction...

    // Sign the transaction
    const signedTransaction = await signTransaction({
      transaction: transaction,
      connection: connection
    });

    console.log('Transaction signed successfully');
    ```

    ### Parameters

    <ParamField path="transaction" type="SupportedSolanaTransaction" required>
      The transaction to be signed. Can be either a legacy Transaction or VersionedTransaction from
      [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html).
    </ParamField>

    <ParamField path="connection" type="Connection" required>
      Connection to an SVM (Solana) network.
    </ParamField>

    <ParamField path="uiOptions" type="SendTransactionModalUIOptions">
      UI options to customize the transaction request modal.
    </ParamField>

    <ParamField path="transactionOptions" type="SendTransactionOptions">
      Transaction options to customize the transaction request.
    </ParamField>

    <ParamField path="address" type="string">
      Address for the embedded wallet signing the transaction. Defaults to the user's embedded wallet at
      HD index 0.
    </ParamField>

    ### Response

    <ResponseField name="signedTransaction" type="SupportedSolanaTransaction">
      The signed transaction that can be sent to the network.
    </ResponseField>

    ## Sign all transactions

    Use the `signAllTransactions` method on a Solana wallet to sign all transactions in a batch.

    ```tsx
    signAllTransactions: (transactions: (Transaction | VersionedTransaction)[]) =>
      Promise<(Transaction | VersionedTransaction)[]>;
    ```

    <Info>This `signAllTransactions` method is only available with whitelabel UIs</Info>

    ### Usage

    ```tsx
    import {
      clusterApiUrl,
      Connection,
      PublicKey,
      getVersionedTransaction,
      getLegacyTransaction
    } from '@solana/web3.js';
    import {useSolanaWallets} from '@privy-io/react-auth/solana';

    const {wallets} = useSolanaWallets();
    const wallet = wallets[0];

    const connection = new Connection(clusterApiUrl('devnet'));
    const walletPublicKey = new PublicKey(wallet.address);

    const tx1 = await getVersionedTransaction({
      connection,
      from: walletPublicKey
    });
    const tx2 = await getLegacyTransaction({
      connection,
      from: walletPublicKey
    });

    const signedTxs = await wallet.signAllTransactions([tx1, tx2]);
    ```

    ### Parameters

    <ParamField path="transactions" type="(Transaction | VersionedTransaction)[]" required>
      The transactions to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signedTransactions" type="(Transaction | VersionedTransaction)[]">
      The array of signed transactions.
    </ResponseField>
  </Tab>

  <Tab title="React Native">
    To sign a transaction from a wallet using the React Native SDK, use the `request` method from the wallet's provider:

    ```javascript
    request: (request: {
      method: 'signTransaction',
      params: {
        transaction: Transaction | VersionedTransaction,
        connection: Connection
      }
    }) => Promise<{ signature: string }>
    ```

    ### Usage

    ```javascript
    import {Connection} from '@solana/web3.js';
    import {useEmbeddedSolanaWallet} from '@privy-io/expo';

    const { wallets } = useEmbeddedSolanaWallet();
    const wallet = wallets[0];

    // Get the provider
    const provider = await wallet.getProvider();

    // Create a connection to the Solana network
    const connection = new Connection('insert-your-rpc-url-here');

    // Create your transaction (either legacy Transaction or VersionedTransaction)
    // transaction = ...

    // Sign the transaction
    const { signature } = await provider.request({
      method: 'signTransaction',
      params: {
        transaction: transaction,
        connection: connection,
      },
    });

    console.log("Transaction sent with signature:", signature);
    ```

    ### Parameters

    <ParamField path="method" type="'signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      Parameters for the transaction.

      <Expandable title="child attributes" defaultOpen="true">
        <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
          The transaction to sign. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html).
        </ParamField>

        <ParamField path="connection" type="Connection" required>
          Connection to an SVM (Solana) network.
        </ParamField>
      </Expandable>
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="string">
      The signature of the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Swift">
    Sign a Solana transaction without submitting it to the network.

    ```swift
    public protocol EmbeddedSolanaWalletProvider {
        func signMessage(message: String) async throws -> String
    }
    ```

    ### Usage

    ```swift
    import SolanaSwift

    // Get the provider for wallet (assumes wallet is already obtained)
    let provider = wallet.provider

    // Create a Solana RPC client
    let solana = JSONRPCAPIClient(endpoint: URL(string: "https://api.mainnet-beta.solana.com")!)

    // Build the transaction using your preferred method
    let latestBlockhash = try await solana.getLatestBlockhash()
    let walletPK = try PublicKey(string: wallet.address)
    var tx = Transaction()
    tx.instructions.append(
        SystemProgram.transferInstruction(
            from: walletPK,
            to: try PublicKey(string: "9NvE68JVWHHHGLp5NNELtM5fiBw6SXHrzqQJjUqaykC1"),
            lamports: 100000000000000
        )
    )
    tx.recentBlockhash = latestBlockhash
    tx.feePayer = walletPK

    // Serialize the transaction for signing as base64
    let message = try tx.compileMessage().serialize().base64EncodedString()

    // Sign using the Privy Embedded Wallet
    let signature = try await provider.signMessage(message: message)
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="signature" type="String">
      The base64-encoded signature for the transaction.
    </ResponseField>
  </Tab>

  <Tab title="Android">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```kotlin
    public suspend fun signMessage(message: String): Result<String>
    ```

    ### Usage

    ```kotlin
    // Retrieve user's Solana wallet (assumes wallet is already obtained)
    val solanaWallet = user.embeddedSolanaWallets.first()

    // Create a Solana RPC client
    val connection = Connection("https://api.mainnet-beta.solana.com")

    // Build the transaction
    val walletPublicKey = PublicKey(solanaWallet.address)
    val instruction = SystemProgram.transfer(
        fromPubkey = walletPublicKey,
        toPubkey = PublicKey(recipientAddress),
        lamports = amount
    )

    // Get recent blockhash
    val recentBlockhash = connection.getLatestBlockhash()

    // Create transaction
    val transaction = Transaction()
    transaction.add(instruction)
    transaction.recentBlockhash = recentBlockhash
    transaction.feePayer = walletPublicKey

    // Serialize transaction to base64
    val serializedTransaction = transaction.serializeMessage().base64()

    // Sign the transaction message
    val result = solanaWallet.provider.signMessage(serializedTransaction)
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="Flutter">
    Use the `signMessage` method on the Solana wallet provider to sign a transaction and then submit it to the network.

    ```dart
    Future<Result<String>> signMessage(String message);
    ```

    ### Usage

    ```dart
    // Retrieve the user's Solana wallet (assumes wallet is already obtained)
    final solanaWallet = user.embeddedSolanaWallets.first;

    // Create a Solana RPC client
    final connection = Connection('https://api.mainnet-beta.solana.com');

    // Build the transaction
    final walletPublicKey = PublicKey(solanaWallet.address);
    final instruction = SystemProgram.transfer(
        fromPubkey: walletPublicKey,
        toPubkey: PublicKey(recipientAddress),
        lamports: amount
    );

    // Get recent blockhash
    final recentBlockhash = await connection.getLatestBlockhash();

    // Create transaction
    final transaction = Transaction();
    transaction.add(instruction);
    transaction.recentBlockhash = recentBlockhash;
    transaction.feePayer = walletPublicKey;

    // Serialize transaction to base64
    final serializedTransaction = base64Encode(transaction.serializeMessage());

    // Sign the transaction message
    final result = await solanaWallet.provider.signMessage(serializedTransaction);
    ```

    ### Parameters

    <ParamField path="message" type="String" required>
      The base64-encoded serialized transaction message to sign.
    </ParamField>

    ### Returns

    <ResponseField name="result" type="Result<String>">
      A Result that, when successful, contains the base64-encoded signature.
    </ResponseField>
  </Tab>

  <Tab title="NodeJS">
    Use the `signTransaction` method on the Solana client to sign a transaction with an Solana wallet.

    ```js
    signTransaction: (input: SolanaSignTransactionInputType) => Promise<SolanaSignTransactionResponseType>
    ```

    ### Usage

    ```js
    import {
    clusterApiUrl,
    Connection,
    LAMPORTS_PER_SOL,
    PublicKey,
    SystemProgram,
    Transaction,
    VersionedTransaction,
    TransactionMessage
    } from '@solana/web3.js';

    const walletPublicKey = new PublicKey(wallet.address);
    const connection = new Connection(clusterApiUrl('devnet'));
    const instruction = SystemProgram.transfer({
    fromPubkey: walletPublicKey,
    toPubkey: new PublicKey(address),
    lamports: value * LAMPORTS_PER_SOL
    });

    const {blockhash: recentBlockhash} = await connection.getLatestBlockhash();

    const message = new TransactionMessage({
    payerKey: walletPublicKey,
    // Replace with your desired instructions
    instructions: [instruction],
    recentBlockhash
    });

    const yourSolanaTransaction = new VersionedTransaction(message.compileToV0Message());

    // Get the signed transaction object from the response
    const {signedTransaction} = await privy.walletApi.solana.signTransaction({
    walletId: wallet.id,
    transaction: yourSolanaTransaction
    });
    ```

    ### Parameters

    <ParamField path="walletId" type="string" required>
      The ID of the wallet to send the transaction from.
    </ParamField>

    <ParamField path="transaction" type="Transaction | VersionedTransaction" required>
      The transaction to sign. This can be either a legacy Transaction or a VersionedTransaction object from [@solana/web3.js](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html).
    </ParamField>

    ### Returns

    <ResponseField name="signedTransaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="encoding" type="'base64'">
      The encoding format for the returned `signedTransaction`. Currently, only `'base64'` is supported for Solana.
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To sign a transaction make a `POST` request to

    ```bash
    https://api.privy.io/v1/wallets/<wallet_id>/rpc
    ```

    ### Usage

    ```bash
    $ curl --request POST https://api.privy.io/v1/wallets/<wallet_id>/rpc \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H "privy-authorization-signature: <authorization-signature-for-request>" \
        -H 'Content-Type: application/json' \
        -d '{
            "method": "signTransaction",
            "params": {
            "transaction": "insert-base-64-encoded-serialized-transaction",
            "encoding": "base64"
            }
        }'
    ```

    A successful response will look like the following:

    ```json
    {
    "method": "signTransaction",
    "data": {
        "signed_transaction": "base64-encoded-serialized-signed-transaction",
        "encoding": "base64"
    }
    }
    ```

    ### Parameters

    <ParamField path="method" type="'signTransaction'" required>
      The RPC method executed with the wallet.
    </ParamField>

    <ParamField path="params" type="Object" required>
      <ParamField path="transaction" type="string" required>
        The transaction to sign with the wallet. If the transaction to sign is raw bytes,
        you must serialize the transaction as a base64 string.
      </ParamField>

      <ParamField path="encoding" type="'base64'" required>
        The encoding format for `transaction`. Currently, only `'base64'` is supported
        for Solana.
      </ParamField>
    </ParamField>

    ### Returns

    <ResponseField name="method" type="'signTransaction'">
      The RPC method executed with the wallet.
    </ResponseField>

    <ResponseField name="data.signed_transaction" type="string">
      The signed transaction.
    </ResponseField>

    <ResponseField name="data.encoding" type="'base64'">
      The encoding format for the signed transaction. Currently, only `'base64'` is supported for Ethereum.
    </ResponseField>
  </Tab>
</Tabs>


# Interfacing with common libraries
Source: https://docs.privy.io/wallets/using-wallets/solana/web3-integrations



<Tabs>
  <Tab title="React">
    Privy's **`ConnectedSolanaWallet`** object is fully compatible with popular web3 libraries for interfacing wallets, such as [`@solana/web3js`](https://solana-labs.github.io/solana-web3.js/) and [`solana/kit`](https://github.com/anza-xyz/kit).

    Read below to learn how to best integrate Privy alongside these libraries.

    ## @solana/web3.js

    First find your desired wallet from the **`wallets`** array:

    ```tsx
    import {PublicKey, Transaction, Connection, SystemProgram} from '@solana/web3.js';

    const {wallets} = useSolanaWallets();
    const wallet = wallets[0]; // Replace this with your desired wallet
    ```

    Then, use this wallet to then send Transactions using the @solana/web3.js Transaction and Connection classes:

    ```tsx
    // Configure your connection to point to the correct Solana network
    let connection = new Connection(clusterApiUrl('devnet'));

    // Build out the transaction object for your desired program
    // https://solana-labs.github.io/solana-web3.js/classes/Transaction.html
    let transaction = new Transaction();

    // Send transaction
    console.log(await wallet.sendTransaction!(transaction, connection));
    ```

    {/* TODO: Add solana/kit */}
  </Tab>
</Tabs>


# UI library
Source: https://docs.privy.io/wallets/using-wallets/ui-library



<Tabs>
  <Tab title="React">
    Privy comes with out-of-the-box UIs for signing messages and sending transactions.

    These wallet UIs are highly-customizable, allowing your application to communicate relevant context to the user or abstract away the fact that a wallet is being used under the hood.

    ## Sign message

    Below is a sample message signature UI.

    ![images/Sign.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Sign.png)

    This UI can also be customized by passing a `uiOptions` object of the following type to the  method.

    ### Parameters

    <ParamField path="showWalletUIs" type="boolean">
      Whether to overwrite the configured wallet UI for the signature prompt. Defaults to `undefined`,
      which will respect the server-side or SDK configured option.
    </ParamField>

    <ParamField path="title" type="string">
      The title text for the signature prompt. Defaults to 'Sign'.
    </ParamField>

    <ParamField path="description" type="string">
      The description text for the signature prompt. Defaults to 'Sign to continue'.
    </ParamField>

    <ParamField path="buttonText" type="string">
      The description text for the signature prompt. Defaults to 'Sign and Continue'.
    </ParamField>

    ## Send transaction

    Below is a sample transaction UI.

    ![images/Trans.png](https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/Trans.png)

    This UI can also be customized by passing a `uiOptions` object of the following type to the\
    method.

    ### Parameters

    <ParamField path="showWalletUIs" type="boolean">
      Whether or not to show wallet UIs for this action. Defaults to the wallet UI setting enabled for your app.
    </ParamField>

    <ParamField path="description" type="string">
      Description of the transaction being sent.
    </ParamField>

    <ParamField path="buttonText" type="string">
      Text to show on CTA button for Send Transaction screen. Defaults to 'Submit' or 'Approve'.
    </ParamField>

    <ParamField path="transactionInfo" type="Object">
      <Expandable defaultOpen="true">
        <ParamField path="title" type="string">
          Title for transaction details accordion.
        </ParamField>

        <ParamField path="action" type="string">
          Short action description (e.g., 'Buy NFT').
        </ParamField>

        <ParamField path="contractInfo" type="Object">
          <Expandable defaultOpen="true">
            <ParamField path="url" type="string">
              Smart contract information URL.
            </ParamField>

            <ParamField path="name" type="string">
              Smart contract name.
            </ParamField>

            <ParamField path="imgUrl" type="string">
              Contract image URL.
            </ParamField>

            <ParamField path="imgAltText" type="string">
              Alternative text for contract image.
            </ParamField>

            <ParamField path="imgSize" type="'sm' | 'lg'">
              Image size for contract ('sm' or 'lg').
            </ParamField>
          </Expandable>
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField path="successHeader" type="string">
      Text displayed at the top of the success screen. Defaults to 'Transaction complete!'.
    </ParamField>

    <ParamField path="successDescription" type="string">
      Description for the success screen. Defaults to 'You're all set.'.
    </ParamField>

    <ParamField path="isCancellable" type="boolean">
      Whether to display a cancel button on the confirmation screen.
    </ParamField>
  </Tab>
</Tabs>


# From my client
Source: https://docs.privy.io/wallets/wallets/create/from-my-client



<Tabs>
  <Tab title="React">
    <Tip>
      The React SDK supports automatically creating embedded wallets for your users when they login to your app. View [this guide](/basics/react/advanced/automatic-wallet-creation) to learn more and configure automatic wallet creation.
    </Tip>

    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the React SDK, use the `createWallet` method from the `useCreateWallet` hook:

        ```tsx
        createWallet: async ({walletIndex?: number} | {createAdditional?: boolean}) => Promise<Wallet>
        ```

        ### Usage

        ```tsx
        import {useCreateWallet} from '@privy-io/react-auth';
        const {createWallet} = useCreateWallet();
        ```

        ### Parameters

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        <ParamField path="opts.walletIndex" type="number">
          HD index to create the Ethereum wallet at. User must have an existing Ethereum embedded wallet in order to use this parameter.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Promise<Wallet>">
          A `Promise` for the linked account object for the created wallet.
        </ResponseField>

        ### Callbacks

        You can optionally register an `onSuccess` or `onError` callback on the `useCreateWallet` hook.

        ```tsx
        const {createWallet} = useCreateWallet({
            onSuccess: ({wallet}) => {
                console.log('Created wallet ', wallet);
            },
            onError: (error) => {
                console.error('Failed to create wallet with error ', e)
            }
        })
        ```

        <ParamField path="onSuccess" type="({wallet: Wallet}) => void">
          Optional callback to run after a user successfully creates a wallet.
        </ParamField>

        <ParamField path="onError" type="(error: string) => void">
          Optional callback to run after there is an error during wallet creation.
        </ParamField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the React SDK, use the `createWallet` method from the `useSolanaWallets` hook:

        ```tsx
        createWallet: async ({walletIndex?: number} | {createAdditional?: boolean}) => Promise<Wallet>
        ```

        ### Usage

        ```tsx
        import {useSolanaWallets} from '@privy-io/react-auth/solana';
        const {createWallet} = useSolanaWallets();
        ```

        ### Parameters

        The `createWallet` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Solana wallet for the user if they already have an existing Solana embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        <ParamField path="opts.walletIndex" type="number">
          HD index to create the Solana wallet at. User must have an existing Solana embedded wallet in order to use this parameter.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Wallet">
          The linked account object for the created wallet.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="React Native">
    <Tip>
      The React Native SDK supports automatically creating embedded wallets for your users when they login to your app. View [this guide](/basics/react/advanced/automatic-wallet-creation) to learn more and configure automatic wallet creation.
    </Tip>

    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the React Native SDK, use the `create` method from the `useEmbeddedEthereumWallet` hook:

        ```tsx
        create: async ({createAdditional?: boolean}) => Promise<{user: User}>
        ```

        ### Usage

        ```tsx
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';
        const {create} = useEmbeddedEthereumWallet();
        ```

        ### Parameters

        The `create` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<{user: User}>">
          A `Promise` for an object containing the updated `user` object for the user.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the React Native SDK, use the `create` method from the `useEmbeddedSolanaWallet` hook:

        ```tsx
        create: async ({createAdditional?: boolean}) => Promise<{user: User}>
        ```

        ### Usage

        ```tsx
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        const {create} = useEmbeddedSolanaWallet();
        ```

        ### Parameters

        The `create` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Solana wallet for the user if they already have an existing Solana embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<{user: User}>">
          A `Promise` for an object containing the updated `user` object.
        </ResponseField>
      </Tab>

      <Tab title="Bitcoin">
        To create a wallet with the React Native SDK, use the `create` method from the `useEmbeddedBitcoinWallet` hook:

        ```javascript
        create: async ({chainType: 'bitcoin-taproot' | 'bitcoin-segtwit', createAdditional?: boolean}) => Promise<{user: User}>
        ```

        ### Usage

        ```tsx
        import {useEmbeddedBitcoinWallet} from '@privy-io/expo';

        const {create} = useEmbeddedBitcoinWallet();
        ```

        ### Parameters

        The `create` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="opts.chainType" type="'bitcoin-taproot' | 'bitcoin-segtwit'" required>
          The type of Bitcoin wallet to create.
        </ParamField>

        <ParamField path="opts.createAdditional" type="boolean">
          Whether or not to create an additional Bitcoin wallet for the user if they already have an existing Bitcoin embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`. [Learn more](/recipes/hd-wallets)
        </ParamField>

        ### Returns

        <ResponseField name="user" type="Promise<{user: User}>">
          A `Promise` for an object containing the updated `user` object.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Swift SDK, use the `createEthereumWallet` method from the `PrivyUser` instance:

        ```swift
        func createEthereumWallet(allowAdditional: Bool) async throws -> EmbeddedEthereumWallet
        ```

        ### Parameters

        The `createEthereumWallet` method optionally accepts the following parameters:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="EmbeddedEthereumWallet">
          The newly created `EmbeddedEthereumWallet`.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Swift SDK, use the `createSolanaWallet` method from the `PrivyUser` instance:

        ```swift
        func createSolanaWallet() async throws -> EmbeddedSolanaWallet
        ```

        ### Returns

        <ResponseField name="wallet" type="EmbeddedSolanaWallet">
          The newly created `EmbeddedSolanaWallet`.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Android SDK, use the `createEthereumWallet` method from the `PrivyUser` instance:

        ```kotlin
        public suspend fun createEthereumWallet: (allowAdditional?: Boolean) => Result<EmbeddedEthereumWallet>
        ```

        ### Parameters

        The `createEthereumWallet` method optionally accepts the following parameters:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Result<EmbeddedEthereumWallet>">
          A `Result` containing the `EmbeddedEthereumWallet` for the user.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Android SDK, use the `createSolanaWallet` method from the `PrivyUser` instance:

        ```kotlin
        public suspend fun createEthereumWallet: (allowAdditional?: Boolean) => Result<EmbeddedSolanaWallet>
        ```

        ### Returns

        <ResponseField name="wallet" type="Result<EmbeddedSolanaWallet>">
          A `Result` containing the `EmbeddedSolanaWallet` for the user.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Unity">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Unity SDK, use the `CreateWallet` method on your `PrivyUser` instance:

        ```csharp
        Task<IEmbeddedEthereumWallet> CreateWallet(bool allowAdditional)
        ```

        ### Parameters

        The `CreateWallet` method accepts the following parameter:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional wallet for the user if they already have an existing ethereum wallet.
          Must be set to `true` to create additional wallets.
          Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Task<IEmbeddedEthereumWallet>">
          A `Task` for the created ethereum wallet object.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Unity SDK, use the `CreateSolanaWallet` method on your `PrivyUser` instance:

        ```csharp
        Task<IEmbeddedSolanaWallet> CreateSolanaWallet(bool allowAdditional)
        ```

        ### Parameters

        The `CreateSolanaWallet` method accepts the following parameter:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional wallet for the user if they already have an existing solana wallet.
          Must be set to `true` to create additional wallets.
          Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Task<IEmbeddedSolanaWallet>">
          A `Task` for the created solana wallet object.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Tabs>
      <Tab title="Ethereum">
        To create a wallet with the Flutter SDK, use the `createEthereumWallet` method from the `PrivyUser` instance:

        ```dart
        Future<Result<EmbeddedEthereumWallet>> createEthereumWallet({bool allowAdditional = false});
        ```

        ### Parameters

        The `createEthereumWallet` method optionally accepts as a parameter an `opts` object with the following fields:

        <ParamField path="allowAdditional" type="bool">
          Whether or not to create an additional Ethereum wallet for the user if they already have an existing Ethereum embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Future<Result<EmbeddedEthereumWallet>>">
          A `Result` containing the `EmbeddedEthereumWallet` for the user.
        </ResponseField>
      </Tab>

      <Tab title="Solana">
        To create a wallet with the Android SDK, use the `createSolanaWallet` method from the `PrivyUser` instance:

        ```dart
        Future<Result<EmbeddedSolanaWallet>> createSolanaWallet()
        ```

        ### Parameters

        The `createSolanaWallet` method optionally accepts the following parameters:

        <ParamField path="allowAdditional" type="Boolean">
          Whether or not to create an additional Solana wallet for the user if they already have an existing Solana embedded wallet. Must be set to `true` to create additional wallets. Defaults to `false`.
        </ParamField>

        ### Returns

        <ResponseField name="wallet" type="Future<Result<EmbeddedSolanaWallet>>">
          A `Result` containing the `EmbeddedSolanaWallet` for the user.
        </ResponseField>
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# From my server
Source: https://docs.privy.io/wallets/wallets/create/from-my-server



Privy enables your app to easily create server-side wallets on any EVM network or Solana.

<Info>
  If the wallet is for a user, use [wallet
  pregeneration](/wallets/wallets/create/pregenerate-wallets) instead to associate the wallet with
  user's login methods.
</Info>

<Tabs>
  <Tab title="NodeJS">
    To create a wallet with the NodeJS SDK, use the `create` method from the Privy client's `walletApi` class:

    ```ts
    createWallet: (input: WalletApiCreateRequestType) => Promise<WalletApiCreateResponseType>
    ```

    ### Usage

    ```ts
    const {id, address, chainType} = await privy.walletApi.create({chainType: 'ethereum'});
    ```

    ### Parameters

    The `create` method accepts as a parameter an `input` object with the following fields:

    <ParamField type="'ethereum' | 'solana' | 'stellar' | 'cosmos'" path="chainType" required>
      Chain type of the wallet to create.
    </ParamField>

    <ParamField type="string[]" path="policyIds">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField type="string" path="idempotencyKey">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    <ParamField type="{'publicKey': string}" path="owner">
      The P-256 public key that will be the owner of the wallet. If you provide this, do not specify an owner\_id as it will be generated automatically.
    </ParamField>

    <ParamField type="string" path="ownerId">
      The key quorum ID of the owner of the wallet. If you provide this, do not specify an owner.
    </ParamField>

    <ParamField type="{'signerId': string}[]" path="additionalSigners">
      List of key quorum IDs that should be allowed to approve transactions for the wallet.
    </ParamField>

    ### Returns

    <ResponseField type="string" name="id">
      Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
    </ResponseField>

    <ResponseField type="string" name="address">
      Address of the created wallet.
    </ResponseField>

    <ResponseField type="'ethereum' | 'solana' | 'stellar' | 'cosmos'" name="chainType">
      Chain type of the created wallet.
    </ResponseField>

    <ResponseField type="string[]" name="policyIds">
      List of policy IDs for policies that are enforced on the wallet.
    </ResponseField>

    <ResponseField type="string | null" name="ownerId">
      The key quorum ID of the owner of the wallet.
    </ResponseField>

    <ResponseField type="{signerId: string}[]" name="additionalSigners">
      The key quorum IDs of the additional signers for the wallet.
    </ResponseField>

    <Tip>
      Your app can provision a smart account with the wallet as a signer by following [this guide](/wallets/gas-and-asset-management/gas/ethereum).
    </Tip>
  </Tab>

  <Tab title="REST API">
    To create a new wallet, make a `POST` request to

    ```bash
    https://api.privy.io/v1/wallets
    ```

    ### Body

    In the request body, include the following fields.

    <ParamField type="'ethereum' | 'solana' | 'stellar' | 'cosmos'" path="chain_type" required>
      Chain type of the wallet to create.
    </ParamField>

    <ParamField type="string[]" path="policy_ids">
      List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField type="string" path="idempotency_key">
      [Idempotency key](/api-reference/idempotency-keys) to identify a unique request.
    </ParamField>

    <ParamField type="{public_key: string} | null" path="owner">
      The P-256 public key of the owner of the wallet. If you provide this, do not specify an owner\_id as it will be generated automatically.
    </ParamField>

    <ParamField type="string | null" path="owner_id">
      The key quorum ID of the owner of the wallet. If you provide this, do not specify an owner.
    </ParamField>

    <ParamField type="{signer_id: string}[]" path="additional_signers">
      The key quorum IDs to add as additional signers for the wallet.
    </ParamField>

    ### Response

    In the response, Privy will send back the following if successful:

    <ResponseField type="string" name="id">
      Unique ID of the created wallet. This will be the primary identifier when using the wallet in the future.
    </ResponseField>

    <ResponseField type="string" name="address">
      Address of the created wallet.
    </ResponseField>

    <ResponseField type="'ethereum' | 'solana' | 'stellar' | 'cosmos'" name="chain_type">
      Chain type of the created wallet.
    </ResponseField>

    <ResponseField type="string[]" name="policy_ids">
      List of policy IDs for policies that are enforced on the wallet.
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the wallet.
    </ResponseField>

    <ResponseField type="{signer_id: string}[]" name="additional_signers">
      The key quorum IDs of the additional signers for the wallet.
    </ResponseField>

    <ResponseField name="created_at" type="number">
      The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
    </ResponseField>

    ### Example

    A sample request might look like the following:

    ```bash
    curl --request POST https://api.privy.io/v1/wallets \
        -u "<your-privy-app-id>:<your-privy-app-secret>" \
        -H "privy-app-id: <your-privy-app-id>" \
        -H 'Content-Type: application/json' \
        -d '{
        "chain_type": "ethereum"
        }'
    ```

    A successful response will look like the following:

    ```json
    {
        "id": "fmfdj6yqly31huorjqzq38zc",
        "address": "0xf9f284C7Eaf97b0f9B5542d83Af7F785D12E803a",
        "chain_type": "ethereum",
        "policy_ids": [],
        "owner_id": null,
        "additional_signers": [],
        "created_at": 1733923425155
    }
    ```
  </Tab>
</Tabs>


# Overview
Source: https://docs.privy.io/wallets/wallets/create/overview



Privy enables you to programmatically create a new wallet within your application. There are two primary types of optionality: the chain (or chain ecosystem) that the wallet is created on, and whether it's created on the client side or the server side.

## Chain type

You can choose whether to create the wallet as an EVM wallet (on Ethereum and any Ethereum L2), or Solana. With either, you can then trigger wallet signing, transaction sending, and more.

## Client-side vs server-side

Privy provides a number of client-side and server-side SDK (or REST API) options for you to programmatically create your wallet. This decision simply depends on where you want your wallet-related logic to live.

For detailed implementation guides, see:

* [Creating wallets from a client SDK](/wallets/wallets/create/from-my-client)
* [Creating wallets from a server](/wallets/wallets/create/from-my-server)


# Pregenerating wallets
Source: https://docs.privy.io/wallets/wallets/create/pregenerate-wallets



With Privy, you can **pregenerate self-custodial Ethereum and Solana embedded wallets** for existing users, or create a new user with other login methods, like an email address or phone number, without requiring the user to login.
You can even send assets to the wallet before the user logs in to your app for the first time.

Once the user associated with the account logs in, they will be able to access the pregenerated wallet and any assets sent to them.

## Pregenerating wallets for new users

<Tabs>
  <Tab title="NodeJS">
    To pregenerate embedded wallets for a given user, use the `importUser` method from `PrivyClient`.

    ```javascript
    importUser: ({linkedAccounts: LinkedAccountType[], createEthereumWallet?: boolean, createSolanaWallet?: boolean, createEthereumSmartWallet?: boolean, customMetadata?: CustomMetadataType}) => Promise<User>
    ```

    ### Usage

    ```tsx
    const user = await privy.importUser({
        linkedAccounts: [
            {
            type: 'email',
            address: 'batman@privy.io',
            },
        ],
        createEthereumWallet: true,
        createSolanaWallet: true,
        createEthereumSmartWallet: true,
        customMetadata: {
            username: 'name',
            isVerified: true,
            age: 23,
        },
    });
    ```

    ### Params

    <ParamField path="linkedAccounts" type="LinkedAccountType[]" required>
      An array of linked accounts to associate with the user.
    </ParamField>

    <ParamField path="createEthereumWallet" type="boolean">
      (Optional) Whether to create an Ethereum wallet for the user.
    </ParamField>

    <ParamField path="createSolanaWallet" type="boolean">
      (Optional) Whether to create a Solana wallet for the user.
    </ParamField>

    <ParamField path="createEthereumSmartWallet" type="boolean">
      (Optional) Whether to create an Ethereum smart wallet for the user.
    </ParamField>

    <ParamField path="customMetadata" type="CustomMetadataType">
      (Optional) Custom metadata to associate with the user.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="User" />
  </Tab>

  <Tab title="REST API">
    To pregenerate embedded wallets for a given user, make a POST request to `https://auth.privy.io/api/v1/users`.

    ### Usage

    Below is a sample cURL command for generating a new wallet for a user with Privy:

    ```sh
    $ curl --request POST https://auth.privy.io/api/v1/users \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
            "create_ethereum_wallet": true,
            "linked_accounts": [
                {
                    "address": "batman@privy.io",
                    "type": "email"
                }
            ]
        }'
    ```

    A successful response will include the new user object along with their user ID and embedded wallet address, like below:

    ```json
        {
            "id": "did:privy:clddy332f002tyqpq3b3lv327",
            "created_at": 1674788927,
            "linked_accounts": [
                {
                    "address": "batman@privy.io",
                    "type": "email"
                },
                {
                    "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
                    "type": "wallet",
                    "walletClient": "privy",
                    "chain_type": "ethereum"
                }
            ]
        }
    ```

    ### Parameters

    <ParamField path="linked_accounts" type="LinkedAccountType[]" required>
      An array of linked accounts to associate with the user.
    </ParamField>

    <ParamField path="create_ethereum_wallet" type="boolean">
      (Optional) Whether to create an Ethereum wallet for the user.
    </ParamField>

    <ParamField path="create_solana_wallet" type="boolean">
      (Optional) Whether to create a Solana wallet for the user.
    </ParamField>

    <ParamField path="create_ethereum_smart_wallet" type="boolean">
      (Optional) Whether to create an Ethereum smart wallet for the user.
    </ParamField>

    <ParamField path="custom_metadata" type="CustomMetadataType">
      (Optional) Custom metadata to associate with the user.
    </ParamField>
  </Tab>
</Tabs>

## Pregenerating wallets for existing users

<Tabs>
  <Tab title="NodeJS">
    To create embedded wallets for an existing user, use the `createWallets` method from `PrivyClient`.

    ```javascript
    createWallets: ({userId: string, createEthereumWallet?: boolean, createSolanaWallet?: boolean, createEthereumSmartWallet?: boolean, numberOfEthereumWalletsToCreate?: number}) => Promise<User>
    ```

    ### Usage

    ```tsx
    const user = await privy.createWallets({
        userId: 'did:privy:clddy332f002tyqpq3b3lv327',
        createEthereumWallet: true,
        createSolanaWallet: true,
        createEthereumSmartWallet: true,
        numberOfEthereumWalletsToCreate: 2,
    });
    ```

    ### Params

    <ParamField path="userId" type="string" required>
      The Privy user ID to create wallets for.
    </ParamField>

    <ParamField path="createEthereumWallet" type="boolean">
      (Optional) Whether to create an Ethereum wallet for the user.
    </ParamField>

    <ParamField path="createSolanaWallet" type="boolean">
      (Optional) Whether to create a Solana wallet for the user.
    </ParamField>

    <ParamField path="createEthereumSmartWallet" type="boolean">
      (Optional) Whether to create an Ethereum smart wallet for the user.
    </ParamField>

    <ParamField path="numberOfEthereumWalletsToCreate" type="number">
      (Optional) The number of Ethereum wallets to pregenerate for the user. Defaults to `1`.
    </ParamField>

    ### Returns

    <ResponseField name="user" type="User" />
  </Tab>

  <Tab title="REST API">
    To pregenerate embedded wallets for a given user, make a POST request to `https://auth.privy.io/api/v1/apps/<your-app-id>/users/wallet`.

    ### Usage

    Below is a sample cURL command for generating a new wallet for a user with Privy:

    ```sh
    $ curl --request POST https://auth.privy.io/api/v1/apps/<your-privy-app-id>/users/wallet \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "Content-Type: application/json" \
    -d '{
    "user_id": "did:privy:clddy332f002tyqpq3b3lv327",
    "create_ethereum_wallet": true
    }'
    ```

    A successful response will include the new user object along with their user ID and embedded wallet address, like below:

    ```json
        {
            "id": "did:privy:clddy332f002tyqpq3b3lv327",
            "created_at": 1674788927,
            "linked_accounts": [
                {
                    "address": "batman@privy.io",
                    "type": "email"
                },
                {
                    "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
                    "type": "wallet",
                    "walletClient": "privy",
                    "chain_type": "ethereum"
                }
            ]
        }
    ```

    ### Parameters

    <ParamField path="userId" type="string" required>
      The Privy user ID to create wallets for.
    </ParamField>

    <ParamField path="createEthereumWallet" type="boolean">
      (Optional) Whether to create an Ethereum wallet for the user.
    </ParamField>

    <ParamField path="createSolanaWallet" type="boolean">
      (Optional) Whether to create a Solana wallet for the user.
    </ParamField>

    <ParamField path="createEthereumSmartWallet" type="boolean">
      (Optional) Whether to create an Ethereum smart wallet for the user.
    </ParamField>

    <ParamField path="numberOfEthereumWalletsToCreate" type="number">
      (Optional) The number of Ethereum wallets to pregenerate for the user. Defaults to `1`.
    </ParamField>
  </Tab>
</Tabs>


# Exporting private keys
Source: https://docs.privy.io/wallets/wallets/export



**Privy enables your users to export the private key or seed phrase for their embedded wallet**. This allows them to use their embedded wallet address with another wallet client, such as MetaMask or Phantom.

<Tabs>
  <Tab title="React">
    To have your user export their embedded wallet's private key or seed phrase, **use Privy's `exportWallet` method:**

    <Tabs>
      <Tab title="EVM">
        ```tsx
        import {usePrivy} from '@privy-io/react-auth';
        ...
        const {exportWallet} = usePrivy();
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        import {useSolanaWallets} from '@privy-io/react-auth/solana';
        ...
        const {exportWallet} = useSolanaWallets();
        ```
      </Tab>
    </Tabs>

    When invoked, **`exportWallet`** will open a modal where your user can copy the full private key or seed phrase for their embedded wallet. The modal will also link your user to [a guide](https://privy-io.notion.site/Transferring-Your-App-Account-9dab9e16c6034a7ab1ff7fa479b02828) for how to load their embedded wallet into another wallet client, such as MetaMask or Phantom.

    If your user is not **`authenticated`** or has not yet created an embedded wallet in your app, this method will fail.

    As an example, you might attach **`exportWallet`** to an export wallet button in your app:

    <Tabs>
      <Tab title="EVM">
        ```tsx
        import {usePrivy} from '@privy-io/react-auth';

        function ExportWalletButton() {
          const {ready, authenticated, user, exportWallet} = usePrivy();
          // Check that your user is authenticated
          const isAuthenticated = ready && authenticated;
          // Check that your user has an embedded wallet
          const hasEmbeddedWallet = !!user.linkedAccounts.find(
            (account) =>
              account.type === 'wallet' &&
              account.walletClient === 'privy' &&
              account.chainType === 'ethereum'
          );

          return (
            <button onClick={exportWallet} disabled={!isAuthenticated || !hasEmbeddedWallet}>
              Export my wallet
            </button>
          );
        }
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        import {usePrivy, type WalletWithMetadata} from '@privy-io/react-auth';
        import {useSolanaWallets} from '@privy-io/react-auth/solana';

        function ExportWalletButton() {
          const {ready, authenticated, user} = usePrivy();
          const {exportWallet} = useSolanaWallets();
          // Check that your user is authenticated
          const isAuthenticated = ready && authenticated;
          // Check that your user has an embedded wallet
          const hasEmbeddedWallet = !!user.linkedAccounts.find(
            (account): account is WalletWithMetadata =>
              account.type === 'wallet' &&
              account.walletClient === 'privy' &&
              account.chainType === 'solana'
          );

          return (
            <button onClick={exportWallet} disabled={!isAuthenticated || !hasEmbeddedWallet}>
              Export my wallet
            </button>
          );
        }
        ```

        Please note that exporting the seed phrase for Solana wallets is not supported, as different external wallet clients use different HD derivation paths to derive Solana wallet addresses from a seed phrase. Privy supports exporting Solana wallets by private key to ensure that users maintain the same address when importing their wallet into an external wallet client like Phantom.
      </Tab>
    </Tabs>

    <Info>
      If your application uses [smart wallets](/wallets/using-wallets/evm-smart-wallets/overview) on EVM
      networks, exporting the wallet will export the private key for the **smart wallet's signer**, and
      not the smart wallet itself. Users can control their smart wallet via this private key, but will
      be required to manually use it to sign calls to the contract for their smart wallet directly to
      use the smart wallet outside of your app.
    </Info>

    ### Exporting HD wallets

    If your user has multiple embedded wallets, you can export the private key for a specific wallet by passing the address of your desired wallet as an `address` parameter to the `exportWallet` method:

    <Tabs>
      <Tab title="EVM">
        ```tsx
        import {exportWallet} from '@privy-io/react-auth';
        ...
        const {exportWallet} = usePrivy();
        await exportWallet({address: 'insert-your-desired-address'});
        ```
      </Tab>

      <Tab title="Solana">
        ```tsx
        import {useSolanaWallets} from '@privy-io/react-auth/solana';
        ...
        const {exportWallet} = useSolanaWallets();
        await exportWallet({address: 'insert-your-desired-address'});
        ```

        If no `address` is passed to `exportWallet`, Privy will default to exporting the wallet at `walletIndex: 0`.
      </Tab>
    </Tabs>

    <Info>
      When your user exports their embedded wallet, their private key or seed phrase is assembled on a
      different origin than your app's origin. This means neither you nor Privy can ever access your
      user's private key or seed phrase.{' '}
      <b>Your user is the only party that can ever access their full private key or seed phrase.</b>
    </Info>
  </Tab>

  <Tab title="REST API">
    To export a wallet's private key via the REST API, use the `/v1/wallets/{wallet_id}/export` endpoint. This endpoint uses Hybrid Public Key Encryption (HPKE) to securely transmit the private key.

    <Warning>
      A wallet must have a policy attached that explicitly permits private key exports via the
      `exportPrivateKey` method. See our [Ethereum example
      policy](/controls/policies/example-policies/ethereum#prevent-private-key-exports-while-allowing-other-actions)
      or [Solana example
      policy](/controls/policies/example-policies/solana#prevent-private-key-exports-while-allowing-other-actions)
      for reference on how to configure this.
    </Warning>

    ```bash
    curl --request POST \
      --url https://api.privy.io/v1/wallets/{wallet_id}/export \
      --header 'Authorization: Basic <encoded-value>' \
      --header 'Content-Type: application/json' \
      --header 'privy-app-id: <privy-app-id>' \
      --data '{
        "encryption_type": "HPKE",
        "recipient_public_key": "<base64-encoded-recipient-public-key>"
      }'
    ```

    The endpoint will return the encrypted private key along with the encapsulation information needed for decryption:

    ```json
    {
      "encryption_type": "HPKE",
      "ciphertext": "Zb2XqqIpPlQKJhkb9GRoXa8N6pKLAlozYnXg713g7mCu5vvn6tGIRbeJj4XOUQkFeB9DRxKg",
      "encapsulated_key": "BLplgxEpMz+WMxDSOzGZe+Oa5kkt9FTxUudRRyO5zRj/OaDbUaddlE18uNv8UKxpecnrSy+UByG2C3oJTgTnGNk="
    }
    ```

    ### Decrypting the Private Key

    The exported private key is encrypted using Hybrid Public Key Encryption (HPKE) with the following configuration:

    * KEM: DHKEM\_P256\_HKDF\_SHA256
    * KDF: HKDF\_SHA256
    * AEAD: CHACHA20\_POLY1305
    * Mode: BASE

    To decrypt the private key, you'll need to use these same parameters along with your recipient private key. Here's how to implement the decryption in several languages:

    <Tabs>
      <Tab title="TypeScript">
        <CodeGroup>
          ```ts decrypt.ts
          import {CipherSuite, DhkemP256HkdfSha256, HkdfSha256} from '@hpke/core';
          import {Chacha20Poly1305} from '@hpke/chacha20poly1305';

          /**
           * Decrypts a message using HPKE (Hybrid Public Key Encryption).
           *
           * Uses P-256 keys with HPKE to decrypt an encrypted message. The function expects base64-encoded
           * inputs and handles all necessary key imports and context creation for HPKE decryption.
           *
           * @param privateKeyBase64 Base64-encoded private key in PKCS8 format used for decryption.
           * @param encapsulatedKeyBase64 Base64-encoded raw public key bytes representing the
           *     encapsulated key.
           * @param ciphertextBase64 Base64-encoded encrypted message using base64url encoding that
           *     will be decrypted.
           * @returns A Promise that resolves to the decrypted message as a UTF-8 string.
           * @throws {Error} If decryption fails or if any of the inputs are incorrectly formatted.
           */
          async function decryptHPKEMessage(
            privateKeyBase64: string,
            encapsulatedKeyBase64: string,
            ciphertextBase64: string
          ): Promise<string> {
            // Initialize the cipher suite
            const suite = new CipherSuite({
              kem: new DhkemP256HkdfSha256(),
              kdf: new HkdfSha256(),
              aead: new Chacha20Poly1305()
            });

            // Convert base64 to ArrayBuffer using browser APIs
            const base64ToBuffer = (base64: string) =>
              Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;

            // Import private key using WebCrypto
            const privateKey = await crypto.subtle.importKey(
              'pkcs8',
              base64ToBuffer(privateKeyBase64),
              {
                name: 'ECDH',
                namedCurve: 'P-256'
              },
              true,
              ['deriveKey', 'deriveBits']
            );

            // Create recipient context and decrypt
            const recipient = await suite.createRecipientContext({
              recipientKey: privateKey,
              enc: base64ToBuffer(encapsulatedKeyBase64)
            });

            return new TextDecoder().decode(await recipient.open(base64ToBuffer(ciphertextBase64)));
          }
          ```

          ```ts example.ts
          // The response from the export API endpoint
          const response = {
            encryption_type: 'HPKE',
            ciphertext: 'Zb2XqqIpPlQKJhkb9GRoXa8N6pKLAlozYnXg713g7mCu5vvn6tGIRbeJj4XOUQkFeB9DRxKg',
            encapsulated_key:
              'BLplgxEpMz+WMxDSOzGZe+Oa5kkt9FTxUudRRyO5zRj/OaDbUaddlE18uNv8UKxpecnrSy+UByG2C3oJTgTnGNk='
          };

          // Replace with your base64-encoded private key
          const privateKeyBase64 =
            'MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgU4RP++trEcTL2CPSgX9dKZAQ+XW3Pt49PNI4Elwia1qhRANCAAROjlGlaxrE9rIRc2jy0xmW7ajzkRqccVJsc2WMsXKoB2lG5NllwkSHwWsZkDbmqhYFk/WlDYl/MCiLnYYVtJf+';

          try {
            const privateKey = await decryptHPKEMessage(
              privateKeyBase64,
              response.encapsulated_key,
              response.ciphertext
            );
            console.log('Decrypted private key:', privateKey);
          } catch (error) {
            console.error('Failed to decrypt:', error);
          }
          ```
        </CodeGroup>
      </Tab>

      <Tab title="Python">
        <CodeGroup>
          ```python decrypt.py
          from cryptography.hazmat.primitives import serialization
          from hpke import CipherSuite, KEMId, KDFId, AEADId
          import base64

          async def decrypt_hpke_message(
              private_key_base64: str,
              encapsulated_key_base64: str,
              ciphertext_base64: str
          ) -> str:
              """
              Decrypts a message using HPKE (Hybrid Public Key Encryption) with P-256 keys

              Args:
                  private_key_base64: Base64-encoded private key in PKCS8 format used for decryption.
                  encapsulated_key_base64: Base64-encoded raw public key bytes representing the
                                          encapsulated key.
                  ciphertext_base64: Base64-encoded encrypted message using base64url encoding that
                                    will be decrypted.

              Returns:
                  str: The decrypted message as a UTF-8 string

              Raises:
                  ValueError: If decryption fails or if inputs are incorrectly formatted
              """
              # Initialize the cipher suite
              suite = CipherSuite.new(
                  KEMId.DHKEM_P256_HKDF_SHA256,
                  KDFId.HKDF_SHA256,
                  AEADId.CHACHA20_POLY1305
              )

              # Convert base64 to bytes
              raw_public_key = base64.b64decode(encapsulated_key_base64)
              private_key_bytes = base64.b64decode(private_key_base64)
              ciphertext = base64.b64decode(ciphertext_base64)

              # Import private key
              loaded_private_key = serialization.load_der_private_key(
                  private_key_bytes,
                  password=None
              )
              private_number = loaded_private_key.private_numbers().private_value
              private_bytes = private_number.to_bytes(32, byteorder="big")  # P-256 uses 32 bytes
              private_kem_key = suite.kem.deserialize_private_key(private_bytes)

              # Create recipient context and decrypt
              encapsulated_kem_key = suite.kem.deserialize_public_key(raw_public_key)
              recipient_context = suite.create_recipient_context(
                  encapsulated_kem_key.to_public_bytes(),
                  private_kem_key
              )

              # Decrypt and return as UTF-8 string
              return recipient_context.open(ciphertext).decode("utf-8")
          ```

          ```python example.py
          # The response from the export API endpoint
          response = {
              "encryption_type": "HPKE",
              "ciphertext": "Zb2XqqIpPlQKJhkb9GRoXa8N6pKLAlozYnXg713g7mCu5vvn6tGIRbeJj4XOUQkFeB9DRxKg",
              "encapsulated_key": "BLplgxEpMz+WMxDSOzGZe+Oa5kkt9FTxUudRRyO5zRj/OaDbUaddlE18uNv8UKxpecnrSy+UByG2C3oJTgTnGNk="
          }

          # Replace with your base64-encoded private key
          private_key_base64 = "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgU4RP++trEcTL2CPSgX9dKZAQ+XW3Pt49PNI4Elwia1qhRANCAAROjlGlaxrE9rIRc2jy0xmW7ajzkRqccVJsc2WMsXKoB2lG5NllwkSHwWsZkDbmqhYFk/WlDYl/MCiLnYYVtJf+"

          # Decrypt the private key
          private_key = decrypt_hpke_message(
              private_key_base64, response["encapsulated_key"], response["ciphertext"]
          )
          print(private_key)
          ```
        </CodeGroup>
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Get all wallets
Source: https://docs.privy.io/wallets/wallets/get-a-wallet/get-all-wallets



Get all server-side wallets for your application.

{/* TODO: Fix this */}

{/* <Note> */}

{/* You can also query for [external wallets linked to user */}

{/* accounts](/user-management/users/linking-accounts) and [embedded wallets created within your app] */}

{/* result in a unified object representing the wallet. You can look all of these up. */}

{/* </Note> */}

<Tabs>
  <Tab title="NodeJS">
    To fetch all your application's wallets, use the Privy client's `walletApi.getWallets` method. This is a paginated query.

    ```tsx
    getWallets: ({cursor?: string, limit?: number, chainType?: 'ethereum' | 'solana'}) => Promise<{data: WalletApiWalletResponseType[], nextCursor?: string}>
    ```

    ### Usage

    ```tsx
    const wallets = [];
    let nextCursor;

    do {
        const result = await privy.walletApi.getWallets({chainType: 'ethereum', cursor: nextCursor});
        wallets.push(...result.data);
        nextCursor = result.nextCursor;
    } while (nextCursor);
    const wallet = wallets.find((wallet) => wallet.address === desiredAddress);
    ```

    ### Parameters

    The `getWallets` method optionally accepts an object with the following fields:

    <ParamField path="cursor" type="string">
      ID of the wallet from which start the search
    </ParamField>

    <ParamField path="limit" type="number">
      Max amount of wallets to fetch per page
    </ParamField>

    <ParamField path="chainType" type="'ethereum' | 'solana'">
      Chain type to filter by.
    </ParamField>

    ### Returns

    <ResponseField name="data" type="WalletApiWalletResponseType[]">
      List of wallets in the current page
    </ResponseField>

    <ResponseField name="nextCursor" type="string">
      Cursor to use for fetching the next page of results, if any
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To fetch your wallets by pages, make a `GET` request to:

    ```
    https://api.privy.io/v1/wallets
    ```

    ### Query

    In the request query parameters, include any of the following:

    <ParamField path="cursor" type="string">
      ID of the wallet from which start the search
    </ParamField>

    <ParamField path="limit" type="number">
      Max amount of wallets per page
    </ParamField>

    <ParamField path="chain_type" type="'ethereum' | 'solana'">
      Chain type to filter by.
    </ParamField>

    ### Response

    In the response, Privy will send back the following if successful:

    <ResponseField name="data" type="Array<WalletApiWalletResponseType>">
      List of wallets in the current page

      <Expandable defaultOpen="true">
        <ResponseField name="id" type="string">
          Unique ID of the wallet
        </ResponseField>

        <ResponseField name="address" type="string">
          Address of the wallet
        </ResponseField>

        <ResponseField name="chain_type" type="'ethereum' | 'solana'">
          Chain type of the wallet
        </ResponseField>

        <ResponseField name="policy_ids" type="string[]">
          List of policy IDs associated with the wallet
        </ResponseField>

        <ResponseField type="string | null" name="owner_id">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="{signer_id: string}[]" name="additional_signers">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField name="created_at" type="number">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="next_cursor" type="string">
      ID of the wallet from which start the next page
    </ResponseField>

    ### Example

    As an example, a sample request to fetch EVM wallets might look like the following:

    ```bash
    $ curl --request GET https://api.privy.io/v1/wallets?chain_type=ethereum&limit=1 \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H 'Content-Type: application/json' \
    ```

    A successful response will look like the following:

    ```json
    {
      "data": [
        {
          "id": "yepf6384cu2nkup42gvrwdqh",
          "address": "0x2F3eb40872143b77D54a6f6e7Cc120464C764c09",
          "chain_type": "ethereum",
          "authorization_threshold": 2,
          "owner_id": null,
          "additional_signers": [],
          "created_at": 1733923425155
        }
      ],
      "next_cursor": "u67nttpkeeti2hm9w7aoxdcc"
    }
    ```
  </Tab>
</Tabs>


# Get user connected wallets
Source: https://docs.privy.io/wallets/wallets/get-a-wallet/get-connected-wallet



A user may come in with both embedded and external wallets. Privy makes it easy to find all of a user's connected wallets so you can help them take an onchain action with the appropriate wallet.

It's worth distinguishing connected vs linked wallets for Privy:

* **Linked wallets** are embedded or external wallets tied to a user object. They may or may not be connected.
* **Connected wallets** are embedded or external wallets currently available for the web client. They may or may not be linked to a user's account.

<Tip>
  Not seeing all of the external wallets connected to the application? Make sure you have [completed
  the steps to connect](/wallets/connectors/setup/configuring-external-connector-chains) any wallets
  to your application.
</Tip>

Both **external wallets** (that users *connect* to your site) and **embedded wallets** (that users *create* within your app) result in a unified object representing the wallet.

<Tabs>
  <Tab title="React">
    <Tabs>
      <Tab title="Ethereum">
        To access connected wallets with the React SDK, use the `wallets` array from the `useWallets` hook:

        ```tsx
        const wallets: ConnectedWallet[]
        ```

        ### Usage

        ```tsx
        import {useWallets} from '@privy-io/react-auth';
        const { wallets } = useWallets();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        The **`wallets`** array includes an object for all wallets a user has connected to your site.
      </Tab>

      <Tab title="Solana">
        To access connected wallets with the React SDK, use the `wallets` array from the `useSolanaWallets` hook:

        ```tsx
        const wallets: ConnectedSolanaWallet[]
        ```

        ### Usage

        ```tsx
        import {useSolanaWallets} from '@privy-io/react-auth/solana';
        const { wallets } = useSolanaWallets();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```

        The **`wallets`** array includes an object for all wallets a user has connected to your site. The array is ordered from most recently connected to least recently connected.
      </Tab>
    </Tabs>

    ## Waiting for wallets to be `ready`

    When your page loads in the user's browser, the Privy SDK determines what wallets the user has connected to your app in two ways:

    * For **external wallets**, Privy determines what wallets are connected via EIP-6963 for injected wallets (e.g. browser extension wallets) and via WalletConnect for mobile wallets.
    * For **embedded wallets**, Privy determines if the user has an embedded wallet by loading the Privy iframe which stores the private key material used for the wallet.

    To determine if Privy has fully processed all external and embedded EVM wallet connections, use the **`ready`** boolean returned by the **`useWallets`** hook, or the **`ready`** boolean returned by the **`useSolanaWallets`** hook for Solana wallets.

    Concretely, **`ready`** will be `false` while Privy is determining what wallets are available for the user, and will be `true` once Privy has settled on the current set of connected wallets.

    ***

    ## `useWallets` and `useSolanaWallets` vs. `usePrivy`

    The **`useWallets`, `useSolanaWallets`**, and **`usePrivy`** hooks all return information about a user's wallets. The key difference between the them is:

    * **`useWallets`** and **`useSolanaWallets`** will return all *connected* wallets (EVM and Solana, respectively), which you can use to request signatures or take onchain actions (via transactions).
    * **`usePrivy`** will return all *linked* wallets, which you can use to verify that a user owns a given wallet address.

    Linked wallets are not necessarily actively connected to your site, so you may not always be able to request a signature or transaction from them. Similarly, connected wallets are not necessarily linked, as a user may have connected their wallet without signing a message to verify that they own the wallet address.

    Concretely, if your use case only requires you to verify that a user owns a given wallet address, you should use the wallets information returned by the **`usePrivy`** hook.

    Otherwise, if your use case requires you to take actions on a *connected* wallet, such as getting its network or requesting a signature or transaction, you should use the wallets information returned by the **`useWallets`** and **`useSolanaWallets`** hook instead.
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="Ethereum">
        To access connected wallets with the React Native SDK, use the `wallets` array from the `useEmbeddedEthereumWallet` hook:

        ```tsx
        const wallets: ConnectedEthereumWallet[]
        ```

        ### Usage

        ```tsx
        import {useEmbeddedEthereumWallet} from '@privy-io/expo';
        const {wallets} = useEmbeddedEthereumWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```
      </Tab>

      <Tab title="Solana">
        To access connected wallets with the React Native SDK, use the `wallets` array from the `useEmbeddedSolanaWallet` hook:

        ```tsx
        const wallets: ConnectedSolanaWallet[]
        ```

        ### Usage

        ```tsx
        import {useEmbeddedSolanaWallet} from '@privy-io/expo';
        const {wallets} = useEmbeddedSolanaWallet();
        const desiredWallet = wallets.find((wallet) => wallet.address === desiredAddress);
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Swift">
    <Tabs>
      <Tab title="Ethereum">
        To access connected Ethereum wallets using the Swift SDK, use the `embeddedEthereumWallets` property from the `PrivyUser` object:

        ```swift
        var embeddedEthereumWallets: [EmbeddedEthereumWallet] { get }
        ```

        ### Usage

        ```swift
        guard let user = privy.user else {
            // If user is null, user is not authenticated
            return
        }

        // Retrieve list of user's embedded Ethereum wallets
        let ethereumWallets = user.embeddedEthereumWallets

        // Grab the desired wallet. Here, we retrieve the first wallet
        guard let ethereumWallet = ethereumWallets.first else {
            // No ETH wallets
            return
        }
        ```
      </Tab>

      <Tab title="Solana">
        To access connected Solana wallets using the Swift SDK, use the `embeddedSolanaWallets` property from the `PrivyUser` object:

        ```swift
        var embeddedSolanaWallets: [EmbeddedSolanaWallet] { get }
        ```

        ### Usage

        ```swift
        guard let user = privy.user else {
            // User is not authenticated
            return
        }

        // Retrieve list of user's embedded Solana wallets
        let solanaWallets = user.embeddedSolanaWallets

        // Grab the desired wallet. Here, we retrieve the first wallet
        guard let solanaWallet = solanaWallets.first else {
            // No SOL wallets
            return
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Ethereum">
        To access connected Ethereum wallets using the Android SDK, use the `embeddedEthereumWallets` property from the `PrivyUser` object:

        ```kotlin
        val embeddedEthereumWallets: List<EmbeddedEthereumWallet>
        ```

        ### Usage

        ```kotlin
        val user = privy.user
        if (user != null) {
            val ethereumWallets = user.embeddedEthereumWallets
            if (ethereumWallets.isNotEmpty()) {
                val ethereumWallet = ethereumWallets.first()
            }
        }
        ```

        The **`embeddedEthereumWallets`** property includes an array of objects for all Ethereum wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>

      <Tab title="Solana">
        To access connected Solana wallets using the Android SDK, use the `embeddedSolanaWallets` property from the `PrivyUser` object:

        ```kotlin
        val embeddedSolanaWallets: List<EmbeddedSolanaWallet>
        ```

        ### Usage

        ```kotlin
        val user = privy.user
        if (user != null) {
            val solanaWallets = user.embeddedSolanaWallets
            if (solanaWallets.isNotEmpty()) {
                val solanaWallet = solanaWallets.first()
            }
        }
        ```

        The **`embeddedSolanaWallets`** property includes an array of objects for all Solana wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Tabs>
      <Tab title="Ethereum">
        To retrieve a user's Ethereum wallet using the Flutter SDK, follow these steps:

        ```dart
        final user = privy.user;
        final EmbeddedEthereumWallet ethereumWallet = user.embeddedEthereumWallets.first;
        ```

        ### Usage

        ```dart
        import 'package:privy_flutter/privy_flutter.dart';

        // Get the user's first Ethereum wallet
        final user = privy.user;
        if (user != null && user.embeddedEthereumWallets.isNotEmpty) {
          final wallet = user.embeddedEthereumWallets.first;

          // Access wallet properties
          final address = wallet.address;
        }
        ```

        The **`embeddedEthereumWallets`** property includes an array of objects for all Ethereum wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>

      <Tab title="Solana">
        To retrieve a user's Solana wallet using the Flutter SDK, follow these steps:

        ```dart
        final user = privy.user;
        final EmbeddedSolanaWallet solanaWallet = user.embeddedSolanaWallets.first;
        ```

        ### Usage

        ```dart
        import 'package:privy_flutter/privy_flutter.dart';

        // Get the user's first Solana wallet
        final user = privy.user;
        if (user != null && user.embeddedSolanaWallets.isNotEmpty) {
          final wallet = user.embeddedSolanaWallets.first;

          // Access wallet properties
          final address = wallet.address;
        }
        ```

        The **`embeddedSolanaWallets`** property includes an array of objects for all Solana wallets a user has connected to your app. The array is ordered from most recently connected to least recently connected.
      </Tab>
    </Tabs>
  </Tab>
</Tabs>


# Get wallet by ID
Source: https://docs.privy.io/wallets/wallets/get-a-wallet/get-wallet-by-id



You can get a specific wallet by its ID from the Privy API using `server-auth` or our REST API.

Note this is a wallet-centric abstraction. You may be looking for a way to [find a given user's wallets](/user-management/users/managing-users/querying-users).

<Tabs>
  <Tab title="NodeJS">
    To get a wallet by ID, use the `getWallet` method.

    ```tsx
    getWallet: ({id}: {id: string}) => Promise<WalletApiWalletResponseType>
    ```

    ### Usage

    ```tsx
    const wallet = await client.wallets.getWallet({id: walletId});
    ```

    ### Parameters

    <ParamField path="id" type="string">
      The ID of the wallet to get
    </ParamField>

    ### Returns

    <ResponseField name="wallet" type="WalletApiWalletResponseType">
      <Expandable defaultOpen="true">
        <ResponseField name="id" type="string">
          Unique ID of the wallet
        </ResponseField>

        <ResponseField name="address" type="string">
          Address of the wallet
        </ResponseField>

        <ResponseField name="chainType" type="'ethereum' | 'solana'">
          Chain type of the wallet
        </ResponseField>

        <ResponseField name="policyIds" type="string[]">
          List of policy IDs associated with the wallet
        </ResponseField>

        <ResponseField type="string | null" name="ownerId">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="{signerId: string}[]" name="additionalSigners">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField name="createdAt" type="Date">
          The creation date of the wallet
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>

  <Tab title="REST API">
    To get a wallet by ID, make a `GET` request to:

    ```
    https://api.privy.io/v1/wallets/[wallet-id]
    ```

    ### Response

    <ResponseField name="data" type="WalletApiWalletResponseType">
      The wallet object

      <Expandable defaultOpen="true">
        <ResponseField name="id" type="string">
          Unique ID of the wallet
        </ResponseField>

        <ResponseField name="address" type="string">
          Address of the wallet
        </ResponseField>

        <ResponseField name="chain_type" type="'ethereum' | 'solana'">
          Chain type of the wallet
        </ResponseField>

        <ResponseField name="policy_ids" type="string[]">
          List of policy IDs associated with the wallet
        </ResponseField>

        <ResponseField type="string | null" name="owner_id">
          The key quorum ID of the owner of the wallet.
        </ResponseField>

        <ResponseField type="{signer_id: string}[]" name="additional_signers">
          The key quorum IDs of the additional signers for the wallet.
        </ResponseField>

        <ResponseField name="created_at" type="number">
          The creation date of the wallet, in milliseconds since midnight, January 1, 1970 UTC.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Tab>
</Tabs>


# Import a wallet
Source: https://docs.privy.io/wallets/wallets/import



**Privy enables your users to import a private key into their embedded wallet**.

This allows users to bring an existing wallet into your application, enabling them to manage their assets directly within your app. For example, a user can import their MetaMask wallet private key to access and manage their assets within your app seamlessly. This method can also be used by developers to migrate users from a different embedded wallet provider to Privy.

<Info>
  Privy's React SDK currently supports importing wallets on **EVM networks** and **Solana**.
</Info>

## Importing a wallet by private key

To have your user import a private key into their embedded wallet, **use the `importWallet` method from the `useImportWallet` hook.** As a parameter to this method, pass an object containing the user's `privateKey` as a `string`.

<Tabs key="chain-type">
  <Tab title="EVM">
    ```tsx
    import {usePrivy, useImportWallet} from '@privy-io/react-auth';

    function ImportWalletButton() {
      const {ready, authenticated} = usePrivy();
      const {importWallet} = useImportWallet();
      const [privateKey, setPrivateKey] = useState('');

      const handleImport = async () => {
        try {
          const wallet = await importWallet({privateKey: privateKey});
          console.log('Wallet imported successfully:', wallet);
        } catch (error) {
          console.error('Failed to import wallet:', error);
        }
      };

      // Check that your user is authenticated
      const isAuthenticated = ready && authenticated;

      return (
        <div>
          <input
            type="text"
            value={privateKey}
            onChange={(e) => setPrivateKey(e.target.value)}
            placeholder="Enter your private key"
          />
          <button onClick={handleImport} disabled={!isAuthenticated}>
            Import my wallet
          </button>
        </div>
      );
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx
    import {usePrivy} from '@privy-io/react-auth';
    import {useImportWallet} from '@privy-io/react-auth/solana';

    function ImportWalletButton() {
      const {ready, authenticated} = usePrivy();
      const {importWallet} = useImportWallet();
      const [privateKey, setPrivateKey] = useState('');

      const handleImport = async () => {
        try {
          const wallet = await importWallet({privateKey: privateKey});
          console.log('Wallet imported successfully:', wallet);
        } catch (error) {
          console.error('Failed to import wallet:', error);
        }
      };

      // Check that your user is authenticated
      const isAuthenticated = ready && authenticated;

      return (
        <div>
          <input
            type="text"
            value={privateKey}
            onChange={(e) => setPrivateKey(e.target.value)}
            placeholder="Enter your private key"
          />
          <button onClick={handleImport} disabled={!isAuthenticated}>
            Import my wallet
          </button>
        </div>
      );
    }
    ```
  </Tab>
</Tabs>

If `importWallet` succeeds, the imported wallet will be added to the user's `linkedAccounts` and the `wallets` array returned by the `useWallets` hook, with an `imported` field that is marked `true`. As an example, you can find the imported wallet like so:

<Tabs key="chain-type">
  <Tab title="EVM">
    ```tsx
    import {useWallets} from '@privy-io/react-auth';

    function ImportedWalletInfo() {
      const {wallets} = useWallets();
      const importedWallet = wallets.find((wallet) => wallet.imported);
      return (
        <div>
          <h3>Imported Wallet</h3>
          {importedWallet ? <p>Address: {importedWallet.address}</p> : <p>No imported wallet found</p>}
        </div>
      );
    }
    ```
  </Tab>

  <Tab title="Solana">
    ```tsx
    import {useSolanaWallets} from '@privy-io/react-auth/solana';

    function ImportedWalletInfo() {
      const {wallets} = useSolanaWallets();
      const importedWallet = wallets.find((wallet) => wallet.imported);
      return (
        <div>
          <h3>Imported Wallet</h3>
          {importedWallet ? <p>Address: {importedWallet.address}</p> : <p>No imported wallet found</p>}
        </div>
      );
    }
    ```
  </Tab>
</Tabs>

This method will error if the provided private key is not valid or if the user has previously imported a wallet by private key.

## Using imported EVM embedded wallets

You can request signatures and transactions from imported wallets using Privy's [native methods](/recipes/react/import-wallet#using-privy%E2%80%99s-native-signature-and-transaction-methods), the wallet's [EIP1193 provider](/recipes/react/import-wallet#using-the-eip1193-provider%2C-viem%2C-and-ethers), or a [third-party library](/recipes/react/import-wallet#using-the-eip1193-provider%2C-viem%2C-and-ethers) like `viem` or `ethers`.

#### Using Privy's native signature and transaction methods

To use Privy's native `signMessage`, `signTypedData`, and `sendTransaction` methods with an imported wallet, simply pass the address for the imported wallet as the final optional parameter to these methods:

<Tabs key="chain-type">
  <Tab title="signMessage">
    ```tsx
    const {signMessage} = usePrivy();
    const signature = await signMessage(
      'insert-message-to-sign',
      insertOptionalUIConfigOrUndefined,
      'insert-imported-wallet-address' // Replace with the imported wallet address in EIP55 format
    );
    ```
  </Tab>

  <Tab title="signTypedData">
    ```tsx
    const {signTypedData} = usePrivy();
    const signature = await signTypedData(
      insertTypedDataObject,
      insertOptionalUIConfigOrUndefined,
      'insert-imported-wallet-address' // Replace with the imported wallet address in EIP55 format
    );
    ```
  </Tab>

  <Tab title="sendTransaction">
    ```tsx
    const {sendTransaction} = usePrivy();
    const signature = await sendTransaction(
      insertTransactionRequest,
      insertOptionalUIConfigOrUndefined,
      insertOptionalFundingConfigOrUndefined
      'insert-imported-wallet-address', // Replace with the imported wallet address in EIP55 format
    );
    ```
  </Tab>
</Tabs>

#### Using the EIP1193 provider, viem, and ethers

You can also request signatures and transactions from an imported wallet using the wallet's EIP1193 provider or a library like `viem` or `ethers`.

To get the EIP1193 provider for the imported wallet, first find the corresponding `ConnectedWallet` object from the `useWallets` array:

```tsx
const {wallets} = useWallets();
// `ConnectedWallet.imported` is set to `true` for imported wallets
const importedWallet = wallets.find(
  (wallet) => wallet.walletClientType === 'privy' && wallet.imported
);
```

Then, call the object's `getEthereumProvider` method to get an EIP1193 provider for that wallet:

```tsx
const provider = await importedWallet.getEthereumProvider();
```

You can then easily pass that EIP1193 provider to a library like [`viem`](/wallets/using-wallets/ethereum/web3-integrations) or [`ethers`](/wallets/using-wallets/ethereum/web3-integrations) to use those libraries' interfaces to send requests to the wallet.

## Using imported Solana embedded wallets

You can request signatures and send transactions using your imported Solana wallet just like with regular embedded Solana wallets.

```tsx
const {wallets} = useSolanaWallets();
// `ConnectedWallet.imported` is set to `true` for imported wallets
const importedWallet = wallets.find(
  (wallet) => wallet.walletClientType === 'privy' && wallet.imported
);
```

Then, call the object's `signMessage` method to sign.

```tsx
const signature = await importedWallet.sign('Sign this message!');
```

## Exporting imported embedded wallets

**Privy enables your users to export the full private key for their embedded wallet, even if it was imported**. This allows them to use their embedded wallet address with another wallet client, such as MetaMask in any application.

<Tabs key="chain-type">
  <Tab title="EVM">
    To have your user export their embedded wallet's private key, **use the `exportWallet` method from the `usePrivy` hook.** As a parameter to this method, you must pass an object containing an `address` field with the user's imported wallet address as a `string`.

    As an example, you might have an export wallet button in your app like so:

    ```tsx
    import {usePrivy, useWallets} from '@privy-io/react-auth';

    function ExportWalletButton() {
      const {ready, authenticated, exportWallet} = usePrivy();
      const {wallets} = useWallets();
      // Check that your user is authenticated
      const isAuthenticated = ready && authenticated;
      // Find your user's imported wallet
      const importedWallet = wallets.find(
        (wallet) => wallet.walletClientType === 'privy' && wallet.imported
      );

      const exportImportedWallet = async () => {
        if (!importedWallet) return;
        await exportWallet({address: importedWallet.address});
      };

      return (
        <button onClick={exportImportedWallet} disabled={!isAuthenticated || !importedWallet}>
          Export my wallet
        </button>
      );
    }
    ```
  </Tab>

  <Tab title="Solana">
    To have your user export their embedded wallet's private key, **use the `exportWallet` method from the `useSolanaWallets` hook.** As a parameter to this method, you must pass an object containing an `address` field with the user's imported wallet address as a `string`.

    As an example, you might have an export wallet button in your app like so:

    ```tsx
    import {usePrivy} from '@privy-io/react-auth';
    import {useSolanaWallets} from '@privy-io/react-auth/solana';

    function ExportWalletButton() {
      const {ready, authenticated} = usePrivy();
      const {wallets, exportWallet} = useSolanaWallets();
      // Check that your user is authenticated
      const isAuthenticated = ready && authenticated;
      // Find your user's imported wallet
      const importedWallet = wallets.find(
        (wallet) => wallet.walletClientType === 'privy' && wallet.imported
      );

      const exportImportedWallet = async () => {
        if (!importedWallet) return;
        await exportWallet({address: importedWallet.address});
      };

      return (
        <button onClick={exportImportedWallet} disabled={!isAuthenticated || !importedWallet}>
          Export my wallet
        </button>
      );
    }
    ```
  </Tab>
</Tabs>

<Info>
  Exporting the seed phrase for an imported embedded wallet is not supported, as it is impossible to
  recover the full seed phrase for the wallet from the imported private key.
</Info>


# Update a wallet
Source: https://docs.privy.io/wallets/wallets/update-a-wallet



<Warning>
  The following functionality exists for [wallets reconstituted
  server-side](/wallets/wallets/create/from-my-server). More on [Privy architecture
  here](https://docs.privy.io/security/wallet-infrastructure/secure-execution-environments/secure-enclave)
</Warning>

Privy enables you to update the policies and authorization keys for a wallet that is provisioned for server-side access.

<Info>
  Prior to updating a wallet, the wallet must be [provisioned for server-side
  access](/wallets/using-wallets/session-signers/overview).
</Info>

<Tabs>
  <Tab title="REST API">
    To update an existing wallet, make a `PATCH` request to:

    ```
    https://api.privy.io/v1/wallets/<wallet_id>
    ```

    <Info>
      Wallets with `owner_id` present must provide an [authorization signature](/api-reference/authorization-signatures) as a request header.
    </Info>

    ### Body

    In the request body, include the following fields:

    <ParamField path="policy_ids" type="string[]">
      New policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet.
    </ParamField>

    <ParamField type="{public_key: string} | null" path="owner">
      The P-256 public key of the owner of the wallet. If you provide this, do not specify an owner\_id as it will be generated automatically.
    </ParamField>

    <ParamField type="string | null" path="owner_id">
      The key quorum ID of the owner of the wallet. If you provide this, do not specify an owner.
    </ParamField>

    <ParamField type="{signer_id: string}[]" path="additional_signers">
      The key quorum IDs to add as additional signers for the wallet.
    </ParamField>

    Any fields not included in the `PATCH` request body will remain unchanged from the original wallet.

    ### Response

    If the wallet is updated successfully, the response will include the updated wallet.

    <ResponseField name="id" type="string">
      Unique ID for the wallet.
    </ResponseField>

    <ResponseField name="address" type="string">
      Address of the wallet.
    </ResponseField>

    <ResponseField name="chain_type" type="'ethereum'">
      Chain type for the wallet.
    </ResponseField>

    <ResponseField name="policy_ids" type="MethodRule">
      Updated policy IDs to enforce on the wallet.
    </ResponseField>

    <ResponseField type="string | null" name="owner_id">
      The key quorum ID of the owner of the wallet.
    </ResponseField>

    <ResponseField type="{signer_id: string}[]" name="additional_signers">
      The key quorum IDs of the additional signers for the wallet.
    </ResponseField>

    ### Example

    A sample request might look like the following:

    ```tsx
    $ curl --request PATCH https://api.privy.io/v1/wallets/rbokq6mmq5f8j1cgyr6a5g4n \
    -u "<your-privy-app-id>:<your-privy-app-secret>" \
    -H "privy-app-id: <your-privy-app-id>" \
    -H "privy-authorization-signature: <authorization-signature-for-request>" \
    -H 'Content-Type: application/json' \
    --data '{
        "policy_ids": ["fmfdj6yqly31huorjqzq38zc"],
        "owner_id": "yhu8t1fjns9rtc2o702ub3vt",
        "additional_signers": [{"signer_id": "trt9syg5k19jvxwbnt6t8rd0"}]
    }'
    ```

    A successful response will look like the following:

    ```tsx
    {
      "id": "rbokq6mmq5f8j1cgyr6a5g4n",
      "address": "0xE315ce0854CcbdB0E33e71af1190F48Eb5d4f5a4",
      "chain_type": "ethereum",
      "policy_ids": ["fmfdj6yqly31huorjqzq38zc"],
      "owner_id": "yhu8t1fjns9rtc2o702ub3vt",
      "additional_signers": [
        {
          "signer_id": "trt9syg5k19jvxwbnt6t8rd0"
        }
      ],
      "created_at": 1737492220389
    }
    ```
  </Tab>
</Tabs>


# Welcome
Source: https://docs.privy.io/welcome



export const Logo = ({img, name, href, className}) => {
  return <a href={href} className={'block not-prose font-normal rounded-md cursor-pointer ' + (className || '')} onClick={e => {
    if (href) {
      e.preventDefault();
      window.location.href = href;
    }
  }}>
      <div className="card h-20 w-20 p-2 object-cover overflow-hidden flex items-center justify-center">
        <img src={img} alt={name} noZoom />
      </div>
      <p className="text-nowrap text-center text-xs mt-2">{name}</p>
    </a>;
};

<div className="hero">
  <div className="text-center">
    <h1>Build with Privy.</h1>
  </div>

  <p className="text-center font-medium details-text">
    Privy builds user onboarding and wallet infrastructure to enable better products built on crypto
    rails by embedding asset control directly into your product.
  </p>

  <div id="hero-search" className="search" onClick={() => clickOnSearch()}>
    <span>Help me learn how to...</span>

    <Icon icon="magnifying-glass" iconType="solid" size={14} />
  </div>

  <div className="text-sm flex items-center justify-center gap-1 font-medium">
    <a href="basics/get-started/account" className="no-underline">
      Get started
    </a>

    <Icon icon="arrow-right" iconType="solid" size={12} />
  </div>
</div>

<div className="max-w-3xl px-4 mx-auto lg:px-8 pb-10">
  <div className="text-center text-sm mb-6">
    <h2 className="subtitle">Quickstarts & recipes</h2>
  </div>

  <CardGroup cols={3}>
    <Card title="Create your first wallet" icon="wallet" href="/basics/react/quickstart">
      Use the React SDK to authenticate a user and create an embedded wallet.
    </Card>

    <Card title="Build a mobile app" icon="mobile" href="/basics/react-native/quickstart">
      Use the React Native SDK to build a mobile app on Solana.
    </Card>

    <Card title="Fund wallets with Apple Pay" icon="money-bill" href="/recipes/card-based-funding">
      Fund user wallets with convenient payment methods like Apple Pay and Google Pay.
    </Card>
  </CardGroup>

  <div className="text-center text-sm mt-12 mb-6">
    <h2 className="subtitle">Explore SDKs</h2>
  </div>

  <div className="flex flex-wrap gap-3 justify-between">
    <Logo name="React" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/react-logo.png" href="basics/react/setup" />

    <Logo name="React Native" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/expo-logo.png" className="dark:hidden" href="basics/react-native/setup" />

    <Logo name="Expo" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/expo-logo-dark.png" className="hidden dark:block" href="basics/react-native/setup" />

    <Logo name="iOS (Swift)" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/swift-logo.png" href="basics/swift/setup" />

    <Logo name="Android (Kotlin)" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/android-logo.png" href="/basics/android/setup" />

    <Logo name="Unity" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/unity-logo.png" className="dark:hidden" href="basics/unity/setup" />

    <Logo name="Unity" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/unity-logo-dark.png" className="hidden dark:block" href="basics/unity/setup" />

    <Logo name="Flutter" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/flutter-logo.png" href="basics/flutter/setup" />

    <Logo name="REST API" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/rest-api-logo.png" href="basics/rest-api/setup" className="dark:hidden" />

    <Logo name="REST API" img="https://mintlify.s3.us-west-1.amazonaws.com/privy-c2af3412/images/rest-api-logo-dark.png" href="basics/rest-api/setup" className="hidden dark:block" />
  </div>

  <div className="text-center text-sm mt-12 mb-6">
    <h2 className="subtitle">Resources</h2>
  </div>

  <CardGroup cols={3}>
    <Card title="Support" icon="slack" href="https://privy.io/slack">
      Join our Slack community to get support.
    </Card>

    <Card title="Recipes" icon="file-lines" href="recipes">
      Implement common Privy features and integrations.
    </Card>

    <Card title="Demo" icon="circle-play" href="https://demo.privy.io">
      Sign in to demo.privy.io to view Privy in action.
    </Card>
  </CardGroup>
</div>

